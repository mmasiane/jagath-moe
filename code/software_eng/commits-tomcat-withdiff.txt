commit 39a61f97d45636de0be8cd8b4c5289a4ed1e5bbd
Author: Mark Thomas <markt@apache.org>
Date:   Thu Nov 5 21:06:00 2015 +0000

    Fix https://bz.apache.org/bugzilla/show_bug.cgi?id=58585
    Fix security exceptions when starting with a security manager.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1712866 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/connector/OutputBuffer.java b/java/org/apache/catalina/connector/OutputBuffer.java
index df30177..5f2ffd7 100644
--- a/java/org/apache/catalina/connector/OutputBuffer.java
+++ b/java/org/apache/catalina/connector/OutputBuffer.java
@@ -558,7 +558,7 @@ public class OutputBuffer extends Writer
             enc = org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING;
         }
 
-        final Charset charset = B2CConverter.getCharset(enc);
+        final Charset charset = getCharset(enc);
         SynchronizedStack<C2BConverter> stack = encoders.get(charset);
         if (stack == null) {
             stack = new SynchronizedStack<>();
@@ -573,6 +573,30 @@ public class OutputBuffer extends Writer
     }
 
 
+    private static Charset getCharset(String encoding) throws IOException {
+        if (Globals.IS_SECURITY_ENABLED) {
+            try {
+                return AccessController.doPrivileged(
+                        new PrivilegedExceptionAction<Charset>() {
+                            @Override
+                            public Charset run() throws IOException {
+                                return B2CConverter.getCharset(encoding);
+                            }
+                        });
+            } catch (PrivilegedActionException ex) {
+                Exception e = ex.getException();
+                if (e instanceof IOException) {
+                    throw (IOException) e;
+                } else {
+                    throw new IOException(ex);
+                }
+            }
+        } else {
+            return B2CConverter.getCharset(encoding);
+        }
+    }
+
+
     private static C2BConverter createConverter(Charset charset) throws IOException {
         if (Globals.IS_SECURITY_ENABLED){
             try {
diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index 6ef0631..7982004 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -70,6 +70,9 @@ public final class SecurityClassLoad {
              "ApplicationDispatcher$PrivilegedInclude");
         loader.loadClass
             (basePackage +
+             "ApplicationPushBuilder");
+        loader.loadClass
+            (basePackage +
             "AsyncContextImpl");
         loader.loadClass
             (basePackage +
@@ -167,6 +170,7 @@ public final class SecurityClassLoad {
         // Make sure system property is read at this point
         Class<?> clazz = loader.loadClass(basePackage + "Constants");
         clazz.newInstance();
+        loader.loadClass(basePackage + "http2.Stream$1");
     }
 
 
@@ -232,6 +236,9 @@ public final class SecurityClassLoad {
              "OutputBuffer$1");
         loader.loadClass
             (basePackage +
+             "OutputBuffer$2");
+        loader.loadClass
+            (basePackage +
              "CoyoteInputStream$1");
         loader.loadClass
             (basePackage +
@@ -268,10 +275,17 @@ public final class SecurityClassLoad {
         loader.loadClass(basePackage + "util.buf.StringCache");
         loader.loadClass(basePackage + "util.buf.StringCache$ByteEntry");
         loader.loadClass(basePackage + "util.buf.StringCache$CharEntry");
+        // collections
+        loader.loadClass(basePackage + "util.collections.CaseInsensitiveKeyMap");
+        loader.loadClass(basePackage + "util.collections.CaseInsensitiveKeyMap$EntryImpl");
+        loader.loadClass(basePackage + "util.collections.CaseInsensitiveKeyMap$EntryIterator");
+        loader.loadClass(basePackage + "util.collections.CaseInsensitiveKeyMap$EntrySet");
+        loader.loadClass(basePackage + "util.collections.CaseInsensitiveKeyMap$Key");
         // http
+        loader.loadClass(basePackage + "util.http.CookieProcessor");
+        loader.loadClass(basePackage + "util.http.NamesEnumerator");
         // Make sure system property is read at this point
-        Class<?> clazz = loader.loadClass(
-                basePackage + "util.http.FastHttpDateFormat");
+        Class<?> clazz = loader.loadClass(basePackage + "util.http.FastHttpDateFormat");
         clazz.newInstance();
         loader.loadClass(basePackage + "util.http.parser.HttpParser");
         loader.loadClass(basePackage + "util.http.parser.MediaType");
diff --git a/java/org/apache/coyote/http2/Stream.java b/java/org/apache/coyote/http2/Stream.java
index 8753404..fb807d8 100644
--- a/java/org/apache/coyote/http2/Stream.java
+++ b/java/org/apache/coyote/http2/Stream.java
@@ -18,6 +18,9 @@ package org.apache.coyote.http2;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import java.util.Iterator;
 
 import org.apache.coyote.ActionCode;
@@ -387,10 +390,36 @@ public class Stream extends AbstractStream implements HeaderEmitter {
         // TODO: Handle default ports
         request.getMimeHeaders().addValue(":authority").setString(
                 request.serverName().getString() + ":" + request.getServerPort());
-        handler.push(request, this);
+        push (handler, request, this);
     }
 
 
+    private static void push(Http2UpgradeHandler handler, Request request, Stream stream)
+            throws IOException {
+        if (org.apache.coyote.Constants.IS_SECURITY_ENABLED) {
+            try {
+                AccessController.doPrivileged(
+                        new PrivilegedExceptionAction<Void>() {
+                            @Override
+                            public Void run() throws IOException {
+                                handler.push(request, stream);
+                                return null;
+                            }
+                        });
+            } catch (PrivilegedActionException ex) {
+                Exception e = ex.getException();
+                if (e instanceof IOException) {
+                    throw (IOException) e;
+                } else {
+                    throw new IOException(ex);
+                }
+            }
+
+        } else {
+            handler.push(request, stream);
+        }
+    }
+
     class StreamOutputBuffer implements OutputBuffer {
 
         private final ByteBuffer buffer = ByteBuffer.allocate(8 * 1024);

commit be331815405615b1c729c7bdc9898cfed9ae14dc
Author: Mark Thomas <markt@apache.org>
Date:   Thu Jul 30 14:12:17 2015 +0000

    Fix https://bz.apache.org/bugzilla/show_bug.cgi?id=58125
    Avoid a possible ClassCircularityError when running under a security manager
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1693429 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/loader/WebappClassLoaderBase.java b/java/org/apache/catalina/loader/WebappClassLoaderBase.java
index b21a50e..c1fbd63 100644
--- a/java/org/apache/catalina/loader/WebappClassLoaderBase.java
+++ b/java/org/apache/catalina/loader/WebappClassLoaderBase.java
@@ -1228,8 +1228,25 @@ public abstract class WebappClassLoaderBase extends URLClassLoader
             //       the webapp from overriding Java SE classes. This implements
             //       SRV.10.7.2
             String resourceName = binaryNameToPath(name, false);
+
             ClassLoader javaseLoader = getJavaseClassLoader();
-            if (javaseLoader.getResource(resourceName) != null) {
+            boolean tryLoadingFromJavaseLoader;
+            try {
+                // Use getResource as it won't trigger an expensive
+                // ClassNotFoundException if the resource is not available from
+                // the Java SE class loader. However (see
+                // https://bz.apache.org/bugzilla/show_bug.cgi?id=58125 for
+                // details) when running under a security manager in rare cases
+                // this call may trigger a ClassCircularityError.
+                tryLoadingFromJavaseLoader = (javaseLoader.getResource(resourceName) != null);
+            } catch (ClassCircularityError cce) {
+                // The getResource() trick won't work for this class. We have to
+                // try loading it directly and accept that we might get a
+                // ClassNotFoundException.
+                tryLoadingFromJavaseLoader = true;
+            }
+
+            if (tryLoadingFromJavaseLoader) {
                 try {
                     clazz = javaseLoader.loadClass(name);
                     if (clazz != null) {

commit 72db186aff0fefdd235e71d9fc30a02281928a87
Author: Mark Thomas <markt@apache.org>
Date:   Fri Jun 26 07:46:48 2015 +0000

    Remove realm name and authentication type from security messages, this information is set up per module now
    Patch by fjodorver
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1687700 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/authenticator/jaspic/JaspicAuthenticator.java b/java/org/apache/catalina/authenticator/jaspic/JaspicAuthenticator.java
index 07bb256..f342951 100644
--- a/java/org/apache/catalina/authenticator/jaspic/JaspicAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/jaspic/JaspicAuthenticator.java
@@ -68,8 +68,7 @@ public class JaspicAuthenticator extends AuthenticatorBase {
             return true;
         }
 
-        MessageInfoImpl messageInfo = new MessageInfoImpl(request, response, true, getAuthMethod());
-        messageInfo.setRealmName(getRealmName(context));
+        MessageInfoImpl messageInfo = new MessageInfoImpl(request, response, true);
 
         AuthConfigFactory factory = AuthConfigFactory.getFactory();
         String appContext = getAppContextId(request);
diff --git a/java/org/apache/catalina/authenticator/jaspic/MessageInfoImpl.java b/java/org/apache/catalina/authenticator/jaspic/MessageInfoImpl.java
index fccd891..7c01dde 100644
--- a/java/org/apache/catalina/authenticator/jaspic/MessageInfoImpl.java
+++ b/java/org/apache/catalina/authenticator/jaspic/MessageInfoImpl.java
@@ -27,8 +27,6 @@ import org.apache.catalina.connector.Request;
 
 public class MessageInfoImpl implements MessageInfo {
     public static final String IS_MANDATORY = "javax.security.auth.message.MessagePolicy.isMandatory";
-    public static final String AUTH_METHOD = "javax.servlet.http.authType";
-    public static final String REALM_NAME = "javax.servlet.http.realmName";
 
     private final Map<String, Object> map = new HashMap<>();
     private HttpServletRequest request;
@@ -37,16 +35,10 @@ public class MessageInfoImpl implements MessageInfo {
     public MessageInfoImpl() {
     }
 
-    public MessageInfoImpl(Request request, HttpServletResponse response, boolean authMandatory,
-            String authMethod) {
+    public MessageInfoImpl(Request request, HttpServletResponse response, boolean authMandatory) {
         this.request = request;
         this.response = response;
         map.put(IS_MANDATORY, Boolean.toString(authMandatory));
-        map.put(AUTH_METHOD, authMethod);
-    }
-
-    public void setRealmName(String realmName) {
-        map.put(REALM_NAME, realmName);
     }
 
     @Override
diff --git a/java/org/apache/catalina/authenticator/jaspic/provider/TomcatAuthConfig.java b/java/org/apache/catalina/authenticator/jaspic/provider/TomcatAuthConfig.java
index a0ba572..6c4bbad 100644
--- a/java/org/apache/catalina/authenticator/jaspic/provider/TomcatAuthConfig.java
+++ b/java/org/apache/catalina/authenticator/jaspic/provider/TomcatAuthConfig.java
@@ -16,6 +16,7 @@
  */
 package org.apache.catalina.authenticator.jaspic.provider;
 
+import java.util.HashMap;
 import java.util.Map;
 
 import javax.security.auth.Subject;
@@ -88,12 +89,20 @@ public class TomcatAuthConfig implements ServerAuthConfig {
     public synchronized ServerAuthContext getAuthContext(String authContextID,
             Subject serviceSubject, Map properties) throws AuthException {
         if (this.tomcatServerAuthContext == null) {
-            this.tomcatServerAuthContext = new TomcatServerAuthContext(handler, getModule());
+            this.tomcatServerAuthContext = new TomcatServerAuthContext(handler, getModule(),
+                    getOptions());
         }
         return tomcatServerAuthContext;
     }
 
 
+    private Map<String, String> getOptions() {
+        Map<String, String> options = new HashMap<>();
+        options.put(TomcatAuthModule.REALM_NAME, getRealmName());
+        return options;
+    }
+
+
     private TomcatAuthModule getModule() throws AuthException {
         String authMethod = getAuthMethod();
         switch (authMethod) {
@@ -111,6 +120,11 @@ public class TomcatAuthConfig implements ServerAuthConfig {
     }
 
 
+    private String getRealmName() {
+        return loginConfig.getRealmName();
+    }
+
+
     /**
      * Temporary workaround to get authentication method
      * @return
diff --git a/java/org/apache/catalina/authenticator/jaspic/provider/TomcatServerAuthContext.java b/java/org/apache/catalina/authenticator/jaspic/provider/TomcatServerAuthContext.java
index 7d4b1eb..4b269c9 100644
--- a/java/org/apache/catalina/authenticator/jaspic/provider/TomcatServerAuthContext.java
+++ b/java/org/apache/catalina/authenticator/jaspic/provider/TomcatServerAuthContext.java
@@ -16,7 +16,7 @@
  */
 package org.apache.catalina.authenticator.jaspic.provider;
 
-import java.util.Collections;
+import java.util.Map;
 
 import javax.security.auth.Subject;
 import javax.security.auth.callback.CallbackHandler;
@@ -33,15 +33,16 @@ import org.apache.tomcat.util.res.StringManager;
  */
 public class TomcatServerAuthContext implements ServerAuthContext {
 
-    protected static final StringManager sm = StringManager.getManager(TomcatServerAuthContext.class);
+    protected static final StringManager sm = StringManager
+            .getManager(TomcatServerAuthContext.class);
 
     private ServerAuthModule module;
 
 
-    public TomcatServerAuthContext(CallbackHandler handler, ServerAuthModule module)
-            throws AuthException {
+    public TomcatServerAuthContext(CallbackHandler handler, ServerAuthModule module,
+            Map<String, String> options) throws AuthException {
         this.module = module;
-        this.module.initialize(null, null, handler, Collections.emptyMap());
+        this.module.initialize(null, null, handler, options);
     }
 
 
diff --git a/java/org/apache/catalina/authenticator/jaspic/provider/modules/BasicAuthModule.java b/java/org/apache/catalina/authenticator/jaspic/provider/modules/BasicAuthModule.java
index 6faacc3..0653ce2 100644
--- a/java/org/apache/catalina/authenticator/jaspic/provider/modules/BasicAuthModule.java
+++ b/java/org/apache/catalina/authenticator/jaspic/provider/modules/BasicAuthModule.java
@@ -45,14 +45,10 @@ public class BasicAuthModule extends TomcatAuthModule {
     private Class<?>[] supportedMessageTypes = new Class[] { HttpServletRequest.class,
             HttpServletResponse.class };
 
-    private CallbackHandler handler;
-
-
     @SuppressWarnings("rawtypes")
     @Override
-    public void initialize(MessagePolicy requestPolicy, MessagePolicy responsePolicy,
+    public void initializeModule(MessagePolicy requestPolicy, MessagePolicy responsePolicy,
             CallbackHandler handler, Map options) throws AuthException {
-        this.handler = handler;
     }
 
 
@@ -67,7 +63,7 @@ public class BasicAuthModule extends TomcatAuthModule {
         HttpServletResponse response = (HttpServletResponse) messageInfo.getResponseMessage();
         String authorization = request.getHeader(AUTHORIZATION_HEADER);
 
-        String realmName = getRealmName(messageInfo);
+        String realmName = getRealmName();
 
         if (authorization == null) {
             return sendUnauthorizedError(response, realmName);
diff --git a/java/org/apache/catalina/authenticator/jaspic/provider/modules/DigestAuthModule.java b/java/org/apache/catalina/authenticator/jaspic/provider/modules/DigestAuthModule.java
index cf6fad6..7fbb5c4 100644
--- a/java/org/apache/catalina/authenticator/jaspic/provider/modules/DigestAuthModule.java
+++ b/java/org/apache/catalina/authenticator/jaspic/provider/modules/DigestAuthModule.java
@@ -180,9 +180,9 @@ public class DigestAuthModule extends TomcatAuthModule {
     }
 
 
-    @SuppressWarnings("rawtypes")
     @Override
-    public void initialize(MessagePolicy requestPolicy, MessagePolicy responsePolicy,
+    @SuppressWarnings("rawtypes")
+    public void initializeModule(MessagePolicy requestPolicy, MessagePolicy responsePolicy,
             CallbackHandler handler, Map options) throws AuthException {
         this.handler = handler;
         startInternal();
@@ -238,12 +238,12 @@ public class DigestAuthModule extends TomcatAuthModule {
         String authorization = request.getHeader(AUTHORIZATION_HEADER);
 
         DigestInfo digestInfo = new DigestInfo(getOpaque(), getNonceValidity(), getKey(), nonces,
-                isValidateUri());
+                isValidateUri(), getRealmName());
         if (authorization == null) {
 
             String nonce = generateNonce(request);
 
-            String authenticateHeader = getAuthenticateHeader(nonce, false, messageInfo);
+            String authenticateHeader = getAuthenticateHeader(nonce, false);
             return sendUnauthorizedError(response, authenticateHeader);
         }
 
@@ -251,7 +251,7 @@ public class DigestAuthModule extends TomcatAuthModule {
             return AuthStatus.SEND_FAILURE;
         }
 
-        if (digestInfo.validate(request, messageInfo)) {
+        if (digestInfo.validate(request)) {
             // TODO discuss a better way to get user roles
             principal = (GenericPrincipal) digestInfo.authenticate(realm);
         }
@@ -259,7 +259,7 @@ public class DigestAuthModule extends TomcatAuthModule {
         if (principal == null || digestInfo.isNonceStale()) {
             String nonce = generateNonce(request);
             boolean isNoncaneStale = principal != null && digestInfo.isNonceStale();
-            String authenticateHeader = getAuthenticateHeader(nonce, isNoncaneStale, messageInfo);
+            String authenticateHeader = getAuthenticateHeader(nonce, isNoncaneStale);
             return sendUnauthorizedError(response, authenticateHeader);
         }
 
@@ -389,10 +389,9 @@ public class DigestAuthModule extends TomcatAuthModule {
      * @param nonce nonce token
      * @return
      */
-    protected String getAuthenticateHeader(String nonce, boolean isNonceStale,
-            MessageInfo messageInfo) {
+    protected String getAuthenticateHeader(String nonce, boolean isNonceStale) {
 
-        String realmName = getRealmName(messageInfo);
+        String realmName = getRealmName();
 
         String template = "Digest realm=\"{0}\", qop=\"{1}\", nonce=\"{2}\", opaque=\"{3}\"";
         String authenticateHeader = MessageFormat.format(template, realmName, QOP, nonce,
@@ -425,13 +424,16 @@ public class DigestAuthModule extends TomcatAuthModule {
 
         private boolean nonceStale = false;
 
+        private String contextRealmName;
+
         public DigestInfo(String opaque, long nonceValidity, String key,
-                Map<String, NonceInfo> nonces, boolean validateUri) {
+                Map<String, NonceInfo> nonces, boolean validateUri, String contextRealmName) {
             this.opaque = opaque;
             this.nonceValidity = nonceValidity;
             this.key = key;
             this.nonces = nonces;
             this.validateUri = validateUri;
+            this.contextRealmName = contextRealmName;
         }
 
         public String getUsername() {
@@ -470,7 +472,7 @@ public class DigestAuthModule extends TomcatAuthModule {
             return true;
         }
 
-        public boolean validate(HttpServletRequest request, MessageInfo messageInfo) {
+        public boolean validate(HttpServletRequest request) {
             if ((userName == null) || (realmName == null) || (nonce == null) || (uri == null)
                     || (response == null)) {
                 return false;
@@ -507,8 +509,7 @@ public class DigestAuthModule extends TomcatAuthModule {
             }
 
             // Validate the Realm name
-            String lcRealm = getRealmName(messageInfo);
-            if (!lcRealm.equals(realmName)) {
+            if (!contextRealmName.equals(realmName)) {
                 return false;
             }
 
diff --git a/java/org/apache/catalina/authenticator/jaspic/provider/modules/TomcatAuthModule.java b/java/org/apache/catalina/authenticator/jaspic/provider/modules/TomcatAuthModule.java
index bab8cc2..cf24279 100644
--- a/java/org/apache/catalina/authenticator/jaspic/provider/modules/TomcatAuthModule.java
+++ b/java/org/apache/catalina/authenticator/jaspic/provider/modules/TomcatAuthModule.java
@@ -16,7 +16,13 @@
  */
 package org.apache.catalina.authenticator.jaspic.provider.modules;
 
+import java.util.Map;
+import java.util.Optional;
+
+import javax.security.auth.callback.CallbackHandler;
+import javax.security.auth.message.AuthException;
 import javax.security.auth.message.MessageInfo;
+import javax.security.auth.message.MessagePolicy;
 import javax.security.auth.message.module.ServerAuthModule;
 
 import org.apache.catalina.authenticator.jaspic.MessageInfoImpl;
@@ -24,17 +30,21 @@ import org.apache.tomcat.util.res.StringManager;
 
 public abstract class TomcatAuthModule implements ServerAuthModule {
 
+    public static final String REALM_NAME = "javax.servlet.http.realmName";
+    public static final String DEFAULT_REALM_NAME = "Authentication required";
+
     protected static final String AUTH_HEADER_NAME = "WWW-Authenticate";
     protected static final String AUTHORIZATION_HEADER = "authorization";
-    /**
-     * Default authentication realm name.
-     */
-    protected static final String REALM_NAME = "Authentication required";
+
     /**
      * The string manager for this package.
      */
     protected static final StringManager sm = StringManager.getManager(TomcatAuthModule.class);
 
+    protected String realmName;
+
+    protected CallbackHandler handler;
+
 
     protected boolean isMandatory(MessageInfo messageInfo) {
         String mandatory = (String) messageInfo.getMap().get(MessageInfoImpl.IS_MANDATORY);
@@ -42,11 +52,23 @@ public abstract class TomcatAuthModule implements ServerAuthModule {
     }
 
 
-    @SuppressWarnings("unchecked")
-    protected static String getRealmName(MessageInfo messageInfo) {
-        if (messageInfo == null) {
-            return REALM_NAME;
-        }
-        return (String) messageInfo.getMap().getOrDefault(MessageInfoImpl.REALM_NAME, REALM_NAME);
+     @SuppressWarnings("rawtypes")
+     @Override
+     public final void initialize(MessagePolicy requestPolicy, MessagePolicy responsePolicy,
+             CallbackHandler handler, Map options) throws AuthException {
+         this.handler = handler;
+         this.realmName = (String) options.get(REALM_NAME);
+         initializeModule(requestPolicy, responsePolicy, handler, options);
+    }
+
+
+    public String getRealmName() {
+        return Optional.of(realmName).orElse(DEFAULT_REALM_NAME);
     }
+
+
+     @SuppressWarnings("rawtypes")
+     public abstract void initializeModule(MessagePolicy requestPolicy,
+             MessagePolicy responsePolicy, CallbackHandler handler, Map options)
+             throws AuthException;
 }

commit 79a6bd00a49a01711b3e47b8f45725b399b2ba0f
Author: Mark Thomas <markt@apache.org>
Date:   Tue Jun 23 09:30:08 2015 +0000

    Store JASPIC auth method in security message
    Patch by fjodorver
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1687005 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/authenticator/jaspic/JaspicAuthenticator.java b/java/org/apache/catalina/authenticator/jaspic/JaspicAuthenticator.java
index 6f14d0c..8ee98c7 100644
--- a/java/org/apache/catalina/authenticator/jaspic/JaspicAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/jaspic/JaspicAuthenticator.java
@@ -46,7 +46,7 @@ public class JaspicAuthenticator extends AuthenticatorBase {
     private static final Log log = LogFactory.getLog(JaspicAuthenticator.class);
 
     private static final String AUTH_TYPE = "JASPIC";
-    private static final String MESSAGE_LAYER = "HttpServlet";
+    public static final String MESSAGE_LAYER = "HttpServlet";
 
     private Subject serviceSubject;
 
@@ -65,7 +65,7 @@ public class JaspicAuthenticator extends AuthenticatorBase {
 
     @Override
     public boolean authenticate(Request request, HttpServletResponse response) throws IOException {
-        MessageInfo messageInfo = new MessageInfoImpl(request, response, true);
+        MessageInfo messageInfo = new MessageInfoImpl(request, response, true, getAuthMethod());
 
         AuthConfigFactory factory = AuthConfigFactory.getFactory();
         String appContext = getAppContextId(request);
@@ -149,6 +149,6 @@ public class JaspicAuthenticator extends AuthenticatorBase {
 
     @Override
     protected String getAuthMethod() {
-        return AUTH_TYPE;
+        return context.getLoginConfig().getAuthMethod();
     }
 }
diff --git a/java/org/apache/catalina/authenticator/jaspic/MessageInfoImpl.java b/java/org/apache/catalina/authenticator/jaspic/MessageInfoImpl.java
index 0946256..8d210a0 100644
--- a/java/org/apache/catalina/authenticator/jaspic/MessageInfoImpl.java
+++ b/java/org/apache/catalina/authenticator/jaspic/MessageInfoImpl.java
@@ -26,7 +26,8 @@ import javax.servlet.http.HttpServletResponse;
 import org.apache.catalina.connector.Request;
 
 public class MessageInfoImpl implements MessageInfo {
-    private static final String IS_MANDATORY = "javax.security.auth.message.MessagePolicy.isMandatory";
+    public static final String IS_MANDATORY = "javax.security.auth.message.MessagePolicy.isMandatory";
+    public static final String AUTH_METHOD = "javax.servlet.http.authType";
 
     private final Map<String, Object> map = new HashMap<>();
     private HttpServletRequest request;
@@ -35,10 +36,12 @@ public class MessageInfoImpl implements MessageInfo {
     public MessageInfoImpl() {
     }
 
-    public MessageInfoImpl(Request request, HttpServletResponse response, boolean authMandatory) {
+    public MessageInfoImpl(Request request, HttpServletResponse response, boolean authMandatory,
+            String authMethod) {
         this.request = request;
         this.response = response;
         map.put(IS_MANDATORY, Boolean.toString(authMandatory));
+        map.put(AUTH_METHOD, authMethod);
     }
 
     @Override

commit d564fc963484ec2585ed48fc9b0c952d53fcc105
Author: Mark Thomas <markt@apache.org>
Date:   Sat May 16 09:37:26 2015 +0000

    set the headers rather than add them
    Add header names to the docs and make clear that any existing headers will be replaced.
    Add the filter tot he security howto
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1679716 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/filters/HttpHeaderSecurityFilter.java b/java/org/apache/catalina/filters/HttpHeaderSecurityFilter.java
index 7a8faba..f29fb0e 100644
--- a/java/org/apache/catalina/filters/HttpHeaderSecurityFilter.java
+++ b/java/org/apache/catalina/filters/HttpHeaderSecurityFilter.java
@@ -89,18 +89,18 @@ public class HttpHeaderSecurityFilter extends FilterBase {
 
         // HSTS
         if (hstsEnabled && request.isSecure() && response instanceof HttpServletResponse) {
-            ((HttpServletResponse) response).addHeader(HSTS_HEADER_NAME, hstsHeaderValue);
+            ((HttpServletResponse) response).setHeader(HSTS_HEADER_NAME, hstsHeaderValue);
         }
 
         // anti click-jacking
         if (antiClickJackingEnabled && response instanceof HttpServletResponse) {
-            ((HttpServletResponse) response).addHeader(
+            ((HttpServletResponse) response).setHeader(
                     ANTI_CLICK_JACKING_HEADER_NAME, antiClickJackingHeaderValue);
         }
 
         // Block content type sniffing
         if (blockContentTypeSniffingEnabled && response instanceof HttpServletResponse) {
-            ((HttpServletResponse) response).addHeader(BLOCK_CONTENT_TYPE_SNIFFING_HEADER_NAME,
+            ((HttpServletResponse) response).setHeader(BLOCK_CONTENT_TYPE_SNIFFING_HEADER_NAME,
                     BLOCK_CONTENT_TYPE_SNIFFING_HEADER_VALUE);
         }
         chain.doFilter(request, response);
diff --git a/webapps/docs/config/filter.xml b/webapps/docs/config/filter.xml
index c1928eb..a47c9f3 100644
--- a/webapps/docs/config/filter.xml
+++ b/webapps/docs/config/filter.xml
@@ -724,9 +724,11 @@ FINE: Request "/docs/config/manager.html" with response status "200"
     <attributes>
 
       <attribute name="hstsEnabled" required="false">
-        <p>Will an HTTP Strict Transport Security (HSTS) header be added to the
-        response. See <a href="http://tools.ietf.org/html/rfc6797">RFC 6797</a>
-        for further details of HSTS. If not specified, the default value of
+        <p>Will an HTTP Strict Transport Security (HSTS) header
+        (<code>Strict-Transport-Security</code>) be set on the response for
+        secure requests. Any HSTS header already present will be replaced. See
+        <a href="http://tools.ietf.org/html/rfc6797">RFC 6797</a> for further
+        details of HSTS. If not specified, the default value of
         <code>true</code> will be used.</p>
       </attribute>
 
@@ -743,8 +745,9 @@ FINE: Request "/docs/config/manager.html" with response status "200"
       </attribute>
 
       <attribute name="antiClickJackingEnabled" required="false">
-        <p>Should the anti click-jacking <code>X-Frame-Options</code> be added
-        to the response. If not specified, the default value of
+        <p>Should the anti click-jacking header (<code>X-Frame-Options</code>)
+        be set on the response. Any anti click-jacking header already present
+        will be replaced. If not specified, the default value of
         <code>true</code> will be used.</p>
       </attribute>
 
@@ -762,9 +765,10 @@ FINE: Request "/docs/config/manager.html" with response status "200"
       </attribute>
 
       <attribute name="blockContentTypeSniffingEnabled" required="false">
-        <p>Should the header that blocks content type sniffing be added to every
-        response. If not specified, the default value of <code>true</code> will
-        be used.</p>
+        <p>Should the header that blocks content type sniffing
+        (<code>X-Content-Type-Options</code>) be set on every response. If
+        already present, the header will be replaced. If not specified, the
+        default value of <code>true</code> will be used.</p>
       </attribute>
 
     </attributes>
diff --git a/webapps/docs/security-howto.xml b/webapps/docs/security-howto.xml
index 5a124f8..af700d8 100644
--- a/webapps/docs/security-howto.xml
+++ b/webapps/docs/security-howto.xml
@@ -468,6 +468,13 @@
     can be configured and used to reject requests that had errors during
     request parameter parsing. Without the filter the default behaviour is
     to ignore invalid or excessive parameters.</p>
+
+    <p><a href="config/filter.html">HttpHeaderSecurityFilter</a> can be
+    used to add headers to responses to improve security. If clients access
+    Tomcat directly, then you probably want to enable this filter and all the
+    headers it sets unless your application is already setting them. If Tomcat
+    is accessed via a reverse proxy, then the configuration of this filter needs
+    to be co-ordinated with any headers that the reverse proxy sets.</p>
   </section>
 
   <section name="General">

commit 61fa48f0eb411c39e6873705c5ff9bf2723fb266
Author: Mark Thomas <markt@apache.org>
Date:   Tue Apr 28 21:28:26 2015 +0000

    Use a new object every time for security. Review by schultz.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1676634 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/el/parser/AstValue.java b/java/org/apache/el/parser/AstValue.java
index acb0d92..06e10c3 100644
--- a/java/org/apache/el/parser/AstValue.java
+++ b/java/org/apache/el/parser/AstValue.java
@@ -42,7 +42,6 @@ import org.apache.el.util.ReflectionUtil;
 public final class AstValue extends SimpleNode {
 
     private static final Object[] EMPTY_ARRAY = new Object[0];
-    private static final Object[] ARRAY_OF_SINGLE_NULL = new Object[1];
 
     protected static class Target {
         protected Object base;
@@ -292,7 +291,9 @@ public final class AstValue extends SimpleNode {
 
         if (src == null) {
             // Must be a varargs method with a single parameter.
-            return ARRAY_OF_SINGLE_NULL;
+            // Use a new array every time since the called code could modify the
+            // contents of the array
+            return new Object[1];
         }
 
         Object[] dest = new Object[paramCount];

commit 29e8ce05676a34773a60f7e61d321c85f2e9cdbd
Author: Mark Thomas <markt@apache.org>
Date:   Thu Dec 18 13:01:41 2014 +0000

    Servlet API requires java.security.cert.X509Certificate[] so be explicit about this in the support class.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1646449 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/tomcat/util/net/SSLSupport.java b/java/org/apache/tomcat/util/net/SSLSupport.java
index c9fbd50..593faff 100644
--- a/java/org/apache/tomcat/util/net/SSLSupport.java
+++ b/java/org/apache/tomcat/util/net/SSLSupport.java
@@ -18,6 +18,7 @@
 package org.apache.tomcat.util.net;
 
 import java.io.IOException;
+import java.security.cert.X509Certificate;
 
 /**
  * Defines an interface to interact with SSL sessions.
@@ -80,11 +81,12 @@ public interface SSLSupport {
 
     /**
      * The client certificate chain (if any).
-     * @param force If <code>true</code>, then re-negotiate the
-     *              connection if necessary.
+     *
+     * @param force If <code>true</code>, then re-negotiate the connection and
+     *              request a client certificate if a client certificate has not
+     *              already been requested.
      */
-    public Object[] getPeerCertificateChain(boolean force)
-        throws IOException;
+    public X509Certificate[] getPeerCertificateChain(boolean force) throws IOException;
 
     /**
      * Get the keysize.
diff --git a/java/org/apache/tomcat/util/net/jsse/JSSESupport.java b/java/org/apache/tomcat/util/net/jsse/JSSESupport.java
index 9f032c7..31d49ef 100644
--- a/java/org/apache/tomcat/util/net/jsse/JSSESupport.java
+++ b/java/org/apache/tomcat/util/net/jsse/JSSESupport.java
@@ -126,7 +126,7 @@ class JSSESupport implements SSLSupport, SSLSessionManager {
     }
 
     @Override
-    public Object[] getPeerCertificateChain(boolean force)
+    public java.security.cert.X509Certificate[] getPeerCertificateChain(boolean force)
         throws IOException {
         // Look up the current SSLSession
         if (session == null)

commit 619985fbf7995521acb1477877fee41d9a54a295
Author: Mark Thomas <markt@apache.org>
Date:   Tue Dec 9 10:29:51 2014 +0000

    Fix potential issue with BeanELresolver when running under a security manager.
    Some classes may not be accessible but may have accessible interfaces.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1644017 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/javax/el/BeanELResolver.java b/java/javax/el/BeanELResolver.java
index 3b40e8c..032662a 100644
--- a/java/javax/el/BeanELResolver.java
+++ b/java/javax/el/BeanELResolver.java
@@ -229,15 +229,39 @@ public class BeanELResolver extends ELResolver {
             try {
                 BeanInfo info = Introspector.getBeanInfo(this.type);
                 PropertyDescriptor[] pds = info.getPropertyDescriptors();
-                for (int i = 0; i < pds.length; i++) {
-                    this.properties.put(pds[i].getName(), new BeanProperty(
-                            type, pds[i]));
+                for (PropertyDescriptor pd: pds) {
+                    this.properties.put(pd.getName(), new BeanProperty(type, pd));
+                }
+                if (System.getSecurityManager() != null) {
+                    // When running with SecurityManager, some classes may be
+                    // not accessible, but have accessible interfaces.
+                    populateFromInterfaces(type);
                 }
             } catch (IntrospectionException ie) {
                 throw new ELException(ie);
             }
         }
 
+        private void populateFromInterfaces(Class<?> aClass) throws IntrospectionException {
+            Class<?> interfaces[] = aClass.getInterfaces();
+            if (interfaces.length > 0) {
+                for (Class<?> ifs : interfaces) {
+                    BeanInfo info = Introspector.getBeanInfo(ifs);
+                    PropertyDescriptor[] pds = info.getPropertyDescriptors();
+                    for (PropertyDescriptor pd : pds) {
+                        if (!this.properties.containsKey(pd.getName())) {
+                            this.properties.put(pd.getName(), new BeanProperty(
+                                    this.type, pd));
+                        }
+                    }
+                }
+            }
+            Class<?> superclass = aClass.getSuperclass();
+            if (superclass != null) {
+                populateFromInterfaces(superclass);
+            }
+        }
+
         private BeanProperty get(ELContext ctx, String name) {
             BeanProperty property = this.properties.get(name);
             if (property == null) {

commit 23750df7b408527ba1718f1d175d6abf40024353
Author: Mark Thomas <markt@apache.org>
Date:   Fri Dec 5 13:58:58 2014 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=57281
    Use interfaces rather than implementations to call Filter and Servlet
    methods when running under a security manager.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1643283 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityUtil.java b/java/org/apache/catalina/security/SecurityUtil.java
index b8c8dd0..cc2e0b1 100644
--- a/java/org/apache/catalina/security/SecurityUtil.java
+++ b/java/org/apache/catalina/security/SecurityUtil.java
@@ -67,10 +67,9 @@ public final class SecurityUtil{
     private static final String DESTROY_METHOD = "destroy";
 
     /**
-     * Cache every object for which we are creating method on it.
+     * Cache every class for which we are creating methods.
      */
-    private static final Map<Object,Method[]> objectCache =
-            new ConcurrentHashMap<>();
+    private static final Map<Class<?>,Method[]> classCache = new ConcurrentHashMap<>();
 
     private static final org.apache.juli.logging.Log log=
         org.apache.juli.logging.LogFactory.getLog( SecurityUtil.class );
@@ -133,7 +132,7 @@ public final class SecurityUtil{
      * @param methodName the method to apply the security restriction
      * @param targetObject the <code>Servlet</code> on which the method will
      * be called.
-     * @param targetType <code>Class</code> array used to instantiate a
+     * @param targetParameterTypes <code>Class</code> array used to instantiate a
      * <code>Method</code> object.
      * @param targetArguments <code>Object</code> array contains the
      * runtime parameters instance.
@@ -142,25 +141,25 @@ public final class SecurityUtil{
      */
     public static void doAsPrivilege(final String methodName,
                                      final Servlet targetObject,
-                                     final Class<?>[] targetType,
+                                     final Class<?>[] targetParameterTypes,
                                      final Object[] targetArguments,
                                      Principal principal)
         throws java.lang.Exception{
 
         Method method = null;
-        Method[] methodsCache = objectCache.get(targetObject);
+        Method[] methodsCache = classCache.get(Servlet.class);
         if(methodsCache == null) {
             method = createMethodAndCacheIt(methodsCache,
+                                            Servlet.class,
                                             methodName,
-                                            targetObject,
-                                            targetType);
+                                            targetParameterTypes);
         } else {
             method = findMethod(methodsCache, methodName);
             if (method == null) {
                 method = createMethodAndCacheIt(methodsCache,
+                                                Servlet.class,
                                                 methodName,
-                                                targetObject,
-                                                targetType);
+                                                targetParameterTypes);
             }
         }
 
@@ -213,38 +212,38 @@ public final class SecurityUtil{
      * @param methodName the method to apply the security restriction
      * @param targetObject the <code>Filter</code> on which the method will
      * be called.
-     * @param targetType <code>Class</code> array used to instantiate a
+     * @param targetParameterTypes <code>Class</code> array used to instantiate a
      * <code>Method</code> object.
-     * @param targetArguments <code>Object</code> array contains the
+     * @param targetParameterValues <code>Object</code> array contains the
      * runtime parameters instance.
      * @param principal the <code>Principal</code> to which the security
      * privilege apply
      */
     public static void doAsPrivilege(final String methodName,
                                      final Filter targetObject,
-                                     final Class<?>[] targetType,
-                                     final Object[] targetArguments,
+                                     final Class<?>[] targetParameterTypes,
+                                     final Object[] targetParameterValues,
                                      Principal principal)
         throws java.lang.Exception{
 
         Method method = null;
-        Method[] methodsCache = objectCache.get(targetObject);
+        Method[] methodsCache = classCache.get(Filter.class);
         if(methodsCache == null) {
             method = createMethodAndCacheIt(methodsCache,
+                                            Filter.class,
                                             methodName,
-                                            targetObject,
-                                            targetType);
+                                            targetParameterTypes);
         } else {
             method = findMethod(methodsCache, methodName);
             if (method == null) {
                 method = createMethodAndCacheIt(methodsCache,
+                                                Filter.class,
                                                 methodName,
-                                                targetObject,
-                                                targetType);
+                                                targetParameterTypes);
             }
         }
 
-        execute(method, targetObject, targetArguments, principal);
+        execute(method, targetObject, targetParameterValues, principal);
     }
 
 
@@ -360,25 +359,23 @@ public final class SecurityUtil{
     /**
      * Create the method and cache it for further re-use.
      * @param methodsCache the cache used to store method instance
+     * @param targetType the class on which the method will be called.
      * @param methodName the method to apply the security restriction
-     * @param targetObject the <code>Servlet</code> on which the method will
-     * be called.
-     * @param targetType <code>Class</code> array used to instantiate a
+     * @param parameterTypes <code>Class</code> array used to instantiate a
      * <code>Method</code> object.
      * @return the method instance.
      */
     private static Method createMethodAndCacheIt(Method[] methodsCache,
+                                                 Class<?> targetType,
                                                  String methodName,
-                                                 Object targetObject,
-                                                 Class<?>[] targetType)
-            throws Exception{
+                                                 Class<?>[] parameterTypes)
+            throws Exception {
 
-        if ( methodsCache == null){
+        if (methodsCache == null) {
             methodsCache = new Method[4];
         }
 
-        Method method =
-            targetObject.getClass().getMethod(methodName, targetType);
+        Method method = targetType.getMethod(methodName, parameterTypes);
 
         if (methodName.equals(INIT_METHOD)){
             methodsCache[INIT] = method;
@@ -394,7 +391,7 @@ public final class SecurityUtil{
             methodsCache[DOFILTEREVENT] = method;
         }
 
-        objectCache.put(targetObject, methodsCache );
+        classCache.put(targetType, methodsCache);
 
         return method;
     }
@@ -406,7 +403,7 @@ public final class SecurityUtil{
      * @param cachedObject The object to remove
      */
     public static void remove(Object cachedObject){
-        objectCache.remove(cachedObject);
+        classCache.remove(cachedObject);
     }
 
 

commit b34c8c7eec93512d061366e0d7b3c11c4db723ad
Author: Konstantin Kolinko <kkolinko@apache.org>
Date:   Tue Oct 21 11:35:35 2014 +0000

    Update changelog for BZ 47919 per r1630407
    It logs not just key env vars, but all of them, and logs command line arguments.
    I am emphasizing CATALINA_OPTS, JAVA_OPTS, as that may be a security concern for somebody.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1633346 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/webapps/docs/changelog.xml b/webapps/docs/changelog.xml
index f9ff601..1f88eb6 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -60,8 +60,10 @@
       </add>
       <add>
         <bug>47919</bug>: Extend the information logged when Tomcat starts to
-        optionally include (disabled by default) the values of key environment
-        variables. (markt)
+        optionally log the values of command line arguments (enabled by
+        default) and environment variables (disabled by default). Note that
+        the values added to CATALINA_OPTS and JAVA_OPTS environment variables
+        will be logged, as they are used to build up the command line. (markt)
       </add>
       <add>
         <bug>49939</bug>: Expose the method that clears the static resource

commit e9b3a857e1264dfbee1842ed9903782522c78efe
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Tue Sep 30 20:10:18 2014 +0000

    Update docs as automatically setting the system property javax.security.auth.useSubjectCredsOnly was removed since it broke SPNEGO on IBM JREs.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1628541 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/webapps/docs/windows-auth-howto.xml b/webapps/docs/windows-auth-howto.xml
index 27b873e..e521b58 100644
--- a/webapps/docs/windows-auth-howto.xml
+++ b/webapps/docs/windows-auth-howto.xml
@@ -172,9 +172,6 @@ com.sun.security.jgss.krb5.accept {
   the JVM being used. The name of the login configuration must match the
   value used by the <a href="config/valve.html#SPNEGO_Valve">authentication
   valve</a>.</li>
-  <li>The system property <code>javax.security.auth.useSubjectCredsOnly</code>
-  is automatically set to the required value of false if a web application is
-  configured to use the SPNEGO authentication method.</li>
   </ul>
   <p>The SPNEGO authenticator will work with any <a href="config/realm.html">
   Realm</a> but if used with the JNDI Realm, by default the JNDI Realm will use

commit 02b8e9d3607dadb54c2fffd425a1cb081dfccc59
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Tue Sep 9 08:22:28 2014 +0000

    Move MessageDigest utility classes from o.a.catalina.util to o.a.tomcat.util.security so they are more widely available.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1623685 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/authenticator/DigestAuthenticator.java b/java/org/apache/catalina/authenticator/DigestAuthenticator.java
index 6bef628..d3340eb 100644
--- a/java/org/apache/catalina/authenticator/DigestAuthenticator.java
+++ b/java/org/apache/catalina/authenticator/DigestAuthenticator.java
@@ -29,11 +29,11 @@ import javax.servlet.http.HttpServletResponse;
 import org.apache.catalina.LifecycleException;
 import org.apache.catalina.Realm;
 import org.apache.catalina.connector.Request;
-import org.apache.catalina.util.ConcurrentMessageDigest;
-import org.apache.catalina.util.MD5Encoder;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.http.parser.Authorization;
+import org.apache.tomcat.util.security.ConcurrentMessageDigest;
+import org.apache.tomcat.util.security.MD5Encoder;
 
 
 /**
diff --git a/java/org/apache/catalina/realm/RealmBase.java b/java/org/apache/catalina/realm/RealmBase.java
index 501dfe8..9bded39 100644
--- a/java/org/apache/catalina/realm/RealmBase.java
+++ b/java/org/apache/catalina/realm/RealmBase.java
@@ -46,7 +46,6 @@ import org.apache.catalina.Wrapper;
 import org.apache.catalina.connector.Request;
 import org.apache.catalina.connector.Response;
 import org.apache.catalina.util.LifecycleMBeanBase;
-import org.apache.catalina.util.MD5Encoder;
 import org.apache.catalina.util.SessionConfig;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
@@ -56,6 +55,7 @@ import org.apache.tomcat.util.codec.binary.Base64;
 import org.apache.tomcat.util.descriptor.web.SecurityCollection;
 import org.apache.tomcat.util.descriptor.web.SecurityConstraint;
 import org.apache.tomcat.util.res.StringManager;
+import org.apache.tomcat.util.security.MD5Encoder;
 import org.ietf.jgss.GSSContext;
 import org.ietf.jgss.GSSCredential;
 import org.ietf.jgss.GSSException;
diff --git a/java/org/apache/catalina/servlets/WebdavServlet.java b/java/org/apache/catalina/servlets/WebdavServlet.java
index dc24ed4..a92c06e 100644
--- a/java/org/apache/catalina/servlets/WebdavServlet.java
+++ b/java/org/apache/catalina/servlets/WebdavServlet.java
@@ -44,11 +44,11 @@ import javax.xml.parsers.ParserConfigurationException;
 import org.apache.catalina.WebResource;
 import org.apache.catalina.util.ConcurrentDateFormat;
 import org.apache.catalina.util.DOMWriter;
-import org.apache.catalina.util.MD5Encoder;
 import org.apache.catalina.util.XMLWriter;
 import org.apache.tomcat.util.buf.UDecoder;
 import org.apache.tomcat.util.http.FastHttpDateFormat;
 import org.apache.tomcat.util.http.RequestUtil;
+import org.apache.tomcat.util.security.MD5Encoder;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.Node;
diff --git a/java/org/apache/catalina/util/ConcurrentMessageDigest.java b/java/org/apache/catalina/util/ConcurrentMessageDigest.java
deleted file mode 100644
index b41fec6..0000000
--- a/java/org/apache/catalina/util/ConcurrentMessageDigest.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.util;
-
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Queue;
-import java.util.concurrent.ConcurrentLinkedQueue;
-
-/**
- * A thread safe wrapper around {@link MessageDigest} that does not make use
- * of ThreadLocal and - broadly - only creates enough MessageDigest objects
- * to satisfy the concurrency requirements.
- */
-public class ConcurrentMessageDigest {
-
-    private static final String MD5 = "MD5";
-
-    private static final Map<String,Queue<MessageDigest>> queues =
-            new HashMap<>();
-
-
-    private ConcurrentMessageDigest() {
-        // Hide default constructor for this utility class
-    }
-
-    static {
-        try {
-            // Init commonly used algorithms
-            init(MD5);
-        } catch (NoSuchAlgorithmException e) {
-            throw new IllegalArgumentException(e);
-        }
-    }
-
-    public static byte[] digestMD5(byte[] input) {
-        return digest(MD5, input);
-    }
-
-    public static byte[] digest(String algorithm, byte[] input) {
-
-        Queue<MessageDigest> queue = queues.get(algorithm);
-        if (queue == null) {
-            throw new IllegalStateException("Must call init() first");
-        }
-
-        MessageDigest md = queue.poll();
-        if (md == null) {
-            try {
-                md = MessageDigest.getInstance(algorithm);
-            } catch (NoSuchAlgorithmException e) {
-                // Ignore. Impossible if init() has been successfully called
-                // first.
-                throw new IllegalStateException("Must call init() first");
-            }
-        }
-
-        byte[] result = md.digest(input);
-
-        queue.add(md);
-
-        return result;
-    }
-
-
-    /**
-     * Ensures that {@link #digest(String, byte[])} will support the specified
-     * algorithm. This method <b>must</b> be called and return successfully
-     * before using {@link #digest(String, byte[])}.
-     *
-     * @param algorithm The message digest algorithm to be supported
-     *
-     * @throws NoSuchAlgorithmException If the algorithm is not supported by the
-     *                                  JVM
-     */
-    public static void init(String algorithm) throws NoSuchAlgorithmException {
-        synchronized (queues) {
-            if (!queues.containsKey(algorithm)) {
-                MessageDigest md = MessageDigest.getInstance(algorithm);
-                Queue<MessageDigest> queue = new ConcurrentLinkedQueue<>();
-                queue.add(md);
-                queues.put(algorithm, queue);
-            }
-        }
-    }
-}
diff --git a/java/org/apache/catalina/util/MD5Encoder.java b/java/org/apache/catalina/util/MD5Encoder.java
deleted file mode 100644
index 627868b..0000000
--- a/java/org/apache/catalina/util/MD5Encoder.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.catalina.util;
-
-/**
- * Encode an MD5 digest into a String.
- * <p>
- * The 128 bit MD5 hash is converted into a 32 character long String.
- * Each character of the String is the hexadecimal representation of 4 bits
- * of the digest.
- *
- * @author Remy Maucherat
- */
-public final class MD5Encoder {
-
-
-    private MD5Encoder() {
-        // Hide default constructor for utility class
-    }
-
-
-    private static final char[] hexadecimal = {'0', '1', '2', '3', '4', '5',
-        '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
-
-
-    /**
-     * Encodes the 128 bit (16 bytes) MD5 into a 32 character String.
-     *
-     * @param binaryData Array containing the digest
-     *
-     * @return Encoded MD5, or null if encoding failed
-     */
-    public static String encode(byte[] binaryData) {
-
-        if (binaryData.length != 16)
-            return null;
-
-        char[] buffer = new char[32];
-
-        for (int i=0; i<16; i++) {
-            int low = binaryData[i] & 0x0f;
-            int high = (binaryData[i] & 0xf0) >> 4;
-            buffer[i*2] = hexadecimal[high];
-            buffer[i*2 + 1] = hexadecimal[low];
-        }
-
-        return new String(buffer);
-    }
-}
-
diff --git a/java/org/apache/tomcat/util/security/ConcurrentMessageDigest.java b/java/org/apache/tomcat/util/security/ConcurrentMessageDigest.java
new file mode 100644
index 0000000..5791602
--- /dev/null
+++ b/java/org/apache/tomcat/util/security/ConcurrentMessageDigest.java
@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util.security;
+
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+/**
+ * A thread safe wrapper around {@link MessageDigest} that does not make use
+ * of ThreadLocal and - broadly - only creates enough MessageDigest objects
+ * to satisfy the concurrency requirements.
+ */
+public class ConcurrentMessageDigest {
+
+    private static final String MD5 = "MD5";
+
+    private static final Map<String,Queue<MessageDigest>> queues =
+            new HashMap<>();
+
+
+    private ConcurrentMessageDigest() {
+        // Hide default constructor for this utility class
+    }
+
+    static {
+        try {
+            // Init commonly used algorithms
+            init(MD5);
+        } catch (NoSuchAlgorithmException e) {
+            throw new IllegalArgumentException(e);
+        }
+    }
+
+    public static byte[] digestMD5(byte[] input) {
+        return digest(MD5, input);
+    }
+
+    public static byte[] digest(String algorithm, byte[] input) {
+
+        Queue<MessageDigest> queue = queues.get(algorithm);
+        if (queue == null) {
+            throw new IllegalStateException("Must call init() first");
+        }
+
+        MessageDigest md = queue.poll();
+        if (md == null) {
+            try {
+                md = MessageDigest.getInstance(algorithm);
+            } catch (NoSuchAlgorithmException e) {
+                // Ignore. Impossible if init() has been successfully called
+                // first.
+                throw new IllegalStateException("Must call init() first");
+            }
+        }
+
+        byte[] result = md.digest(input);
+
+        queue.add(md);
+
+        return result;
+    }
+
+
+    /**
+     * Ensures that {@link #digest(String, byte[])} will support the specified
+     * algorithm. This method <b>must</b> be called and return successfully
+     * before using {@link #digest(String, byte[])}.
+     *
+     * @param algorithm The message digest algorithm to be supported
+     *
+     * @throws NoSuchAlgorithmException If the algorithm is not supported by the
+     *                                  JVM
+     */
+    public static void init(String algorithm) throws NoSuchAlgorithmException {
+        synchronized (queues) {
+            if (!queues.containsKey(algorithm)) {
+                MessageDigest md = MessageDigest.getInstance(algorithm);
+                Queue<MessageDigest> queue = new ConcurrentLinkedQueue<>();
+                queue.add(md);
+                queues.put(algorithm, queue);
+            }
+        }
+    }
+}
diff --git a/java/org/apache/tomcat/util/security/MD5Encoder.java b/java/org/apache/tomcat/util/security/MD5Encoder.java
new file mode 100644
index 0000000..8f5df40
--- /dev/null
+++ b/java/org/apache/tomcat/util/security/MD5Encoder.java
@@ -0,0 +1,64 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util.security;
+
+/**
+ * Encode an MD5 digest into a String.
+ * <p>
+ * The 128 bit MD5 hash is converted into a 32 character long String.
+ * Each character of the String is the hexadecimal representation of 4 bits
+ * of the digest.
+ *
+ * @author Remy Maucherat
+ */
+public final class MD5Encoder {
+
+
+    private MD5Encoder() {
+        // Hide default constructor for utility class
+    }
+
+
+    private static final char[] hexadecimal = {'0', '1', '2', '3', '4', '5',
+        '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
+
+
+    /**
+     * Encodes the 128 bit (16 bytes) MD5 into a 32 character String.
+     *
+     * @param binaryData Array containing the digest
+     *
+     * @return Encoded MD5, or null if encoding failed
+     */
+    public static String encode(byte[] binaryData) {
+
+        if (binaryData.length != 16)
+            return null;
+
+        char[] buffer = new char[32];
+
+        for (int i=0; i<16; i++) {
+            int low = binaryData[i] & 0x0f;
+            int high = (binaryData[i] & 0xf0) >> 4;
+            buffer[i*2] = hexadecimal[high];
+            buffer[i*2 + 1] = hexadecimal[low];
+        }
+
+        return new String(buffer);
+    }
+}
+
diff --git a/test/org/apache/catalina/authenticator/TestDigestAuthenticator.java b/test/org/apache/catalina/authenticator/TestDigestAuthenticator.java
index f01b0b2..98dd1db 100644
--- a/test/org/apache/catalina/authenticator/TestDigestAuthenticator.java
+++ b/test/org/apache/catalina/authenticator/TestDigestAuthenticator.java
@@ -37,12 +37,12 @@ import org.apache.catalina.startup.TesterMapRealm;
 import org.apache.catalina.startup.TesterServlet;
 import org.apache.catalina.startup.Tomcat;
 import org.apache.catalina.startup.TomcatBaseTest;
-import org.apache.catalina.util.ConcurrentMessageDigest;
-import org.apache.catalina.util.MD5Encoder;
 import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.descriptor.web.LoginConfig;
 import org.apache.tomcat.util.descriptor.web.SecurityCollection;
 import org.apache.tomcat.util.descriptor.web.SecurityConstraint;
+import org.apache.tomcat.util.security.ConcurrentMessageDigest;
+import org.apache.tomcat.util.security.MD5Encoder;
 
 public class TestDigestAuthenticator extends TomcatBaseTest {
 
diff --git a/test/org/apache/catalina/authenticator/TestSSOnonLoginAndDigestAuthenticator.java b/test/org/apache/catalina/authenticator/TestSSOnonLoginAndDigestAuthenticator.java
index 833bee6..533f25e 100644
--- a/test/org/apache/catalina/authenticator/TestSSOnonLoginAndDigestAuthenticator.java
+++ b/test/org/apache/catalina/authenticator/TestSSOnonLoginAndDigestAuthenticator.java
@@ -30,12 +30,12 @@ import org.apache.catalina.Context;
 import org.apache.catalina.startup.TesterServlet;
 import org.apache.catalina.startup.Tomcat;
 import org.apache.catalina.startup.TomcatBaseTest;
-import org.apache.catalina.util.ConcurrentMessageDigest;
-import org.apache.catalina.util.MD5Encoder;
 import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.descriptor.web.LoginConfig;
 import org.apache.tomcat.util.descriptor.web.SecurityCollection;
 import org.apache.tomcat.util.descriptor.web.SecurityConstraint;
+import org.apache.tomcat.util.security.ConcurrentMessageDigest;
+import org.apache.tomcat.util.security.MD5Encoder;
 
 /**
  * Test DigestAuthenticator and NonLoginAuthenticator when a
diff --git a/test/org/apache/catalina/authenticator/TesterDigestAuthenticatorPerformance.java b/test/org/apache/catalina/authenticator/TesterDigestAuthenticatorPerformance.java
index a432d2f..2873e5d 100644
--- a/test/org/apache/catalina/authenticator/TesterDigestAuthenticatorPerformance.java
+++ b/test/org/apache/catalina/authenticator/TesterDigestAuthenticatorPerformance.java
@@ -31,9 +31,9 @@ import org.apache.catalina.connector.Request;
 import org.apache.catalina.core.StandardContext;
 import org.apache.catalina.filters.TesterHttpServletResponse;
 import org.apache.catalina.startup.TesterMapRealm;
-import org.apache.catalina.util.ConcurrentMessageDigest;
-import org.apache.catalina.util.MD5Encoder;
 import org.apache.tomcat.util.descriptor.web.LoginConfig;
+import org.apache.tomcat.util.security.ConcurrentMessageDigest;
+import org.apache.tomcat.util.security.MD5Encoder;
 
 public class TesterDigestAuthenticatorPerformance {
 

commit dc6c27f99e543ee7a2ab4f9b4f1763ba8df1406f
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Fri Aug 15 12:54:37 2014 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=56857
    Fix thread safety issue when calling ServletContext methods while running under a security manager.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1618169 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/core/ApplicationContextFacade.java b/java/org/apache/catalina/core/ApplicationContextFacade.java
index d56a577..cc469ad 100644
--- a/java/org/apache/catalina/core/ApplicationContextFacade.java
+++ b/java/org/apache/catalina/core/ApplicationContextFacade.java
@@ -32,6 +32,7 @@ import java.util.EventListener;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 
 import javax.servlet.Filter;
 import javax.servlet.FilterRegistration;
@@ -61,13 +62,13 @@ public class ApplicationContextFacade implements ServletContext {
     /**
      * Cache Class object used for reflection.
      */
-    private final HashMap<String,Class<?>[]> classCache;
+    private final Map<String,Class<?>[]> classCache;
 
 
     /**
      * Cache method object.
      */
-    private final HashMap<String,Method> objectCache;
+    private final Map<String,Method> objectCache;
 
 
     // ----------------------------------------------------------- Constructors
@@ -84,7 +85,7 @@ public class ApplicationContextFacade implements ServletContext {
         this.context = context;
 
         classCache = new HashMap<>();
-        objectCache = new HashMap<>();
+        objectCache = new ConcurrentHashMap<>();
         initClassCache();
     }
 
diff --git a/webapps/docs/changelog.xml b/webapps/docs/changelog.xml
index 99699ba..ef6e8b8 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -145,6 +145,10 @@
         <bug>56848</bug>: Improve handling of <code>accept-language</code>
         headers. (markt)
       </fix>
+      <fix>
+        <bug>56857</bug>: Fix thread safety issue when calling ServletContext
+        methods while running under a security manager. (markt)
+      </fix>
     </changelog>
   </subsection>
   <subsection name="Coyote">

commit c88e75305e198f500ffd626a5b1275dc3ad46553
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Mon Jun 16 09:52:49 2014 +0000

    Attempt to obfuscate session cookie values associated with other web applications when viewing HTTP request headers with the Request Header example from the examples web application. This reduces the opportunity to use this example for malicious purposes should the advice to remove the examples web application from security sensitive systems be ignored.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1602831 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/test/util/TestCookieFilter.java b/test/util/TestCookieFilter.java
new file mode 100644
index 0000000..6384d1d
--- /dev/null
+++ b/test/util/TestCookieFilter.java
@@ -0,0 +1,93 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package util;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import org.apache.catalina.authenticator.Constants;
+
+public class TestCookieFilter {
+
+    @Test
+    public void test01() {
+        // Single cookie
+        Assert.assertEquals("a=b", CookieFilter.filter("a=b", null));
+    }
+
+    @Test
+    public void test02() {
+        // Two cookies
+        Assert.assertEquals("a=b;c=d", CookieFilter.filter("a=b;c=d", null));
+    }
+
+    @Test
+    public void test03() {
+        // Cookies with leading and trailing whitespace
+        Assert.assertEquals(" a=b  ;   c=d    ",
+                CookieFilter.filter(" a=b  ;   c=d    ", null));
+    }
+
+    @Test
+    public void test04() {
+        // Empty name (not necessarily valid but checking edge cases in filter)
+        Assert.assertEquals("=b", CookieFilter.filter("=b", null));
+    }
+
+    @Test
+    public void test05() {
+        // Empty value (not necessarily valid but checking edge cases in filter)
+        Assert.assertEquals("a=", CookieFilter.filter("a=", null));
+    }
+
+    @Test
+    public void test06() {
+        // Simple case
+        Assert.assertEquals("JSESSIONID=[obfuscated]",
+                CookieFilter.filter("JSESSIONID=0123456789", null));
+    }
+
+    @Test
+    public void test07() {
+        // Simple SSO case
+        Assert.assertEquals(Constants.SINGLE_SIGN_ON_COOKIE + "=[obfuscated]",
+                CookieFilter.filter(Constants.SINGLE_SIGN_ON_COOKIE + "=0123456789", null));
+    }
+
+
+    @Test
+    public void test08() {
+        // Simple case
+        String id = "0123456789";
+        String cookie = "JSESSIONID=" + id;
+        Assert.assertEquals(cookie, CookieFilter.filter(cookie, id));
+    }
+
+    @Test
+    public void test09() {
+        // Simple SSO case
+        String id = "0123456789";
+        String cookie = Constants.SINGLE_SIGN_ON_COOKIE + "=" + id;
+        Assert.assertEquals(cookie, CookieFilter.filter(cookie, id));
+    }
+
+    @Test
+    public void test10() {
+        // Single cookie
+        Assert.assertEquals("a=\"xx;x\"", CookieFilter.filter("a=\"xx;x\"", null));
+    }
+}
diff --git a/webapps/docs/changelog.xml b/webapps/docs/changelog.xml
index 4f85fe9..1e676ed 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -265,6 +265,14 @@
         remove the examples web application from security sensitive systems be
         ignored. (markt/kkolinko)
       </fix>
+      <fix>
+        Attempt to obfuscate session cookie values associated with other web
+        applications when viewing HTTP request headers with the Request Header
+        example from the examples web application. This reduces the opportunity
+        to use this example for malicious purposes should the advice to remove
+        the examples web application from security sensitive systems be ignored.
+        (markt)
+      </fix>
     </changelog>
   </subsection>
   <subsection name="Other">
diff --git a/webapps/examples/WEB-INF/classes/RequestHeaderExample.java b/webapps/examples/WEB-INF/classes/RequestHeaderExample.java
index 81e5492..79e7bac 100644
--- a/webapps/examples/WEB-INF/classes/RequestHeaderExample.java
+++ b/webapps/examples/WEB-INF/classes/RequestHeaderExample.java
@@ -18,13 +18,16 @@
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.Enumeration;
+import java.util.Locale;
 import java.util.ResourceBundle;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
 
+import util.CookieFilter;
 import util.HTMLFilter;
 
 /**
@@ -79,7 +82,16 @@ public class RequestHeaderExample extends HttpServlet {
             out.println("<tr><td bgcolor=\"#CCCCCC\">");
             out.println(HTMLFilter.filter(headerName));
             out.println("</td><td>");
-            out.println(HTMLFilter.filter(headerValue));
+            if (headerName.toLowerCase(Locale.ENGLISH).contains("cookie")) {
+                HttpSession session = request.getSession(false);
+                String sessionId = null;
+                if (session != null) {
+                    sessionId = session.getId();
+                }
+                out.println(HTMLFilter.filter(CookieFilter.filter(headerValue, sessionId)));
+            } else {
+                out.println(HTMLFilter.filter(headerValue));
+            }
             out.println("</td></tr>");
         }
         out.println("</table>");
diff --git a/webapps/examples/WEB-INF/classes/util/CookieFilter.java b/webapps/examples/WEB-INF/classes/util/CookieFilter.java
new file mode 100644
index 0000000..1e156db
--- /dev/null
+++ b/webapps/examples/WEB-INF/classes/util/CookieFilter.java
@@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package util;
+
+import java.util.Locale;
+import java.util.StringTokenizer;
+
+/**
+ * Processes a cookie header and attempts to obfuscate any cookie values that
+ * represent session IDs from other web applications. Since session cookie names
+ * are configurable, as are session ID lengths, this filter is not expected to
+ * be 100% effective.
+ *
+ * It is required that the examples web application is removed in security
+ * conscious environments as documented in the Security How-To. This filter is
+ * intended to reduce the impact of failing to follow that advice. A failure by
+ * this filter to obfuscate a session ID or similar value is not a security
+ * vulnerability. In such instances the vulnerability is the failure to remove
+ * the examples web application.
+ */
+public class CookieFilter {
+
+    private static final String OBFUSCATED = "[obfuscated]";
+
+    private CookieFilter() {
+        // Hide default constructor
+    }
+
+    public static String filter(String input, String sessionId) {
+
+        StringBuilder sb = new StringBuilder(input.length());
+
+        // Cookie name value pairs are ';' separated.
+        // Session IDs don't use ; in the value so don't worry about quoted
+        // values that contain ;
+        StringTokenizer st = new StringTokenizer(input, ";");
+
+        boolean first = true;
+        while (st.hasMoreTokens()) {
+            if (first) {
+                first = false;
+            } else {
+                sb.append(';');
+            }
+            sb.append(filterNameValuePair(st.nextToken(), sessionId));
+        }
+
+
+        return sb.toString();
+    }
+
+    private static String filterNameValuePair(String input, String sessionId) {
+        int i = input.indexOf('=');
+        if (i == -1) {
+            return input;
+        }
+        String name = input.substring(0, i);
+        String value = input.substring(i + 1, input.length());
+
+        if (name.toLowerCase(Locale.ENGLISH).contains("jsessionid") &&
+                (sessionId == null || !value.contains(sessionId))) {
+            value = OBFUSCATED;
+        }
+
+        return name + "=" + value;
+    }
+}

commit b069009815608ea4867bdf12428384a2f71d0bf9
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Fri Jun 13 21:04:05 2014 +0000

    Set the path for cookies created by the examples web app
    This reduces the opportunity for using such cookies for malicious purposes should the advice to remove the examples web application from security sensitive systems be ignored.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1602521 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/webapps/docs/changelog.xml b/webapps/docs/changelog.xml
index 68b3caf..c0d4160 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -256,6 +256,17 @@
       </fix>
     </changelog>
   </subsection>
+  <subsection name="Web applications">
+    <changelog>
+      <fix>
+        Set the path for cookies created by the examples web application so they
+        only returned to the examples application. This reduces the opportunity
+        for using such cookies for malicious purposes should the advice to
+        remove the examples web application from security sensitive systems be
+        ignored. (markt)
+      </fix>
+    </changelog>
+  </subsection>
   <subsection name="Other">
     <changelog>
       <update>
diff --git a/webapps/examples/WEB-INF/classes/CookieExample.java b/webapps/examples/WEB-INF/classes/CookieExample.java
index 7d053de..2790909 100644
--- a/webapps/examples/WEB-INF/classes/CookieExample.java
+++ b/webapps/examples/WEB-INF/classes/CookieExample.java
@@ -50,6 +50,7 @@ public class CookieExample extends HttpServlet {
         Cookie aCookie = null;
         if (cookieName != null && cookieValue != null) {
             aCookie = new Cookie(cookieName, cookieValue);
+            aCookie.setPath(request.getServletContext().getContextPath());
             response.addCookie(aCookie);
         }
 

commit 32126ac5db78cd582ff1c107f6e5f2fae309f236
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Tue May 20 11:26:02 2014 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=56545
    Pre-load two more classes to avoid exceptions when running under a security manager
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1596201 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index e62177e..2d689ab 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -149,6 +149,7 @@ public final class SecurityClassLoad {
             throws Exception {
         final String basePackage = "org.apache.catalina.util.";
         loader.loadClass(basePackage + "ParameterMap");
+        loader.loadClass(basePackage + "RequestUtil");
     }
 
 
diff --git a/webapps/docs/changelog.xml b/webapps/docs/changelog.xml
index 65ea898..bd8d199 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -67,6 +67,11 @@
         optionally interrupt stuck threads to attempt to unblock them.
         (slaurent)
       </add>
+      <fix>
+        <bug>56545</bug>: Pre-load two additional classes, the loading of which
+        may otherwise be triggered by a web application which in turn would
+        trigger an exception when running under a security manager. (markt)
+      </fix>
       <update>
         <bug>56546</bug>: Reduce logging level for stack traces of stuck web
         application threads printed by WebappClassLoader.clearReferencesThreads()

commit a24d70d3421306c4a06b1d90645d06f3fc686863
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Tue May 20 08:49:35 2014 +0000

    Partial fix for https://issues.apache.org/bugzilla/show_bug.cgi?id=56545
    Pre-load an additional class if running under a security manager
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1596141 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index 95e985d..e62177e 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -275,6 +275,7 @@ public final class SecurityClassLoad {
         clazz.newInstance();
         loader.loadClass(basePackage + "util.http.HttpMessages");
         loader.loadClass(basePackage + "util.http.parser.HttpParser");
+        loader.loadClass(basePackage + "util.http.parser.HttpParser$SkipConstantResult");
         loader.loadClass(basePackage + "util.http.parser.MediaType");
         loader.loadClass(basePackage + "util.http.parser.MediaTypeCache");
         // net

commit 0f18751f30b34556f065c4f7ce61e98108a9ef46
Author: Violeta Georgieva Georgieva <violetagg@apache.org>
Date:   Thu May 8 07:55:35 2014 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=56383
    Document ErrorReportValve's new property 'showReport' on the "security HowTO" page.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1593200 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/webapps/docs/security-howto.xml b/webapps/docs/security-howto.xml
index 67c2717..d1979a6 100644
--- a/webapps/docs/security-howto.xml
+++ b/webapps/docs/security-howto.xml
@@ -362,7 +362,9 @@
 
       <p>The default ErrorReportValve can display stack traces and/or JSP
       source code to clients when an error occurs. To avoid this, custom error
-      handling can be configured within each web application.</p>
+      handling can be configured within each web application. Alternatively, you
+      can explicitly configure an <a href="config/valve.html">ErrorReportValve</a>
+      and set its <strong>showReport</strong> attribute to <code>false</code>.</p>
     </subsection>
 
     <subsection name="Realms">

commit 5d126eec714a30fc335c793d0b820810abc2e82a
Author: Konstantin Kolinko <kkolinko@apache.org>
Date:   Sun Apr 27 18:43:58 2014 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=56383
    Document the new feature on the "security HowTO" page.
    Move error valve documentation lower in the valves list
    (access log valves and access control valves should be the first ones there).
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1590451 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/webapps/docs/changelog.xml b/webapps/docs/changelog.xml
index 44d6498..0c1f1c7 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -110,7 +110,7 @@
       <add>
         <bug>56383</bug>: Properties for disabling server information and error
         report are added to the <code>org.apache.catalina.valves.ErrorReportValve</code>.
-        Based on the patch provided by Nick Bunn. (violetagg)
+        Based on the patch provided by Nick Bunn. (violetagg/kkolinko)
       </add>
       <fix>
         <bug>56390</bug>: Fix JAR locking issue with JARs containing TLDs and
diff --git a/webapps/docs/config/valve.xml b/webapps/docs/config/valve.xml
index 9774c2b..48f46e4 100644
--- a/webapps/docs/config/valve.xml
+++ b/webapps/docs/config/valve.xml
@@ -339,54 +339,6 @@
 </section>
 
 
-<section name="Error Report Valve">
-
-  <subsection name="Introduction">
-
-    <p>The <strong>Error Report Valve</strong> is a simple error handler
-    for HTTP status codes that will generate and return HTML error pages.</p>
-
-    <p><strong>NOTE:</strong> Disabling both showServerInfo and showReport will
-    only return the HTTP status code and remove all CSS.</p>
-
-  </subsection>
-
-  <subsection name="Attributes">
-
-    <p>The <strong>Error Report Valve</strong> supports the following
-    configuration attributes:</p>
-
-    <attributes>
-
-      <attribute name="className" required="true">
-        <p>Java class name of the implementation to use.  This MUST be set to
-        <strong>org.apache.catalina.valves.ErrorReportValve</strong> to use the
-        default error report valve.</p>
-      </attribute>
-
-      <attribute name="showReport" required="false">
-        <p>Flag to determine if the error report is presented when an error occurs.
-           If set to <code>false</code>, then the error report is not in
-           the HTML response.
-           Default value: <code>true</code>
-        </p>
-      </attribute>
-
-      <attribute name="showServerInfo" required="false">
-        <p>Flag to determine if server information is presented when an error occurs.
-           If set to <code>false</code>, then the server version is not returned in
-           the HTML response.
-           Default value: <code>true</code>
-        </p>
-      </attribute>
-
-    </attributes>
-
-  </subsection>
-
-</section>
-
-
 <section name="Extended Access Log Valve">
 
   <subsection name="Introduction">
@@ -640,6 +592,54 @@
 </section>
 
 
+<section name="Error Report Valve">
+
+  <subsection name="Introduction">
+
+    <p>The <strong>Error Report Valve</strong> is a simple error handler
+    for HTTP status codes that will generate and return HTML error pages.</p>
+
+    <p><strong>NOTE:</strong> Disabling both showServerInfo and showReport will
+    only return the HTTP status code and remove all CSS.</p>
+
+  </subsection>
+
+  <subsection name="Attributes">
+
+    <p>The <strong>Error Report Valve</strong> supports the following
+    configuration attributes:</p>
+
+    <attributes>
+
+      <attribute name="className" required="true">
+        <p>Java class name of the implementation to use.  This MUST be set to
+        <strong>org.apache.catalina.valves.ErrorReportValve</strong> to use the
+        default error report valve.</p>
+      </attribute>
+
+      <attribute name="showReport" required="false">
+        <p>Flag to determine if the error report is presented when an error
+           occurs. If set to <code>false</code>, then the error report is not in
+           the HTML response.
+           Default value: <code>true</code>
+        </p>
+      </attribute>
+
+      <attribute name="showServerInfo" required="false">
+        <p>Flag to determine if server information is presented when an error
+           occurs. If set to <code>false</code>, then the server version is not
+           returned in the HTML response.
+           Default value: <code>true</code>
+        </p>
+      </attribute>
+
+    </attributes>
+
+  </subsection>
+
+</section>
+
+
 <section name="Single Sign On Valve">
 
   <subsection name="Introduction">
diff --git a/webapps/docs/security-howto.xml b/webapps/docs/security-howto.xml
index 463bca5..84ddc7a 100644
--- a/webapps/docs/security-howto.xml
+++ b/webapps/docs/security-howto.xml
@@ -348,8 +348,10 @@
 
       <p>The default ErrorReportValve includes the Tomcat version number in the
       response sent to clients. To avoid this, custom error handling can be
-      configured within each web application. Alternatively, the version number
-      can be changed by creating the file
+      configured within each web application. Alternatively, you can explicitly
+      configure an <a href="config/valve.html">ErrorReportValve</a> and set its
+      <strong>showServerInfo</strong> attribute to <code>false</code>.
+      Alternatively, the version number can be changed by creating the file
       CATALINA_BASE/lib/org/apache/catalina/util/ServerInfo.properties with
       content as follows:</p>
       <source>server.info=Apache Tomcat/<version-major-minor/>.x</source>

commit ce70ee6b8fe437a498a375215011056702b0c481
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Thu Apr 17 09:56:26 2014 +0000

    Small optimisation. The resolver and the factory are only used when running under a security manager so only load them in this case.
    Also avoid a possible memory leak when creating these objects.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1588193 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index 58a2435..5e85690 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -43,6 +43,7 @@ public final class SecurityClassLoad {
         loadCoyotePackage(loader);
         loadLoaderPackage(loader);
         loadRealmPackage(loader);
+        loadServletsPackage(loader);
         loadSessionPackage(loader);
         loadUtilPackage(loader);
         loadValvesPackage(loader);
@@ -126,6 +127,18 @@ public final class SecurityClassLoad {
     }
 
 
+    private static final void loadServletsPackage(ClassLoader loader)
+            throws Exception {
+        final String basePackage = "org.apache.catalina.servlets.";
+        // Avoid a possible memory leak in the DefaultServlet when running with
+        // a security manager. The DefaultServlet needs to load an XML parser
+        // when running under a security manager. We want this to be loaded by
+        // the container rather than a web application to prevent a memory leak
+        // via web application class loader.
+        loader.loadClass(basePackage + "DefaultServlet");
+    }
+
+
     private static final void loadSessionPackage(ClassLoader loader)
             throws Exception {
         final String basePackage = "org.apache.catalina.session.";
diff --git a/java/org/apache/catalina/servlets/DefaultServlet.java b/java/org/apache/catalina/servlets/DefaultServlet.java
index a8b47ee..0c678eb 100644
--- a/java/org/apache/catalina/servlets/DefaultServlet.java
+++ b/java/org/apache/catalina/servlets/DefaultServlet.java
@@ -132,8 +132,7 @@ public class DefaultServlet extends HttpServlet {
 
     private static final DocumentBuilderFactory factory;
 
-    private static final SecureEntityResolver secureEntityResolver =
-            new SecureEntityResolver();
+    private static final SecureEntityResolver secureEntityResolver;
 
     /**
      * Full range marker.
@@ -166,9 +165,15 @@ public class DefaultServlet extends HttpServlet {
         urlEncoder.addSafeCharacter('*');
         urlEncoder.addSafeCharacter('/');
 
-        factory = DocumentBuilderFactory.newInstance();
-        factory.setNamespaceAware(true);
-        factory.setValidating(false);
+        if (Globals.IS_SECURITY_ENABLED) {
+            factory = DocumentBuilderFactory.newInstance();
+            factory.setNamespaceAware(true);
+            factory.setValidating(false);
+            secureEntityResolver = new SecureEntityResolver();
+        } else {
+            factory = null;
+            secureEntityResolver = null;
+        }
     }
 
 

commit 41c0827a50192a12843bddbaa0b62a348c5115c1
Author: Konstantin Kolinko <kkolinko@apache.org>
Date:   Fri Feb 21 15:13:15 2014 +0000

    Allow to limit JUnit test run to a number of selected test case methods.
    
    BUILDING.txt says that Ant 1.8.x is needed.
    If we require a later version of Ant, e.g. 1.9.3 due to javadoc task security fixes,
    then Ant 1.8.2 comment in BUILDING.txt can be removed.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1570601 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/BUILDING.txt b/BUILDING.txt
index 14f5f20..ec98f0e 100644
--- a/BUILDING.txt
+++ b/BUILDING.txt
@@ -338,6 +338,16 @@ For example:
 
     test.entry=org.apache.catalina.util.TestServerInfo
 
+It is possible to further limit such run to a number of selected test
+methods by adding "test.entry.methods" property. The property specifies a
+comma-separated list of test case methods. (This feature requires
+Apache Ant 1.8.2 or later).
+
+For example:
+
+    test.entry=org.apache.el.lang.TestELArithmetic
+    test.entry.methods=testMultiply01,testMultiply02
+
 
 (7.3) Other configuration options
 
diff --git a/build.xml b/build.xml
index 4838fb6..6ba78fe 100644
--- a/build.xml
+++ b/build.xml
@@ -1367,7 +1367,12 @@
                    extension="@{extension}${junit.formatter.extension}" />
 
         <!-- If test.entry is defined, run a single test, otherwise run all valid tests -->
-        <test todir="${tomcat.build}/logs" name="${test.entry}" if="test.entry"/>
+        <test todir="${tomcat.build}/logs" name="${test.entry}"
+              if="test.entry" unless="test.entry.methods"
+           />
+        <test todir="${tomcat.build}/logs" name="${test.entry}" methods="${test.entry.methods}"
+              if="test.entry.methods"
+           />
         <batchtest todir="${tomcat.build}/logs" unless="test.entry">
           <fileset dir="test" >
             <!-- Include all by default -->

commit 7b3934c8c6eb20039157b25da01bd8ab9906a614
Author: Konstantin Kolinko <kkolinko@apache.org>
Date:   Fri Jan 24 19:53:00 2014 +0000

    Remove svn:keywords property from catalina/(mapper|mbeans|realm|security|servlets|session)/**
    
    svn propdel svn:keywords --depth infinity
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1561135 13f79535-47bb-0310-9956-ffa450edef68

commit a37b2168927ca530162b8ac876d103b627fea89c
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Fri Jan 10 16:34:46 2014 +0000

    Follow up to r1557113 - fix failure when running under a security manager
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1557180 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index c08d926..8c22195 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -153,7 +153,7 @@ public final class SecurityClassLoad {
     private static final void loadValvesPackage(ClassLoader loader)
             throws Exception {
         final String basePackage = "org.apache.catalina.valves.";
-        loader.loadClass(basePackage + "AccessLogValve$3");
+        loader.loadClass(basePackage + "AbstractAccessLogValve$3");
     }
 
 

commit 2e39008e220ffc3d39d3820601a2642445ce69b4
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Tue Dec 17 18:47:49 2013 +0000

    Fix a reported issue when running under a security manager.
    Refactor to enable some basic unit testing to hopefully avoid some of these issues in future.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1551652 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index 7a632ad..74eff12 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -30,10 +30,15 @@ package org.apache.catalina.security;
 
 public final class SecurityClassLoad {
 
-    public static void securityClassLoad(ClassLoader loader)
-        throws Exception {
+    public static void securityClassLoad(ClassLoader loader) throws Exception {
+        securityClassLoad(loader, true);
+    }
+
+
+    static void securityClassLoad(ClassLoader loader, boolean requireSecurityManager)
+            throws Exception {
 
-        if( System.getSecurityManager() == null ){
+        if (requireSecurityManager && System.getSecurityManager() == null) {
             return;
         }
 
@@ -280,8 +285,9 @@ public final class SecurityClassLoad {
         loader.loadClass(basePackage +
                 "util.net.NioBlockingSelector$BlockPoller$3");
         loader.loadClass(basePackage + "util.net.SSLSupport$CipherData");
+        // threads
         loader.loadClass
-            (basePackage + "util.net.AbstractEndpoint$PrivilegedSetTccl");
+            (basePackage + "util.threads.TaskThreadFactory$PrivilegedSetTccl");
     }
 }
 

commit ad10732ec868df4bd66b14a173d3f37a87c55917
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Mon Nov 25 14:06:06 2013 +0000

    Prevent a web application from deploying if it contains a context.xml, deployXML is false and there is no explicit descriptor as the descriptor may contain necessary security information.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1545288 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/startup/HostConfig.java b/java/org/apache/catalina/startup/HostConfig.java
index 5007756..463b13c 100644
--- a/java/org/apache/catalina/startup/HostConfig.java
+++ b/java/org/apache/catalina/startup/HostConfig.java
@@ -766,26 +766,24 @@ public class HostConfig
                 cn.getBaseName() + "/META-INF/context.xml");
 
         boolean xmlInWar = false;
-        if (deployXML) {
-            JarEntry entry = null;
-            try {
-                jar = new JarFile(war);
-                entry = jar.getJarEntry(Constants.ApplicationContextXml);
-                if (entry != null) {
-                    xmlInWar = true;
-                }
-            } catch (IOException e) {
-                /* Ignore */
-            } finally {
-                entry = null;
-                if (jar != null) {
-                    try {
-                        jar.close();
-                    } catch (IOException ioe) {
-                        // Ignore;
-                    }
-                    jar = null;
+        JarEntry entry = null;
+        try {
+            jar = new JarFile(war);
+            entry = jar.getJarEntry(Constants.ApplicationContextXml);
+            if (entry != null) {
+                xmlInWar = true;
+            }
+        } catch (IOException e) {
+            /* Ignore */
+        } finally {
+            entry = null;
+            if (jar != null) {
+                try {
+                    jar.close();
+                } catch (IOException ioe) {
+                    // Ignore;
                 }
+                jar = null;
             }
         }
 
@@ -809,7 +807,6 @@ public class HostConfig
                 context.setConfigFile(xml.toURI().toURL());
             } else if (deployXML && xmlInWar) {
                 synchronized (digester) {
-                    JarEntry entry = null;
                     try {
                         jar = new JarFile(war);
                         entry =
@@ -847,6 +844,12 @@ public class HostConfig
                         digester.reset();
                     }
                 }
+            } else if (!deployXML && xmlInWar) {
+                // Block deployment as META-INF/context.xml may contain security
+                // configuration necessary for a secure deployment.
+                log.error(sm.getString("hostConfig.deployDescriptor.blocked",
+                        cn.getPath(), Constants.ApplicationContextXml,
+                        new File(host.getConfigBaseFile(), cn.getBaseName() + ".xml")));
             } else {
                 context = (Context) Class.forName(contextClass).newInstance();
             }
@@ -875,7 +878,7 @@ public class HostConfig
                 // Change location of XML file to config base
                 xml = new File(host.getConfigBaseFile(),
                         cn.getBaseName() + ".xml");
-                JarEntry entry = null;
+                entry = null;
                 try {
                     jar = new JarFile(war);
                     entry =
@@ -1103,6 +1106,12 @@ public class HostConfig
                 } else {
                     context.setConfigFile(xml.toURI().toURL());
                 }
+            } else if (!deployXML && xml.exists()) {
+                // Block deployment as META-INF/context.xml may contain security
+                // configuration necessary for a secure deployment.
+                log.error(sm.getString("hostConfig.deployDescriptor.blocked",
+                        cn.getPath(), xml, xmlCopy));
+                context = new FailedContext();
             } else {
                 context = (Context) Class.forName(contextClass).newInstance();
             }
diff --git a/java/org/apache/catalina/startup/LocalStrings.properties b/java/org/apache/catalina/startup/LocalStrings.properties
index 2e04459..5b884e4 100644
--- a/java/org/apache/catalina/startup/LocalStrings.properties
+++ b/java/org/apache/catalina/startup/LocalStrings.properties
@@ -86,6 +86,7 @@ hostConfig.context.remove=Error while removing context [{0}]
 hostConfig.context.restart=Error during context [{0}] restart
 hostConfig.createDirs=Unable to create directory for deployment: {0}
 hostConfig.deployDescriptor=Deploying configuration descriptor {0}
+hostConfig.deployDescriptor.blocked=The web application with context path [{0}] was not deployed because it contained a deployment descriptor [{1}] which may include configuration necessary for the secure deployment of the application but processing of deployment descriptors is prevented by the deloyXML setting of this host. An appropriate descriptor should be created at [{2}] to deploy this application.
 hostConfig.deployDescriptor.error=Error deploying configuration descriptor {0}
 hostConfig.deployDescriptor.threaded.error=Error waiting for multi-thread deployment of context descriptors to complete
 hostConfig.deployDescriptor.localDocBaseSpecified=A docBase {0} inside the host appBase has been specified, and will be ignored

commit c83d975c5873c327b20a68862216b8b55602cf7d
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Mon Nov 25 10:26:26 2013 +0000

    When running under a security manager disabled deployXML by default.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1545213 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/core/StandardHost.java b/java/org/apache/catalina/core/StandardHost.java
index 67d5783..8cf03d1 100644
--- a/java/org/apache/catalina/core/StandardHost.java
+++ b/java/org/apache/catalina/core/StandardHost.java
@@ -31,6 +31,7 @@ import javax.management.ObjectName;
 import org.apache.catalina.Container;
 import org.apache.catalina.Context;
 import org.apache.catalina.Engine;
+import org.apache.catalina.Globals;
 import org.apache.catalina.Host;
 import org.apache.catalina.JmxEnabled;
 import org.apache.catalina.Lifecycle;
@@ -128,7 +129,7 @@ public class StandardHost extends ContainerBase implements Host {
     /**
      * deploy Context XML config files property.
      */
-    private boolean deployXML = true;
+    private boolean deployXML = !Globals.IS_SECURITY_ENABLED;
 
 
     /**
diff --git a/webapps/docs/config/host.xml b/webapps/docs/config/host.xml
index 7e293dd..aae0252 100644
--- a/webapps/docs/config/host.xml
+++ b/webapps/docs/config/host.xml
@@ -242,7 +242,8 @@
         then be responsible for providing an external context configuration
         file, and putting it in the location defined by the
         <strong>xmlBase</strong> attribute. The flag's value defaults to
-        <code>true</code>.</p>
+        <code>true</code> unless a security manager is enabled when the default
+        is <code>false</code>.</p>
       </attribute>
 
       <attribute name="errorReportValveClass" required="false">
diff --git a/webapps/docs/security-howto.xml b/webapps/docs/security-howto.xml
index c80ba95..44132c9 100644
--- a/webapps/docs/security-howto.xml
+++ b/webapps/docs/security-howto.xml
@@ -173,6 +173,13 @@
     manager should be introduced at the start of the development cycle as it can
     be time-consuming to track down and fix issues caused by enabling a security
     manager for a mature application.</p>
+    
+    <p>Enabling the security manager changes the defaults for the following
+    settings:</p>
+    <ul>
+      <li>The default value for the <strong>deployXML</strong> attribute of the
+      <strong>Host</strong> element is changed to <code>false</code>.</li>
+    </ul>
   </section>
 
   <section name="server.xml">
@@ -293,9 +300,11 @@
       </p>
 
       <p>In a hosted environment where web applications may not be trusted, set
-      the <strong>deployXML</strong> attribute to <code>false</code> to ignore any
-      context.xml packaged with the web application that may try to assign
-      increased privileges to the web application. </p>
+      the <strong>deployXML</strong> attribute to <code>false</code> to ignore
+      any context.xml packaged with the web application that may try to assign
+      increased privileges to the web application. Note that if the security
+      manager is enabled that the <strong>deployXML</strong> attribute will
+      default to <code>false</code>.</p>
     </subsection>
 
     <subsection name="Context">

commit 27806aa373fb25c125036198d802d59936aef1b2
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Fri Nov 15 17:39:05 2013 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=55778
    Make value used for javax.security.sasl.qop with SPNEGO configurable.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1542339 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/realm/JNDIRealm.java b/java/org/apache/catalina/realm/JNDIRealm.java
index d55f174..38f3518 100644
--- a/java/org/apache/catalina/realm/JNDIRealm.java
+++ b/java/org/apache/catalina/realm/JNDIRealm.java
@@ -427,6 +427,14 @@ public class JNDIRealm extends RealmBase {
     protected boolean useDelegatedCredential = true;
 
 
+    /**
+     * The QOP that should be used for the connection to the LDAP server after
+     * authentication. This value is used to set the
+     * <code>javax.security.sasl.qop</code> environment property for the LDAP
+     * connection.
+     */
+    protected String spengoDelegationQop = "auth-conf";
+
     // ------------------------------------------------------------- Properties
 
     /**
@@ -980,7 +988,6 @@ public class JNDIRealm extends RealmBase {
     }
 
 
-
     public boolean isUseDelegatedCredential() {
         return useDelegatedCredential;
     }
@@ -990,6 +997,15 @@ public class JNDIRealm extends RealmBase {
     }
 
 
+    public String getSpengoDelegationQop() {
+        return spengoDelegationQop;
+    }
+
+    public void setSpengoDelegationQop(String spengoDelegationQop) {
+        this.spengoDelegationQop = spengoDelegationQop;
+    }
+
+
     // ---------------------------------------------------------- Realm Methods
 
     /**
@@ -2062,7 +2078,7 @@ public class JNDIRealm extends RealmBase {
                 context.addToEnvironment(
                         "javax.security.sasl.server.authentication", "true");
                 context.addToEnvironment(
-                        "javax.security.sasl.qop", "auth-conf");
+                        "javax.security.sasl.qop", spengoDelegationQop);
                 // Note: Subject already set in SPNEGO authenticator so no need
                 //       for Subject.doAs() here
             }
diff --git a/webapps/docs/config/realm.xml b/webapps/docs/config/realm.xml
index 3b8d256..5cd6cd7 100644
--- a/webapps/docs/config/realm.xml
+++ b/webapps/docs/config/realm.xml
@@ -551,6 +551,17 @@
         <code>0</code> is used which indicates no limit.</p>
       </attribute>
 
+      <attribute mame="spengoDelegationQop" requireed="false">
+        <p>When the JNDI Realm is used with the SPNEGO authenticator and
+        <code>useDelegatedCredential</code> is <code>true</code> this attribute
+        controls the QOP that should be used for the connection to the LDAP
+        server after authentication. This value is used to set the
+        <code>javax.security.sasl.qop</code> environment property for the LDAP
+        connection. This attribute should be a comma-separated list of values
+        selected from <code>auth-conf</code>, <code>auth-int</code> and
+        <code>auth</code>. The default value is <code>auth-conf</code>.</p>
+      </attribute>
+
       <attribute name="stripRealmForGss" required="false">
         <p>When processing users authenticated via the GSS-API, this attribute
         controls if any &quot;@...&quot; is removed from the end of the user
@@ -565,7 +576,7 @@
       </attribute>
 
       <attribute name="useDelegatedCredential" required="false">
-        <p>When the JNIRealm is used with the SPNEGO authenticator, delegated
+        <p>When the JNDIRealm is used with the SPNEGO authenticator, delegated
         credentials for the user may be available. If such credentials are
         present, this attribute controls whether are not they are used to
         connect to the directory. If not specified, the default value of

commit 0fb7439a77a7e719df8203d826431c3d7ca3b537
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Mon Nov 11 11:25:50 2013 +0000

    Add more detail to the security how-to
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1540670 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/webapps/docs/security-howto.xml b/webapps/docs/security-howto.xml
index 21a59ff..58f489e 100644
--- a/webapps/docs/security-howto.xml
+++ b/webapps/docs/security-howto.xml
@@ -72,10 +72,74 @@
   </section>
 
   <section name="Default web applications">
-    <p>Tomcat ships with a number of web applications by default.
-    Vulnerabilities have been discovered in these applications in the past.
-    Applications that are not required should be removed so the system will not
-    be at risk if another vulnerability is discovered.</p>
+
+    <subsection name="General">
+      <p>Tomcat ships with a number of web applications that are enabled by
+      default. Vulnerabilities have been discovered in these applications in the
+      past. Applications that are not required should be removed so the system
+      will not be at risk if another vulnerability is discovered.</p>
+    </subsection>
+
+    <subsection name="ROOT">
+      <p>The ROOT web application presents a very low security risk but it does
+      include the version of Tomcat that is being used. The ROOT web application
+      should normally be removed from a publicly accessible Tomcat instance, not
+      for security reasons, but so that a more appropriate default page is shown
+      to users.</p>
+    </subsection>
+
+    <subsection name="Documentation">
+      <p>The documentation web application presents a very low security risk but
+      it does identify the version of Tomcat that is being used. It should
+      normally be removed from a publicly accessible Tomcat instance.</p>
+    </subsection>
+
+    <subsection name="Examples">
+      <p>The examples web application should always be removed from any security
+      sensitive installation. While the examples web application does not
+      contain any known vulnerabilities, it is known to contain features
+      (particularly the cookie examples that display the contents of all
+      received and allow new cookies to be set) that may be used by an attacker
+      in conjunction with a vulnerability in another application deployed on the
+      Tomcat instance to obtain additional information that would otherwise be
+      unavailable.</p>
+    </subsection>
+
+    <subsection name="Manager">
+      <p>The Manager application allows the remote deployment of web
+      applications and is frequently targeted by attackers due to the widespread
+      use of weak passwords and publicly accessible Tomcat instances with the
+      Manager application enabled. The Manager application is not accessible by
+      default as no users are configured with the necessary access. If the
+      Manager application is enabled then guidance in the section
+      <strong>Securing Management Applications</strong> section should be
+      followed.</p>
+    </subsection>
+
+    <subsection name="Host Manager">
+      <p>The Host Manager application allows the creation and management of
+      virtual hosts - including the enabling of the Manager application for a
+      virtual host. The Host Manager application is not accessible by default a
+      no users are configured with the necessary access. If the Manager
+      application is enabled then guidance in the section <strong>Securing
+      Management Applications</strong> section should be followed.</p>
+    </subsection>
+
+   <subsection name="Securing Management Applications">
+     <p>When deploying a web application that provides management functions for
+     the Tomcat instance, the following guidelines should be followed:</p>
+     <ul>
+       <ol>Ensure that any users permitted to access the management application
+           have strong passwords.</ol>
+       <ol>Do not remove the use of the <a
+           href="config/realm.html#LockOut_Realm_-_org.apache.catalina.realm.LockOutRealm">LockOutRealm</a>
+           which prevents brute force attacks against user passwords.</ol>
+       <ol>Uncomment the <a href="config/valve.html#Remote_Address_Filter">RemoteAddrValve</a>
+           in <code>/META-INF/context.xml</code> which limits access to
+           localhost. If remote access is required, limit it to specific IP
+           addresses using this valve.</ol>
+     </ul>
+   </subsection>
   </section>
 
   <section name="Security manager">

commit 2470216479bbfed93941a54768960198a0d01981
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Tue Oct 15 20:15:03 2013 +0000

    Fix Servlet 3.1 non-blocking when running with a security manager
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1532511 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index 8423ede..7a632ad 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -272,6 +272,7 @@ public final class SecurityClassLoad {
         loader.loadClass(basePackage + "util.http.parser.MediaTypeCache");
         // net
         loader.loadClass(basePackage + "util.net.Constants");
+        loader.loadClass(basePackage + "util.net.DispatchType");
         loader.loadClass(basePackage +
                 "util.net.NioBlockingSelector$BlockPoller$1");
         loader.loadClass(basePackage +

commit ae819efa7810c5a8b4eb41ad615d9d2a0c45243b
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Tue Oct 15 20:00:14 2013 +0000

    Fix WebSocket when running under a security manager
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1532506 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/conf/catalina.policy b/conf/catalina.policy
index a90ea3a..cf69af9 100644
--- a/conf/catalina.policy
+++ b/conf/catalina.policy
@@ -191,8 +191,9 @@ grant {
     // Applications using Comet need to be able to access this package
     permission java.lang.RuntimePermission "accessClassInPackage.org.apache.catalina.comet";
 
-    // Applications using WebSocket need to be able to access this package
-    permission java.lang.RuntimePermission "accessClassInPackage.org.apache.catalina.websocket";
+    // Applications using WebSocket need to be able to access these packages
+    permission java.lang.RuntimePermission "accessClassInPackage.org.apache.tomcat.websocket";
+    permission java.lang.RuntimePermission "accessClassInPackage.org.apache.tomcat.websocket.server";
 };
 
 

commit 1a5f2dec07dcb82b551b2eb39467b19298268376
Author: Konstantin Preier <kpreisser@apache.org>
Date:   Thu Sep 26 15:21:06 2013 +0000

    Improve Snake Websocket example:
    - Fix invalid JSON syntax (Strings always need to be in double-quotes)
    - In JavaScript, use JSON.parse() instead of eval() to parse JSON strings, to avoid potential security problems.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1526565 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/webapps/examples/WEB-INF/classes/websocket/snake/Snake.java b/webapps/examples/WEB-INF/classes/websocket/snake/Snake.java
index 5d3a94c..8a58be9 100644
--- a/webapps/examples/WEB-INF/classes/websocket/snake/Snake.java
+++ b/webapps/examples/WEB-INF/classes/websocket/snake/Snake.java
@@ -52,12 +52,12 @@ public class Snake {
 
     private synchronized void kill() {
         resetState();
-        sendMessage("{'type': 'dead'}");
+        sendMessage("{\"type\": \"dead\"}");
     }
 
     private synchronized void reward() {
         length++;
-        sendMessage("{'type': 'kill'}");
+        sendMessage("{\"type\": \"kill\"}");
     }
 
 
@@ -121,14 +121,14 @@ public class Snake {
 
     public synchronized String getLocationsJson() {
         StringBuilder sb = new StringBuilder();
-        sb.append(String.format("{x: %d, y: %d}",
+        sb.append(String.format("{\"x\": %d, \"y\": %d}",
                 Integer.valueOf(head.x), Integer.valueOf(head.y)));
         for (Location location : tail) {
             sb.append(',');
-            sb.append(String.format("{x: %d, y: %d}",
+            sb.append(String.format("{\"x\": %d, \"y\": %d}",
                     Integer.valueOf(location.x), Integer.valueOf(location.y)));
         }
-        return String.format("{'id':%d,'body':[%s]}",
+        return String.format("{\"id\":%d,\"body\":[%s]}",
                 Integer.valueOf(id), sb.toString());
     }
 
diff --git a/webapps/examples/WEB-INF/classes/websocket/snake/SnakeAnnotation.java b/webapps/examples/WEB-INF/classes/websocket/snake/SnakeAnnotation.java
index ba63250..ab929fa 100644
--- a/webapps/examples/WEB-INF/classes/websocket/snake/SnakeAnnotation.java
+++ b/webapps/examples/WEB-INF/classes/websocket/snake/SnakeAnnotation.java
@@ -79,13 +79,13 @@ public class SnakeAnnotation {
         for (Iterator<Snake> iterator = SnakeTimer.getSnakes().iterator();
                 iterator.hasNext();) {
             Snake snake = iterator.next();
-            sb.append(String.format("{id: %d, color: '%s'}",
+            sb.append(String.format("{\"id\": %d, \"color\": \"%s\"}",
                     Integer.valueOf(snake.getId()), snake.getHexColor()));
             if (iterator.hasNext()) {
                 sb.append(',');
             }
         }
-        SnakeTimer.broadcast(String.format("{'type': 'join','data':[%s]}",
+        SnakeTimer.broadcast(String.format("{\"type\": \"join\",\"data\":[%s]}",
                 sb.toString()));
     }
 
@@ -107,7 +107,7 @@ public class SnakeAnnotation {
     @OnClose
     public void onClose() {
         SnakeTimer.removeSnake(snake);
-        SnakeTimer.broadcast(String.format("{'type': 'leave', 'id': %d}",
+        SnakeTimer.broadcast(String.format("{\"type\": \"leave\", \"id\": %d}",
                 Integer.valueOf(id)));
     }
 }
diff --git a/webapps/examples/WEB-INF/classes/websocket/snake/SnakeTimer.java b/webapps/examples/WEB-INF/classes/websocket/snake/SnakeTimer.java
index 5b664b6..0e939bc 100644
--- a/webapps/examples/WEB-INF/classes/websocket/snake/SnakeTimer.java
+++ b/webapps/examples/WEB-INF/classes/websocket/snake/SnakeTimer.java
@@ -73,7 +73,7 @@ public class SnakeTimer {
                 sb.append(',');
             }
         }
-        broadcast(String.format("{'type': 'update', 'data' : [%s]}",
+        broadcast(String.format("{\"type\": \"update\", \"data\" : [%s]}",
                 sb.toString()));
     }
 
diff --git a/webapps/examples/websocket/snake.xhtml b/webapps/examples/websocket/snake.xhtml
index fdc3e97..a65f27f 100644
--- a/webapps/examples/websocket/snake.xhtml
+++ b/webapps/examples/websocket/snake.xhtml
@@ -209,8 +209,7 @@
             };
 
             Game.socket.onmessage = function (message) {
-                // _Potential_ security hole, consider using json lib to parse data in production.
-                var packet = eval('(' + message.data + ')');
+                var packet = JSON.parse(message.data);
                 switch (packet.type) {
                     case 'update':
                         for (var i = 0; i < packet.data.length; i++) {

commit fb010025639a37c94160e01d2ccf971ee1cf0675
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Wed Sep 18 20:24:02 2013 +0000

    Fix starting with a security manager
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1524557 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index c7c6482..8423ede 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -280,9 +280,7 @@ public final class SecurityClassLoad {
                 "util.net.NioBlockingSelector$BlockPoller$3");
         loader.loadClass(basePackage + "util.net.SSLSupport$CipherData");
         loader.loadClass
-            (basePackage + "util.net.JIoEndpoint$PrivilegedSetTccl");
-        loader.loadClass
-            (basePackage + "util.net.AprEndpoint$PrivilegedSetTccl");
+            (basePackage + "util.net.AbstractEndpoint$PrivilegedSetTccl");
     }
 }
 

commit 2710b05e708361eb00e0abad11ecd801dbce1c28
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Wed Aug 7 09:16:31 2013 +0000

    When using a security manager always use the same method inside the doPrivileged call as triggered the call. This fixes an startup failure when running 8.0.x under a security manager as it uses a listener that does not have a zero arg constructor.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1511217 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/core/ApplicationContextFacade.java b/java/org/apache/catalina/core/ApplicationContextFacade.java
index a361939..1dd59c4 100644
--- a/java/org/apache/catalina/core/ApplicationContextFacade.java
+++ b/java/org/apache/catalina/core/ApplicationContextFacade.java
@@ -462,7 +462,8 @@ public class ApplicationContextFacade implements ServletContext {
             Class<? extends Filter> filterClass) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
             return (FilterRegistration.Dynamic) doPrivileged("addFilter",
-                    new Object[]{filterName, filterClass.getName()});
+                    new Class[]{String.class, Class.class},
+                    new Object[]{filterName, filterClass});
         } else {
             return context.addFilter(filterName, filterClass);
         }
@@ -530,7 +531,8 @@ public class ApplicationContextFacade implements ServletContext {
             Class<? extends Servlet> servletClass) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
             return (ServletRegistration.Dynamic) doPrivileged("addServlet",
-                    new Object[]{servletName, servletClass.getName()});
+                    new Class[]{String.class, Class.class},
+                    new Object[]{servletName, servletClass});
         } else {
             return context.addServlet(servletName, servletClass);
         }
@@ -630,7 +632,8 @@ public class ApplicationContextFacade implements ServletContext {
     public void addListener(Class<? extends EventListener> listenerClass) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
             doPrivileged("addListener",
-                    new Object[]{listenerClass.getName()});
+                    new Class[]{Class.class},
+                    new Object[]{listenerClass});
         } else {
             context.addListener(listenerClass);
         }
@@ -652,7 +655,8 @@ public class ApplicationContextFacade implements ServletContext {
     public <T extends EventListener> void addListener(T t) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
             doPrivileged("addListener",
-                    new Object[]{t.getClass().getName()});
+                    new Class[]{EventListener.class},
+                    new Object[]{t});
         } else {
             context.addListener(t);
         }
@@ -683,9 +687,7 @@ public class ApplicationContextFacade implements ServletContext {
     @Override
     public void declareRoles(String... roleNames) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
-//FIXME
-            doPrivileged("declareRoles",
-                    new Object[]{roleNames});
+            doPrivileged("declareRoles", new Object[]{roleNames});
         } else {
             context.declareRoles(roleNames);
         }

commit 7682a4f48a62b007af3a709c9ee5b91a5aab1872
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Fri Jun 21 12:41:13 2013 +0000

    Expand test cases for servlet security annotations to include deny uncovered http methods.
    Fix the failure identified by violetagg
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1495414 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/core/StandardContext.java b/java/org/apache/catalina/core/StandardContext.java
index ff8a21c..195b3dd 100644
--- a/java/org/apache/catalina/core/StandardContext.java
+++ b/java/org/apache/catalina/core/StandardContext.java
@@ -5291,7 +5291,7 @@ public class StandardContext extends ContainerBase
             // Needs to be after SCIs and listeners as they may programatically
             // change constraints
             if (ok) {
-                checkConstraintsForUncoveredMethods();
+                checkConstraintsForUncoveredMethods(findConstraints());
             }
 
             try {
@@ -5358,9 +5358,10 @@ public class StandardContext extends ContainerBase
     }
 
 
-    private void checkConstraintsForUncoveredMethods() {
+    private void checkConstraintsForUncoveredMethods(
+            SecurityConstraint[] constraints) {
         SecurityConstraint[] newConstraints =
-                SecurityConstraint.findUncoveredHttpMethods(findConstraints(),
+                SecurityConstraint.findUncoveredHttpMethods(constraints,
                         getDenyUncoveredHttpMethods(), getLogger());
         for (SecurityConstraint constraint : newConstraints) {
             addConstraint(constraint);
@@ -5838,6 +5839,8 @@ public class StandardContext extends ContainerBase
                         newSecurityConstraints) {
                     addConstraint(securityConstraint);
                 }
+
+                checkConstraintsForUncoveredMethods(newSecurityConstraints);
             }
         }
 
diff --git a/test/org/apache/catalina/core/TestStandardWrapper.java b/test/org/apache/catalina/core/TestStandardWrapper.java
index 3ce457e..f381eba 100644
--- a/test/org/apache/catalina/core/TestStandardWrapper.java
+++ b/test/org/apache/catalina/core/TestStandardWrapper.java
@@ -62,37 +62,89 @@ public class TestStandardWrapper extends TomcatBaseTest {
 
     @Test
     public void testSecurityAnnotationsSimple() throws Exception {
-        doTest(DenyAllServlet.class.getName(), false, false, false);
+        doTest(DenyAllServlet.class.getName(), false, false, false, false);
     }
 
     @Test
     public void testSecurityAnnotationsSubclass1() throws Exception {
-        doTest(SubclassDenyAllServlet.class.getName(), false, false, false);
+        doTest(SubclassDenyAllServlet.class.getName(),
+                false, false, false,false);
     }
 
     @Test
     public void testSecurityAnnotationsSubclass2() throws Exception {
-        doTest(SubclassAllowAllServlet.class.getName(), false, false, true);
+        doTest(SubclassAllowAllServlet.class.getName(),
+                false, false, true, false);
     }
 
     @Test
     public void testSecurityAnnotationsMethods1() throws Exception {
-        doTest(MethodConstraintServlet.class.getName(), false, false, false);
+        doTest(MethodConstraintServlet.class.getName(),
+                false, false, false, false);
     }
 
     @Test
     public void testSecurityAnnotationsMethods2() throws Exception {
-        doTest(MethodConstraintServlet.class.getName(), true, false, true);
+        doTest(MethodConstraintServlet.class.getName(),
+                true, false, true, false);
     }
 
     @Test
     public void testSecurityAnnotationsRole1() throws Exception {
-        doTest(RoleAllowServlet.class.getName(), false, true, true);
+        doTest(RoleAllowServlet.class.getName(), false, true, true, false);
     }
 
     @Test
     public void testSecurityAnnotationsRole2() throws Exception {
-        doTest(RoleDenyServlet.class.getName(), false, true, false);
+        doTest(RoleDenyServlet.class.getName(), false, true, false, false);
+    }
+
+    @Test
+    public void testSecurityAnnotationsUncoveredGet01() throws Exception {
+        // Use a POST with role - should be allowed
+        doTest(UncoveredGetServlet.class.getName(), true, true, true, false);
+    }
+
+    @Test
+    public void testSecurityAnnotationsUncoveredGet02() throws Exception {
+        // Use a POST with role - should be allowed
+        doTest(UncoveredGetServlet.class.getName(), true, true, true, true);
+    }
+
+    @Test
+    public void testSecurityAnnotationsUncoveredGet03() throws Exception {
+        // Use a POST no role - should be blocked
+        doTest(UncoveredGetServlet.class.getName(), true, false, false, false);
+    }
+
+    @Test
+    public void testSecurityAnnotationsUncoveredGet04() throws Exception {
+        // Use a POST no role - should be blocked
+        doTest(UncoveredGetServlet.class.getName(), true, false, false, true);
+    }
+
+    @Test
+    public void testSecurityAnnotationsUncoveredGet05() throws Exception {
+        // Use a GET with role - should be allowed as denyUncovered is false
+        doTest(UncoveredGetServlet.class.getName(), false, true, true, false);
+    }
+
+    @Test
+    public void testSecurityAnnotationsUncoveredGet06() throws Exception {
+        // Use a GET with role - should be blocked as denyUncovered is true
+        doTest(UncoveredGetServlet.class.getName(), false, true, false, true);
+    }
+
+    @Test
+    public void testSecurityAnnotationsUncoveredGet07() throws Exception {
+        // Use a GET no role - should be allowed as denyUncovered is false
+        doTest(UncoveredGetServlet.class.getName(), false, false, true, false);
+    }
+
+    @Test
+    public void testSecurityAnnotationsUncoveredGet08() throws Exception {
+        // Use a GET no role - should be blocked as denyUncovered is true
+        doTest(UncoveredGetServlet.class.getName(), true, false, false, true);
     }
 
     @Test
@@ -223,7 +275,8 @@ public class TestStandardWrapper extends TomcatBaseTest {
     }
 
     private void doTest(String servletClassName, boolean usePost,
-            boolean useRole, boolean expect200) throws Exception {
+            boolean useRole, boolean expect200, boolean denyUncovered)
+            throws Exception {
 
         // Setup Tomcat instance
         Tomcat tomcat = getTomcatInstance();
@@ -231,6 +284,7 @@ public class TestStandardWrapper extends TomcatBaseTest {
         // Must have a real docBase - just use temp
         Context ctx =
             tomcat.addContext("", System.getProperty("java.io.tmpdir"));
+        ctx.setDenyUncoveredHttpMethods(denyUncovered);
 
         Wrapper wrapper = Tomcat.addServlet(ctx, "servlet", servletClassName);
         wrapper.setAsyncSupported(true);
@@ -318,6 +372,14 @@ public class TestStandardWrapper extends TomcatBaseTest {
         private static final long serialVersionUID = 1L;
     }
 
+    @ServletSecurity(httpMethodConstraints = {
+            @HttpMethodConstraint(value="POST",rolesAllowed = "testRole")
+        }
+    )
+    public static class UncoveredGetServlet extends TestServlet {
+        private static final long serialVersionUID = 1L;
+    }
+
     @ServletSecurity(@HttpConstraint(rolesAllowed = "testRole"))
     public static class RoleAllowServlet extends TestServlet {
         private static final long serialVersionUID = 1L;

commit bc685a094147703b683092ce896d83014b4f4291
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Tue Jun 18 20:46:53 2013 +0000

    Add tests for security constraint role combination
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1494295 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/test/org/apache/catalina/realm/TestRealmBase.java b/test/org/apache/catalina/realm/TestRealmBase.java
index 0b238ec..8d40689 100644
--- a/test/org/apache/catalina/realm/TestRealmBase.java
+++ b/test/org/apache/catalina/realm/TestRealmBase.java
@@ -28,7 +28,6 @@ import org.apache.catalina.connector.Request;
 import org.apache.catalina.connector.Response;
 import org.apache.catalina.connector.TesterResponse;
 import org.apache.catalina.core.TesterContext;
-import org.apache.catalina.deploy.SecurityCollection;
 import org.apache.catalina.deploy.SecurityConstraint;
 import org.apache.catalina.startup.TesterMapRealm;
 
@@ -37,6 +36,9 @@ public class TestRealmBase {
     private static final String USER1 = "user1";
     private static final String PWD1 = "password1";
     private static final String ROLE1 = "role1";
+    private static final String ROLE2 = "role2";
+    private static final String ROLE3 = "role3";
+    private static final String ROLE99 = "role99";
 
     @Test
     public void testUserWithSingleRole() throws IOException {
@@ -156,48 +158,398 @@ public class TestRealmBase {
 
     @Test
     public void testNoAuthConstraint() throws IOException {
-        // No auth constraint == allow access
+        // No auth constraint == allow access for all
+        List<String> applicationRoles = new ArrayList<>();
+
+        doRoleTest(null, null, applicationRoles, true);
+    }
+
+
+    /*
+     * The combining constraints tests are based on the scenarios described in
+     * section
+     */
+
+    @Test
+    public void testCombineConstraints01() throws IOException {
+        // Allowed roles should be the union of the roles in the constraints
+        // User role is in first constraint
+        List<String> userRoles = new ArrayList<>();
+        List<String> constraintOneRoles = new ArrayList<>();
+        List<String> constraintTwoRoles = new ArrayList<>();
+        List<String> applicationRoles = new ArrayList<>();
+
+        userRoles.add(ROLE1);
+        constraintOneRoles.add(ROLE1);
+        constraintTwoRoles.add(ROLE2);
+        applicationRoles.add(ROLE1);
+        applicationRoles.add(ROLE2);
+
+        doRoleTest(userRoles, constraintOneRoles, constraintTwoRoles,
+                applicationRoles, true);
+    }
+
+
+    @Test
+    public void testCombineConstraints02() throws IOException {
+        // Allowed roles should be the union of the roles in the constraints
+        // User role is in last constraint
+        List<String> userRoles = new ArrayList<>();
+        List<String> constraintOneRoles = new ArrayList<>();
+        List<String> constraintTwoRoles = new ArrayList<>();
+        List<String> applicationRoles = new ArrayList<>();
+
+        userRoles.add(ROLE2);
+        constraintOneRoles.add(ROLE1);
+        constraintTwoRoles.add(ROLE2);
+        applicationRoles.add(ROLE1);
+        applicationRoles.add(ROLE2);
+
+        doRoleTest(userRoles, constraintOneRoles, constraintTwoRoles,
+                applicationRoles, true);
+    }
+
+
+    @Test
+    public void testCombineConstraints03() throws IOException {
+        // Allowed roles should be the union of the roles in the constraints
+        // User role is not in any constraint
+        List<String> userRoles = new ArrayList<>();
+        List<String> constraintOneRoles = new ArrayList<>();
+        List<String> constraintTwoRoles = new ArrayList<>();
+        List<String> applicationRoles = new ArrayList<>();
+
+        userRoles.add(ROLE3);
+        constraintOneRoles.add(ROLE1);
+        constraintTwoRoles.add(ROLE2);
+        applicationRoles.add(ROLE1);
+        applicationRoles.add(ROLE2);
+
+        doRoleTest(userRoles, constraintOneRoles, constraintTwoRoles,
+                applicationRoles, false);
+    }
+
+
+    @Test
+    public void testCombineConstraints04() throws IOException {
+        // Allowed roles should be the union of the roles in the constraints
+        // * is any app role
+        // User role is not in any constraint
+        List<String> userRoles = new ArrayList<>();
+        List<String> constraintOneRoles = new ArrayList<>();
+        List<String> constraintTwoRoles = new ArrayList<>();
+        List<String> applicationRoles = new ArrayList<>();
+
+        userRoles.add(ROLE99);
+        constraintOneRoles.add(ROLE1);
+        constraintTwoRoles.add(SecurityConstraint.ROLE_ALL_ROLES);
+        applicationRoles.add(ROLE2);
+        applicationRoles.add(ROLE3);
+
+        doRoleTest(userRoles, constraintOneRoles, constraintTwoRoles,
+                applicationRoles, false);
+    }
+
+
+    @Test
+    public void testCombineConstraints05() throws IOException {
+        // Allowed roles should be the union of the roles in the constraints
+        // * is any app role
+        // User role is a non-app constraint role
+        List<String> userRoles = new ArrayList<>();
+        List<String> constraintOneRoles = new ArrayList<>();
+        List<String> constraintTwoRoles = new ArrayList<>();
+        List<String> applicationRoles = new ArrayList<>();
+
+        userRoles.add(ROLE1);
+        constraintOneRoles.add(ROLE1);
+        constraintTwoRoles.add(SecurityConstraint.ROLE_ALL_ROLES);
+        applicationRoles.add(ROLE2);
+        applicationRoles.add(ROLE3);
+
+        doRoleTest(userRoles, constraintOneRoles, constraintTwoRoles,
+                applicationRoles, true);
+    }
+
+
+    @Test
+    public void testCombineConstraints06() throws IOException {
+        // Allowed roles should be the union of the roles in the constraints
+        // * is any app role
+        // User role is an app role
+        List<String> userRoles = new ArrayList<>();
+        List<String> constraintOneRoles = new ArrayList<>();
+        List<String> constraintTwoRoles = new ArrayList<>();
+        List<String> applicationRoles = new ArrayList<>();
+
+        userRoles.add(ROLE2);
+        constraintOneRoles.add(ROLE1);
+        constraintTwoRoles.add(SecurityConstraint.ROLE_ALL_ROLES);
+        applicationRoles.add(ROLE2);
+        applicationRoles.add(ROLE3);
+
+        doRoleTest(userRoles, constraintOneRoles, constraintTwoRoles,
+                applicationRoles, true);
+    }
+
+
+    @Test
+    public void testCombineConstraints07() throws IOException {
+        // Allowed roles should be the union of the roles in the constraints
+        // * is any app role
+        // User has no role
+        List<String> userRoles = new ArrayList<>();
+        List<String> constraintOneRoles = new ArrayList<>();
+        List<String> constraintTwoRoles = new ArrayList<>();
+        List<String> applicationRoles = new ArrayList<>();
+
+        constraintOneRoles.add(ROLE1);
+        constraintTwoRoles.add(SecurityConstraint.ROLE_ALL_ROLES);
+        applicationRoles.add(ROLE2);
+        applicationRoles.add(ROLE3);
+
+        doRoleTest(userRoles, constraintOneRoles, constraintTwoRoles,
+                applicationRoles, false);
+    }
+
+
+    @Test
+    public void testCombineConstraints08() throws IOException {
+        // Allowed roles should be the union of the roles in the constraints
+        // ** is any authenticated user
+        // User has no role
+        List<String> userRoles = new ArrayList<>();
+        List<String> constraintOneRoles = new ArrayList<>();
+        List<String> constraintTwoRoles = new ArrayList<>();
+        List<String> applicationRoles = new ArrayList<>();
+
+        constraintOneRoles.add(ROLE1);
+        constraintTwoRoles.add(SecurityConstraint.ROLE_ALL_AUTHENTICATED_USERS);
+        applicationRoles.add(ROLE2);
+        applicationRoles.add(ROLE3);
+
+        doRoleTest(userRoles, constraintOneRoles, constraintTwoRoles,
+                applicationRoles, true);
+    }
+
+
+    @Test
+    public void testCombineConstraints09() throws IOException {
+        // Allowed roles should be the union of the roles in the constraints
+        // ** is any authenticated user
+        // User has constraint role
         List<String> userRoles = new ArrayList<>();
+        List<String> constraintOneRoles = new ArrayList<>();
+        List<String> constraintTwoRoles = new ArrayList<>();
         List<String> applicationRoles = new ArrayList<>();
 
-        doRoleTest(userRoles, null, applicationRoles, true);
+        userRoles.add(ROLE1);
+        constraintOneRoles.add(ROLE1);
+        constraintTwoRoles.add(SecurityConstraint.ROLE_ALL_AUTHENTICATED_USERS);
+        applicationRoles.add(ROLE2);
+        applicationRoles.add(ROLE3);
+
+        doRoleTest(userRoles, constraintOneRoles, constraintTwoRoles,
+                applicationRoles, true);
+    }
+
+
+    @Test
+    public void testCombineConstraints10() throws IOException {
+        // Allowed roles should be the union of the roles in the constraints
+        // ** is any authenticated user
+        // User has app role
+        List<String> userRoles = new ArrayList<>();
+        List<String> constraintOneRoles = new ArrayList<>();
+        List<String> constraintTwoRoles = new ArrayList<>();
+        List<String> applicationRoles = new ArrayList<>();
+
+        userRoles.add(ROLE2);
+        constraintOneRoles.add(ROLE1);
+        constraintTwoRoles.add(SecurityConstraint.ROLE_ALL_AUTHENTICATED_USERS);
+        applicationRoles.add(ROLE2);
+        applicationRoles.add(ROLE3);
+
+        doRoleTest(userRoles, constraintOneRoles, constraintTwoRoles,
+                applicationRoles, true);
+    }
+
+
+    @Test
+    public void testCombineConstraints11() throws IOException {
+        // Allowed roles should be the union of the roles in the constraints
+        // ** is any authenticated user
+        // User is not authenticated
+        List<String> constraintOneRoles = new ArrayList<>();
+        List<String> constraintTwoRoles = new ArrayList<>();
+        List<String> applicationRoles = new ArrayList<>();
+
+        constraintOneRoles.add(ROLE1);
+        constraintTwoRoles.add(SecurityConstraint.ROLE_ALL_AUTHENTICATED_USERS);
+        applicationRoles.add(ROLE2);
+        applicationRoles.add(ROLE3);
+
+        doRoleTest(null, constraintOneRoles, constraintTwoRoles,
+                applicationRoles, false);
+    }
+
+
+    @Test
+    public void testCombineConstraints12() throws IOException {
+        // Allowed roles should be the union of the roles in the constraints
+        // Constraint without role or implied role permits unauthenticated users
+        // User is not authenticated
+        List<String> constraintTwoRoles = new ArrayList<>();
+        List<String> applicationRoles = new ArrayList<>();
+
+        constraintTwoRoles.add(ROLE1);
+        applicationRoles.add(ROLE1);
+
+        doRoleTest(null, null, constraintTwoRoles,
+                applicationRoles, true);
+    }
+
+
+    @Test
+    public void testCombineConstraints13() throws IOException {
+        // Allowed roles should be the union of the roles in the constraints
+        // Constraint without role or implied role permits unauthenticated users
+        // User is not authenticated
+        List<String> constraintTwoRoles = new ArrayList<>();
+        List<String> applicationRoles = new ArrayList<>();
+
+        constraintTwoRoles.add(SecurityConstraint.ROLE_ALL_ROLES);
+        applicationRoles.add(ROLE1);
+
+        doRoleTest(null, null, constraintTwoRoles,
+                applicationRoles, true);
+    }
+
+
+    @Test
+    public void testCombineConstraints14() throws IOException {
+        // Allowed roles should be the union of the roles in the constraints
+        // Constraint without role or implied role permits unauthenticated users
+        // User is not authenticated
+        List<String> constraintTwoRoles = new ArrayList<>();
+        List<String> applicationRoles = new ArrayList<>();
+
+        constraintTwoRoles.add(SecurityConstraint.ROLE_ALL_AUTHENTICATED_USERS);
+        applicationRoles.add(ROLE1);
+
+        doRoleTest(null, null, constraintTwoRoles,
+                applicationRoles, true);
+    }
+
+
+    @Test
+    public void testCombineConstraints15() throws IOException {
+        // Allowed roles should be the union of the roles in the constraints
+        // Constraint with empty auth section prevents all access
+        // User has matching constraint role
+        List<String> userRoles = new ArrayList<>();
+        List<String> constraintOneRoles = new ArrayList<>();
+        List<String> constraintTwoRoles = new ArrayList<>();
+        List<String> applicationRoles = new ArrayList<>();
+
+        userRoles.add(ROLE1);
+        constraintTwoRoles.add(ROLE1);
+        applicationRoles.add(ROLE1);
+
+        doRoleTest(userRoles, constraintOneRoles, constraintTwoRoles,
+                applicationRoles, false);
+    }
+
+
+    @Test
+    public void testCombineConstraints16() throws IOException {
+        // Allowed roles should be the union of the roles in the constraints
+        // Constraint with empty auth section prevents all access
+        // User has matching role
+        List<String> userRoles = new ArrayList<>();
+        List<String> constraintOneRoles = new ArrayList<>();
+        List<String> constraintTwoRoles = new ArrayList<>();
+        List<String> applicationRoles = new ArrayList<>();
+
+        userRoles.add(ROLE1);
+        constraintTwoRoles.add(SecurityConstraint.ROLE_ALL_ROLES);
+        applicationRoles.add(ROLE1);
+
+        doRoleTest(userRoles, constraintOneRoles, constraintTwoRoles,
+                applicationRoles, false);
+    }
+
+
+    @Test
+    public void testCombineConstraints17() throws IOException {
+        // Allowed roles should be the union of the roles in the constraints
+        // Constraint with empty auth section prevents all access
+        // User matches all authenticated users
+        List<String> userRoles = new ArrayList<>();
+        List<String> constraintOneRoles = new ArrayList<>();
+        List<String> constraintTwoRoles = new ArrayList<>();
+        List<String> applicationRoles = new ArrayList<>();
+
+        userRoles.add(ROLE1);
+        constraintTwoRoles.add(SecurityConstraint.ROLE_ALL_AUTHENTICATED_USERS);
+        applicationRoles.add(ROLE1);
+
+        doRoleTest(userRoles, constraintOneRoles, constraintTwoRoles,
+                applicationRoles, false);
     }
 
 
     /**
-     *
      * @param userRoles         <code>null</code> tests unauthenticated access
      *                          otherwise access is tested with an authenticated
      *                          user with the listed roles
      * @param constraintRoles   <code>null</code> is equivalent to no auth
      *                          constraint whereas an empty list is equivalent
      *                          to an auth constraint that defines no roles.
-     * @param applicationRoles
-     * @param expected
-     * @throws IOException
      */
     private void doRoleTest(List<String> userRoles,
             List<String> constraintRoles, List<String> applicationRoles,
             boolean expected) throws IOException {
 
+        List<String> constraintTwoRoles = new ArrayList<>();
+        constraintTwoRoles.add(ROLE99);
+        doRoleTest(userRoles, constraintRoles, constraintTwoRoles,
+                applicationRoles, expected);
+    }
+
+
+    private void doRoleTest(List<String> userRoles,
+            List<String> constraintOneRoles, List<String> constraintTwoRoles,
+            List<String> applicationRoles, boolean expected)
+            throws IOException {
+
         TesterMapRealm mapRealm = new TesterMapRealm();
 
         // Configure the security constraints for the resource
-        SecurityConstraint constraint = new SecurityConstraint();
-        if (constraintRoles != null) {
-            constraint.setAuthConstraint(true);
-            for (String constraintRole : constraintRoles) {
-                constraint.addAuthRole(constraintRole);
+        SecurityConstraint constraintOne = new SecurityConstraint();
+        if (constraintOneRoles != null) {
+            constraintOne.setAuthConstraint(true);
+            for (String constraintRole : constraintOneRoles) {
+                constraintOne.addAuthRole(constraintRole);
+                if (applicationRoles.contains(
+                        SecurityConstraint.ROLE_ALL_AUTHENTICATED_USERS)) {
+                    constraintOne.treatAllAuthenticatedUsersAsApplicationRole();
+                }
+            }
+        }
+        SecurityConstraint constraintTwo = new SecurityConstraint();
+        if (constraintTwoRoles != null) {
+            constraintTwo.setAuthConstraint(true);
+            for (String constraintRole : constraintTwoRoles) {
+                constraintTwo.addAuthRole(constraintRole);
                 if (applicationRoles.contains(
                         SecurityConstraint.ROLE_ALL_AUTHENTICATED_USERS)) {
-                    constraint.treatAllAuthenticatedUsersAsApplicationRole();
+                    constraintTwo.treatAllAuthenticatedUsersAsApplicationRole();
                 }
             }
         }
-        SecurityCollection collection = new SecurityCollection();
-        collection.addPattern("/*");
         SecurityConstraint[] constraints =
-                new SecurityConstraint[] {constraint};
+                new SecurityConstraint[] { constraintOne, constraintTwo };
 
         // Set up the mock request and response
         Request request = new Request();

commit 0c0315befa173952427f6147bc701ef9271e82fc
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Fri Nov 16 19:35:42 2012 +0000

    Fix some security exceptions when running with a security manager
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1410545 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index d7fc114..c7c6482 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -43,6 +43,7 @@ public final class SecurityClassLoad {
         loadRealmPackage(loader);
         loadSessionPackage(loader);
         loadUtilPackage(loader);
+        loadValvesPackage(loader);
         loadJavaxPackage(loader);
         loadConnectorPackage(loader);
         loadTomcatPackage(loader);
@@ -54,6 +55,9 @@ public final class SecurityClassLoad {
         final String basePackage = "org.apache.catalina.core.";
         loader.loadClass
             (basePackage +
+             "AccessLogAdapter");
+        loader.loadClass
+            (basePackage +
              "ApplicationContextFacade$1");
         loader.loadClass
             (basePackage +
@@ -72,6 +76,12 @@ public final class SecurityClassLoad {
             "AsyncContextImpl$1");
         loader.loadClass
             (basePackage +
+            "AsyncContextImpl$PrivilegedGetTccl");
+        loader.loadClass
+            (basePackage +
+            "AsyncContextImpl$PrivilegedSetTccl");
+        loader.loadClass
+            (basePackage +
             "AsyncListenerWrapper");
         loader.loadClass
             (basePackage +
@@ -135,6 +145,13 @@ public final class SecurityClassLoad {
     }
 
 
+    private static final void loadValvesPackage(ClassLoader loader)
+            throws Exception {
+            final String basePackage = "org.apache.catalina.valves.";
+            loader.loadClass(basePackage + "AccessLogValve$3");
+        }
+
+
     private static final void loadCoyotePackage(ClassLoader loader)
             throws Exception {
         final String basePackage = "org.apache.coyote.";

commit 7d5a5411cf7c2a3bceb03adde0b40e715a9fcf02
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Fri Nov 16 16:56:47 2012 +0000

    Make sure onComplete() works when running with a security manager
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1410466 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/core/AsyncContextImpl.java b/java/org/apache/catalina/core/AsyncContextImpl.java
index 818e135..69ea65b 100644
--- a/java/org/apache/catalina/core/AsyncContextImpl.java
+++ b/java/org/apache/catalina/core/AsyncContextImpl.java
@@ -97,11 +97,22 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
         List<AsyncListenerWrapper> listenersCopy = new ArrayList<>();
         listenersCopy.addAll(listeners);
 
-        ClassLoader oldCL = Thread.currentThread().getContextClassLoader();
-        ClassLoader newCL = request.getContext().getLoader().getClassLoader();
+        ClassLoader oldCL;
+        if (Globals.IS_SECURITY_ENABLED) {
+            PrivilegedAction<ClassLoader> pa = new PrivilegedGetTccl();
+            oldCL = AccessController.doPrivileged(pa);
+        } else {
+            oldCL = Thread.currentThread().getContextClassLoader();
+        }
+        ClassLoader newCL = context.getLoader().getClassLoader();
 
         try {
-            Thread.currentThread().setContextClassLoader(newCL);
+            if (Globals.IS_SECURITY_ENABLED) {
+                PrivilegedAction<Void> pa = new PrivilegedSetTccl(newCL);
+                AccessController.doPrivileged(pa);
+            } else {
+                Thread.currentThread().setContextClassLoader(newCL);
+            }
             for (AsyncListenerWrapper listener : listenersCopy) {
                 try {
                     listener.fireOnComplete(event);
@@ -111,7 +122,12 @@ public class AsyncContextImpl implements AsyncContext, AsyncContextCallback {
                 }
             }
         } finally {
-            Thread.currentThread().setContextClassLoader(oldCL);
+            if (Globals.IS_SECURITY_ENABLED) {
+                PrivilegedAction<Void> pa = new PrivilegedSetTccl(oldCL);
+                AccessController.doPrivileged(pa);
+            } else {
+                Thread.currentThread().setContextClassLoader(oldCL);
+            }
         }
     }
 

commit 95d7a0fb011c606b6278954abb296d0c61af682e
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Thu Aug 30 22:55:20 2012 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=53801
    Overlapping URL patterns were sometimes merged incorrectly in security constraints leading to incorrect 401 responses. Note: it was possible for access to be denied when it should have been granted but it was not possible for access to be granted when it should have been denied.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1379206 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/realm/RealmBase.java b/java/org/apache/catalina/realm/RealmBase.java
index 22fe2cd..d4b5995 100644
--- a/java/org/apache/catalina/realm/RealmBase.java
+++ b/java/org/apache/catalina/realm/RealmBase.java
@@ -629,14 +629,15 @@ public abstract class RealmBase extends LifecycleMBeanBase implements Realm {
                     }
                 }
                 if(matched) {
-                    found = true;
                     if(length > longest) {
+                        found = false;
                         if(results != null) {
                             results.clear();
                         }
                         longest = length;
                     }
                     if(collection[j].findMethod(method)) {
+                        found = true;
                         if(results == null) {
                             results = new ArrayList<>();
                         }
@@ -760,7 +761,7 @@ public abstract class RealmBase extends LifecycleMBeanBase implements Realm {
      */
     private SecurityConstraint [] resultsToArray(
             ArrayList<SecurityConstraint> results) {
-        if(results == null) {
+        if(results == null || results.size() == 0) {
             return null;
         }
         SecurityConstraint [] array = new SecurityConstraint[results.size()];

commit d0997627dee04638468c0802c8186b9f4e6fe00e
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Sun Jul 15 19:47:20 2012 +0000

    Code clean-up for o.a.catalina.security
     - Add final prompted by UCDetector
     - Java 7 use of <>
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1361776 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityConfig.java b/java/org/apache/catalina/security/SecurityConfig.java
index 5b4cd04..b7b63af 100644
--- a/java/org/apache/catalina/security/SecurityConfig.java
+++ b/java/org/apache/catalina/security/SecurityConfig.java
@@ -49,26 +49,31 @@ public final class SecurityConfig{
     /**
      * List of protected package from conf/catalina.properties
      */
-    private String packageDefinition;
+    private final String packageDefinition;
 
 
     /**
      * List of protected package from conf/catalina.properties
      */
-    private String packageAccess;
+    private final String packageAccess;
 
 
     /**
      * Create a single instance of this class.
      */
-    private SecurityConfig(){
+    private SecurityConfig() {
+        String definition = null;
+        String access = null;
         try{
-            packageDefinition = CatalinaProperties.getProperty("package.definition");
-            packageAccess = CatalinaProperties.getProperty("package.access");
+            definition = CatalinaProperties.getProperty("package.definition");
+            access = CatalinaProperties.getProperty("package.access");
         } catch (java.lang.Exception ex){
             if (log.isDebugEnabled()){
                 log.debug("Unable to load properties using CatalinaProperties", ex);
             }
+        } finally {
+            packageDefinition = definition;
+            packageAccess = access;
         }
     }
 
diff --git a/java/org/apache/catalina/security/SecurityListener.java b/java/org/apache/catalina/security/SecurityListener.java
index 6a51ea5..d736b9a 100644
--- a/java/org/apache/catalina/security/SecurityListener.java
+++ b/java/org/apache/catalina/security/SecurityListener.java
@@ -42,7 +42,7 @@ public class SecurityListener implements LifecycleListener {
     /**
      * The list of operating system users not permitted to run Tomcat.
      */
-    private Set<String> checkedOsUsers = new HashSet<String>();
+    private final Set<String> checkedOsUsers = new HashSet<>();
 
     /**
      * The minimum umask that must be configured for the operating system user
diff --git a/java/org/apache/catalina/security/SecurityUtil.java b/java/org/apache/catalina/security/SecurityUtil.java
index bd2e87d..3e64a20 100644
--- a/java/org/apache/catalina/security/SecurityUtil.java
+++ b/java/org/apache/catalina/security/SecurityUtil.java
@@ -69,12 +69,12 @@ public final class SecurityUtil{
      * Cache every object for which we are creating method on it.
      */
     private static final Map<Object,Method[]> objectCache =
-        new ConcurrentHashMap<Object,Method[]>();
+            new ConcurrentHashMap<>();
 
     private static final org.apache.juli.logging.Log log=
         org.apache.juli.logging.LogFactory.getLog( SecurityUtil.class );
 
-    private static boolean packageDefinitionEnabled =
+    private static final boolean packageDefinitionEnabled =
          (System.getProperty("package.definition") == null &&
            System.getProperty("package.access")  == null) ? false : true;
 

commit 212f112701e2cab17ea54d60db34e5521b1feb41
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Wed Jun 6 18:45:50 2012 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=53368
    Make WebSocket play nicely with a security manager (kkolinko)
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1347047 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/conf/catalina.policy b/conf/catalina.policy
index b8f0ad6..f0944ac 100644
--- a/conf/catalina.policy
+++ b/conf/catalina.policy
@@ -188,6 +188,9 @@ grant {
 
     // Applications using Comet need to be able to access this package
     permission java.lang.RuntimePermission "accessClassInPackage.org.apache.catalina.comet";
+
+    // Applications using WebSocket need to be able to access this package
+    permission java.lang.RuntimePermission "accessClassInPackage.org.apache.catalina.websocket";
 };
 
 

commit 0a1123af7087019ad62de469ccfd00d198c4e892
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Wed Jun 6 18:29:53 2012 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=53366
    New http header parser needs to be pre-loaded when running under a security manager
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1347034 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index fbcec4b..14fd381 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -238,16 +238,36 @@ public final class SecurityClassLoad {
     private static final void loadTomcatPackage(ClassLoader loader)
         throws Exception {
         final String basePackage = "org.apache.tomcat.";
+        // buf
         loader.loadClass(basePackage + "util.buf.HexUtils");
         loader.loadClass(basePackage + "util.buf.StringCache");
         loader.loadClass(basePackage + "util.buf.StringCache$ByteEntry");
         loader.loadClass(basePackage + "util.buf.StringCache$CharEntry");
+        // http
         loader.loadClass(basePackage + "util.http.HttpMessages");
         // Make sure system property is read at this point
         Class<?> clazz = loader.loadClass(
                 basePackage + "util.http.FastHttpDateFormat");
         clazz.newInstance();
         loader.loadClass(basePackage + "util.http.HttpMessages");
+        loader.loadClass(basePackage + "util.http.parser.AstAttribute");
+        loader.loadClass(basePackage + "util.http.parser.AstMediaType");
+        loader.loadClass(basePackage + "util.http.parser.AstParameter");
+        loader.loadClass(basePackage + "util.http.parser.AstSubType");
+        loader.loadClass(basePackage + "util.http.parser.AstType");
+        loader.loadClass(basePackage + "util.http.parser.AstValue");
+        loader.loadClass(basePackage + "util.http.parser.HttpParser");
+        loader.loadClass(basePackage + "util.http.parser.HttpParserConstants");
+        loader.loadClass(basePackage + "util.http.parser.HttpParserTokenManager");
+        loader.loadClass(basePackage + "util.http.parser.HttpParserTreeConstants");
+        loader.loadClass(basePackage + "util.http.parser.JJTHttpParserState");
+        loader.loadClass(basePackage + "util.http.parser.Node");
+        loader.loadClass(basePackage + "util.http.parser.ParseException");
+        loader.loadClass(basePackage + "util.http.parser.SimpleCharStream");
+        loader.loadClass(basePackage + "util.http.parser.SimpleNode");
+        loader.loadClass(basePackage + "util.http.parser.Token");
+        loader.loadClass(basePackage + "util.http.parser.TokenMgrError");
+        // net
         loader.loadClass(basePackage + "util.net.Constants");
         loader.loadClass(basePackage +
                 "util.net.NioBlockingSelector$BlockPoller$1");

commit ad3b503517ab7fefa2d5350a5036918a7f01d85a
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Fri Jun 1 09:40:59 2012 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=53285
    Modify how the digester processes security-role-ref since link is optional and null parameters are not handled by IntrospectionUtils
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1345029 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/deploy/ServletDef.java b/java/org/apache/catalina/deploy/ServletDef.java
index 900f819..b15e196 100644
--- a/java/org/apache/catalina/deploy/ServletDef.java
+++ b/java/org/apache/catalina/deploy/ServletDef.java
@@ -215,7 +215,9 @@ public class ServletDef implements Serializable {
     /**
      * Add a security-role-ref to the set of security-role-refs associated
      * with this servlet.
+     * @deprecated
      */
+    @Deprecated
     public void addSecurityRoleRef(String roleName, String roleLink) {
         SecurityRoleRef srr = new SecurityRoleRef();
         srr.setName(roleName);
diff --git a/java/org/apache/catalina/startup/WebRuleSet.java b/java/org/apache/catalina/startup/WebRuleSet.java
index 530ac9d..b3fe0ba 100644
--- a/java/org/apache/catalina/startup/WebRuleSet.java
+++ b/java/org/apache/catalina/startup/WebRuleSet.java
@@ -386,10 +386,15 @@ public class WebRuleSet extends RuleSetBase {
         digester.addCallMethod(fullPrefix + "/servlet/run-as/role-name",
                                "setRunAs", 0);
 
-        digester.addCallMethod(fullPrefix + "/servlet/security-role-ref",
-                               "addSecurityRoleRef", 2);
-        digester.addCallParam(fullPrefix + "/servlet/security-role-ref/role-link", 1);
-        digester.addCallParam(fullPrefix + "/servlet/security-role-ref/role-name", 0);
+        digester.addObjectCreate(fullPrefix + "/servlet/security-role-ref",
+                                 "org.apache.catalina.deploy.SecurityRoleRef");
+        digester.addSetNext(fullPrefix + "/servlet/security-role-ref",
+                            "addSecurityRoleRef",
+                            "org.apache.catalina.deploy.SecurityRoleRef");
+        digester.addCallMethod(fullPrefix + "/servlet/security-role-ref/role-link",
+                               "setLink", 0);
+        digester.addCallMethod(fullPrefix + "/servlet/security-role-ref/role-name",
+                               "setName", 0);
 
         digester.addCallMethod(fullPrefix + "/servlet/servlet-class",
                               "setServletClass", 0);

commit 98e1551284e76880cf16845efb241535d0ea825b
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Wed Oct 26 15:02:01 2011 +0000

    Make configuration issues for security related valves and filters result in the failure of the valve or filter rather than just a warning message.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1189256 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/filters/CsrfPreventionFilter.java b/java/org/apache/catalina/filters/CsrfPreventionFilter.java
index b6cfcf9..f98c785 100644
--- a/java/org/apache/catalina/filters/CsrfPreventionFilter.java
+++ b/java/org/apache/catalina/filters/CsrfPreventionFilter.java
@@ -186,6 +186,13 @@ public class CsrfPreventionFilter extends FilterBase {
         chain.doFilter(request, wResponse);
     }
 
+
+    @Override
+    protected boolean isConfigProblemFatal() {
+        return true;
+    }
+
+
     /**
      * Generate a once time token (nonce) for authenticating subsequent
      * requests. This will also add the token to the session. The nonce
diff --git a/java/org/apache/catalina/filters/FilterBase.java b/java/org/apache/catalina/filters/FilterBase.java
index d6b2a61..bb65724 100644
--- a/java/org/apache/catalina/filters/FilterBase.java
+++ b/java/org/apache/catalina/filters/FilterBase.java
@@ -47,8 +47,13 @@ public abstract class FilterBase implements Filter {
             String paramName = paramNames.nextElement();
             if (!IntrospectionUtils.setProperty(this, paramName,
                     filterConfig.getInitParameter(paramName))) {
-                getLogger().warn(sm.getString("filterbase.noSuchProperty",
-                        paramName, this.getClass().getName()));
+                String msg = sm.getString("filterbase.noSuchProperty",
+                        paramName, this.getClass().getName());
+                if (isConfigProblemFatal()) {
+                    throw new ServletException(msg);
+                } else {
+                    getLogger().warn(msg);
+                }
             }
         }
     }
@@ -58,4 +63,15 @@ public abstract class FilterBase implements Filter {
         // NOOP
     }
 
+    /**
+     * Determines if an exception when calling a setter or an unknown
+     * configuration attribute triggers the failure of the this filter which in
+     * turn will prevent the web application from starting.
+     *
+     * @return <code>true</true> if a problem should trigger the failure of this
+     *         filter, else <code>false</code>
+     */
+    protected boolean isConfigProblemFatal() {
+        return false;
+    }
 }
diff --git a/java/org/apache/catalina/filters/RequestFilter.java b/java/org/apache/catalina/filters/RequestFilter.java
index 25a7d77..83afa76 100644
--- a/java/org/apache/catalina/filters/RequestFilter.java
+++ b/java/org/apache/catalina/filters/RequestFilter.java
@@ -158,6 +158,12 @@ public abstract class RequestFilter extends FilterBase implements CometFilter {
     // ------------------------------------------------------ Protected Methods
 
 
+    @Override
+    protected boolean isConfigProblemFatal() {
+        return true;
+    }
+
+
     /**
      * Perform the filtering that has been configured for this Filter, matching
      * against the specified request property.
@@ -185,6 +191,7 @@ public abstract class RequestFilter extends FilterBase implements CometFilter {
         }
     }
 
+
     /**
      * Perform the filtering that has been configured for this Filter, matching
      * against the specified request property.
diff --git a/java/org/apache/catalina/valves/LocalStrings.properties b/java/org/apache/catalina/valves/LocalStrings.properties
index 960a7f1..60e89a1 100644
--- a/java/org/apache/catalina/valves/LocalStrings.properties
+++ b/java/org/apache/catalina/valves/LocalStrings.properties
@@ -40,6 +40,8 @@ errorReportValve.rootCauseInLogs=The full stack trace of the root cause is avail
 # Remote IP valve
 remoteIpValve.invalidPortHeader=Invalid value [{0}] found for port in HTTP header [{1}]
 
+requestFilterValve.configInvalid=One or more invalid configuration settings were provided for the Remote[Host|Ip]Valve which prevented the Valve and its parent containers from starting
+
 sslValve.certError=Failed to process certificate string [{0}] to create a java.security.cert.X509Certificate object
 sslValve.invalidProvider=The SSL provider specified on the connector associated with this request of [{0}] is invalid. The certificate data could not be processed.
 
diff --git a/java/org/apache/catalina/valves/RequestFilterValve.java b/java/org/apache/catalina/valves/RequestFilterValve.java
index 0338409..8172202 100644
--- a/java/org/apache/catalina/valves/RequestFilterValve.java
+++ b/java/org/apache/catalina/valves/RequestFilterValve.java
@@ -23,6 +23,7 @@ import java.util.regex.Pattern;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletResponse;
 
+import org.apache.catalina.LifecycleException;
 import org.apache.catalina.connector.Request;
 import org.apache.catalina.connector.Response;
 
@@ -71,12 +72,14 @@ public abstract class RequestFilterValve extends ValveBase {
      * The regular expression used to test for allowed requests.
      */
     protected volatile Pattern allow = null;
+    protected volatile boolean allowValid = true;
 
 
     /**
      * The regular expression used to test for denied requests.
      */
     protected volatile Pattern deny = null;
+    protected volatile boolean denyValid = true;
 
 
     // ------------------------------------------------------------- Properties
@@ -105,8 +108,15 @@ public abstract class RequestFilterValve extends ValveBase {
     public void setAllow(String allow) {
         if (allow == null || allow.length() == 0) {
             this.allow = null;
+            allowValid = true;
         } else {
-            this.allow = Pattern.compile(allow);
+            boolean success = false;
+            try {
+                this.allow = Pattern.compile(allow);
+                success = true;
+            } finally {
+                allowValid = success;
+            }
         }
     }
 
@@ -134,8 +144,15 @@ public abstract class RequestFilterValve extends ValveBase {
     public void setDeny(String deny) {
         if (deny == null || deny.length() == 0) {
             this.deny = null;
+            denyValid = true;
         } else {
-            this.deny = Pattern.compile(deny);
+            boolean success = false;
+            try {
+                this.deny = Pattern.compile(deny);
+                success = true;
+            } finally {
+                denyValid = success;
+            }
         }
     }
 
@@ -162,6 +179,16 @@ public abstract class RequestFilterValve extends ValveBase {
     // ------------------------------------------------------ Protected Methods
 
 
+    @Override
+    protected void initInternal() throws LifecycleException {
+        super.initInternal();
+        if (!allowValid || !denyValid) {
+            throw new LifecycleException(
+                    sm.getString("requestFilterValve.configInvalid"));
+        }
+    }
+
+
     /**
      * Perform the filtering that has been configured for this Valve, matching
      * against the specified request property.

commit 8226e51e96b2d8aaed8b86490b6cafcc535a9ab0
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Thu Sep 22 11:21:08 2011 +0000

    Fix running under a security manager
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1174061 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index 9723723..be52a48 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -87,10 +87,10 @@ public final class SecurityClassLoad {
              "DefaultInstanceManager$3");
         loader.loadClass
             (basePackage +
-             "DefaultInstanceManager$4");
+             "DefaultInstanceManager$AnnotationCacheEntry");
         loader.loadClass
             (basePackage +
-             "DefaultInstanceManager$5");
+             "DefaultInstanceManager$AnnotationCacheEntryType");
         loader.loadClass
             (basePackage +
              "ApplicationHttpRequest$AttributeNamesEnumerator");

commit 2e69497fa7b1444632c6dadb64a4a82e18478ee6
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Wed Jul 13 13:28:24 2011 +0000

    When running under a security manager and using sendfile, validate sendfile attributes to prevent sendfile being used to bypass the security manager.
    Part of the fix for CVE-2011-2526
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1146005 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/connector/LocalStrings.properties b/java/org/apache/catalina/connector/LocalStrings.properties
index a0d38fa..e012080 100644
--- a/java/org/apache/catalina/connector/LocalStrings.properties
+++ b/java/org/apache/catalina/connector/LocalStrings.properties
@@ -66,6 +66,7 @@ coyoteRequest.noLoginConfig=No authentication mechanism has been configured for
 coyoteRequest.authenticate.ise=Cannot call authenticate() after the reponse has been committed
 coyoteRequest.uploadLocationInvalid=The temporary upload location [{0}] is not valid
 coyoteRequest.sessionEndAccessFail=Exception triggered ending access to session while recycling request
+coyoteRequest.sendfileNotCanonical=Unable to determine canonical name of file [{0}] specified for use with sendfile
 
 requestFacade.nullRequest=The request object has been recycled and is no longer associated with this facade
 
diff --git a/java/org/apache/catalina/connector/Request.java b/java/org/apache/catalina/connector/Request.java
index 2d26be0..87ce690 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -1525,6 +1525,26 @@ public class Request
             return;
         }
 
+        // Do the security check before any updates are made
+        if (Globals.IS_SECURITY_ENABLED &&
+                name.equals("org.apache.tomcat.sendfile.filename")) {
+            // Use the canonical file name to avoid any possible symlink and
+            // relative path issues
+            String canonicalPath;
+            try {
+                canonicalPath = new File(value.toString()).getCanonicalPath();
+            } catch (IOException e) {
+                throw new SecurityException(sm.getString(
+                        "coyoteRequest.sendfileNotCanonical", value), e);
+            }
+            // Sendfile is performed in Tomcat's security context so need to
+            // check if the web app is permitted to access the file while still
+            // in the web app's security context
+            System.getSecurityManager().checkRead(canonicalPath);
+            // Update the value so the canonical path is used
+            value = canonicalPath;
+        }
+
         oldValue = attributes.put(name, value);
         if (oldValue != null) {
             replaced = true;

commit 443ab2b2963b574723df87cf5fd89016d28806a0
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Thu Jul 7 20:53:51 2011 +0000

    Use SecurityClassLoad to pre-load HexUtils to prevent a security exception
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1144031 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index bc33271..9723723 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -239,6 +239,7 @@ public final class SecurityClassLoad {
     private static final void loadTomcatPackage(ClassLoader loader)
         throws Exception {
         final String basePackage = "org.apache.tomcat.";
+        loader.loadClass(basePackage + "util.buf.HexUtils");
         loader.loadClass(basePackage + "util.buf.StringCache");
         loader.loadClass(basePackage + "util.buf.StringCache$ByteEntry");
         loader.loadClass(basePackage + "util.buf.StringCache$CharEntry");
diff --git a/java/org/apache/coyote/ajp/AjpAprProcessor.java b/java/org/apache/coyote/ajp/AjpAprProcessor.java
index 6cf6ac5..196f22d 100644
--- a/java/org/apache/coyote/ajp/AjpAprProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpAprProcessor.java
@@ -14,7 +14,6 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.coyote.ajp;
 
 import java.io.IOException;
@@ -31,7 +30,6 @@ import org.apache.tomcat.jni.Socket;
 import org.apache.tomcat.jni.Status;
 import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.buf.ByteChunk;
-import org.apache.tomcat.util.buf.HexUtils;
 import org.apache.tomcat.util.http.HttpMessages;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.AprEndpoint;
@@ -77,12 +75,8 @@ public class AjpAprProcessor extends AbstractAjpProcessor {
         inputBuffer.limit(0);
         outputBuffer = ByteBuffer.allocateDirect(packetSize * 2);
 
-        // Cause loading of HexUtils
-        HexUtils.load();
-
         // Cause loading of HttpMessages
         HttpMessages.getMessage(200);
-
     }
 
 
diff --git a/java/org/apache/coyote/ajp/AjpNioProcessor.java b/java/org/apache/coyote/ajp/AjpNioProcessor.java
index 555945f..470ffba 100644
--- a/java/org/apache/coyote/ajp/AjpNioProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpNioProcessor.java
@@ -14,7 +14,6 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.coyote.ajp;
 
 import java.io.EOFException;
@@ -31,7 +30,6 @@ import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.buf.ByteChunk;
-import org.apache.tomcat.util.buf.HexUtils;
 import org.apache.tomcat.util.http.HttpMessages;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.NioChannel;
@@ -68,12 +66,8 @@ public class AjpNioProcessor extends AbstractAjpProcessor {
 
         pool = endpoint.getSelectorPool();
 
-        // Cause loading of HexUtils
-        HexUtils.load();
-
         // Cause loading of HttpMessages
         HttpMessages.getMessage(200);
-
     }
 
 
diff --git a/java/org/apache/coyote/ajp/AjpProcessor.java b/java/org/apache/coyote/ajp/AjpProcessor.java
index fa1cf37..290e973 100644
--- a/java/org/apache/coyote/ajp/AjpProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpProcessor.java
@@ -14,7 +14,6 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.coyote.ajp;
 
 import java.io.IOException;
@@ -31,7 +30,6 @@ import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.ExceptionUtils;
 import org.apache.tomcat.util.buf.ByteChunk;
-import org.apache.tomcat.util.buf.HexUtils;
 import org.apache.tomcat.util.http.HttpMessages;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.JIoEndpoint;
@@ -71,12 +69,8 @@ public class AjpProcessor extends AbstractAjpProcessor {
 
         response.setOutputBuffer(new SocketOutputBuffer());
 
-        // Cause loading of HexUtils
-        HexUtils.load();
-
         // Cause loading of HttpMessages
         HttpMessages.getMessage(200);
-
     }
 
 
diff --git a/java/org/apache/coyote/http11/Http11AprProcessor.java b/java/org/apache/coyote/http11/Http11AprProcessor.java
index 56f9ef3..257977c 100644
--- a/java/org/apache/coyote/http11/Http11AprProcessor.java
+++ b/java/org/apache/coyote/http11/Http11AprProcessor.java
@@ -14,7 +14,6 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.coyote.http11;
 
 import java.io.ByteArrayInputStream;
@@ -34,7 +33,6 @@ import org.apache.tomcat.jni.SSLSocket;
 import org.apache.tomcat.jni.Sockaddr;
 import org.apache.tomcat.jni.Socket;
 import org.apache.tomcat.util.ExceptionUtils;
-import org.apache.tomcat.util.buf.HexUtils;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.AprEndpoint;
 import org.apache.tomcat.util.net.SSLSupport;
@@ -71,9 +69,6 @@ public class Http11AprProcessor extends AbstractHttp11Processor {
         response.setOutputBuffer(outputBuffer);
 
         initializeFilters(maxTrailerSize);
-
-        // Cause loading of HexUtils
-        HexUtils.load();
     }
 
 
diff --git a/java/org/apache/coyote/http11/Http11NioProcessor.java b/java/org/apache/coyote/http11/Http11NioProcessor.java
index ecb0415..b35488f 100644
--- a/java/org/apache/coyote/http11/Http11NioProcessor.java
+++ b/java/org/apache/coyote/http11/Http11NioProcessor.java
@@ -14,8 +14,8 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.coyote.http11;
+
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.InetAddress;
@@ -29,7 +29,6 @@ import org.apache.coyote.http11.filters.BufferedInputFilter;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.ExceptionUtils;
-import org.apache.tomcat.util.buf.HexUtils;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.NioChannel;
 import org.apache.tomcat.util.net.NioEndpoint;
@@ -75,9 +74,6 @@ public class Http11NioProcessor extends AbstractHttp11Processor {
         response.setOutputBuffer(outputBuffer);
 
         initializeFilters(maxTrailerSize);
-
-        // Cause loading of HexUtils
-        HexUtils.load();
     }
 
 
diff --git a/java/org/apache/coyote/http11/Http11Processor.java b/java/org/apache/coyote/http11/Http11Processor.java
index e332e71..4e25608 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -14,7 +14,6 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
 package org.apache.coyote.http11;
 
 import java.io.EOFException;
@@ -29,7 +28,6 @@ import org.apache.coyote.http11.filters.BufferedInputFilter;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.ExceptionUtils;
-import org.apache.tomcat.util.buf.HexUtils;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.JIoEndpoint;
 import org.apache.tomcat.util.net.SSLSupport;
@@ -66,10 +64,6 @@ public class Http11Processor extends AbstractHttp11Processor {
         response.setOutputBuffer(outputBuffer);
 
         initializeFilters(maxTrailerSize);
-
-        // Cause loading of HexUtils
-        HexUtils.load();
-
     }
 
 

commit 7cc808304f4f6b352656b2d4eeb0441da4f46ec7
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Wed Jun 8 22:20:22 2011 +0000

    Refactoring triggered security exception when running TCKs
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1133586 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index c8bb6ad..bc33271 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -140,6 +140,7 @@ public final class SecurityClassLoad {
             throws Exception {
         final String basePackage = "org.apache.coyote.";
         loader.loadClass(basePackage + "http11.AbstractOutputBuffer$1");
+        loader.loadClass(basePackage + "http11.Constants");
         // Make sure system property is read at this point
         Class<?> clazz = loader.loadClass(basePackage + "Constants");
         clazz.newInstance();

commit 05594914c87d13ac3f217b1aafc7f2eafacc3aee
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Thu May 5 12:38:44 2011 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=50950
    Correct possible NotSerializableException for an authenticated session when running with a security manager.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1099772 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/ha/session/DeltaSession.java b/java/org/apache/catalina/ha/session/DeltaSession.java
index 34cc7df..8d6c609 100644
--- a/java/org/apache/catalina/ha/session/DeltaSession.java
+++ b/java/org/apache/catalina/ha/session/DeltaSession.java
@@ -625,7 +625,9 @@ public class DeltaSession extends StandardSession implements Externalizable,Clus
         try {
             lock();
             super.setAttribute(name,value, notify);
-            if (addDeltaRequest && (deltaRequest != null)) deltaRequest.setAttribute(name, value);
+            if (addDeltaRequest && deltaRequest != null && !exclude(name)) {
+                deltaRequest.setAttribute(name, value);
+            }
         } finally {
             unlock();
         }
@@ -804,7 +806,9 @@ public class DeltaSession extends StandardSession implements Externalizable,Clus
             if (value == null) return;
 
             super.removeAttributeInternal(name,notify);
-            if (addDeltaRequest && (deltaRequest != null)) deltaRequest.removeAttribute(name);
+            if (addDeltaRequest && deltaRequest != null && !exclude(name)) {
+                deltaRequest.removeAttribute(name);
+            }
 
         }finally {
             unlock();
diff --git a/webapps/docs/changelog.xml b/webapps/docs/changelog.xml
index 762b5a3..506f1d6 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -187,6 +187,14 @@
       </add>
     </changelog>
   </subsection>
+  <subsection name="Cluster">
+    <changelog>
+      <fix>
+        <bug>50950</bug>: Correct possible NotSerializableException for an
+        authenticated session when running with a security manager. (markt)
+      </fix>
+    </changelog>
+  </subsection>
   <subsection name="Web applications">
     <changelog>
       <update>

commit 65b144773b81f6cdac65bb1091a4436c81262677
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Wed Mar 9 15:00:07 2011 +0000

    Fix TCK test failure under a security Manager
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1079822 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index 6bc480d..7b6ced6 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -40,6 +40,7 @@ public final class SecurityClassLoad {
         loadCorePackage(loader);
         loadCoyotePackage(loader);
         loadLoaderPackage(loader);
+        loadRealmPackage(loader);
         loadSessionPackage(loader);
         loadUtilPackage(loader);
         loadJavaxPackage(loader);
@@ -105,6 +106,14 @@ public final class SecurityClassLoad {
     }
     
     
+    private static final void loadRealmPackage(ClassLoader loader)
+            throws Exception {
+        final String basePackage = "org.apache.catalina.realm.";
+        loader.loadClass
+            (basePackage + "LockOutRealm$LockRecord");
+    }
+
+
     private static final void loadSessionPackage(ClassLoader loader)
         throws Exception {
         final String basePackage = "org.apache.catalina.session.";

commit 38f47110847ef6d3ec672ecbce313f45f5ba07f4
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Wed Mar 9 11:38:38 2011 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=50854
    Add additional permissions required by the Manager application when running under a security Manager and support a shared Manager installation when $CATALINA_HOME != CATALINA_BASE.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1079755 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/conf/catalina.policy b/conf/catalina.policy
index 200936a..38d5de9 100644
--- a/conf/catalina.policy
+++ b/conf/catalina.policy
@@ -187,11 +187,24 @@ grant {
 
 
 // The Manager application needs access to the following packages to support the
-// session display functionality
+// session display functionality. These settings support the following
+// configurations:
+// - default CATALINA_HOME == CATALINA_BASE
+// - CATALINA_HOME != CATALINA_BASE, per instance Manager in CATALINA_BASE
+// - CATALINA_HOME != CATALINA_BASE, shared Manager in CATALINA_HOME
 grant codeBase "file:${catalina.base}/webapps/manager/-" {
     permission java.lang.RuntimePermission "accessClassInPackage.org.apache.catalina";
+    permission java.lang.RuntimePermission "accessClassInPackage.org.apache.catalina.ha.session";
     permission java.lang.RuntimePermission "accessClassInPackage.org.apache.catalina.manager";
     permission java.lang.RuntimePermission "accessClassInPackage.org.apache.catalina.manager.util";
+    permission java.lang.RuntimePermission "accessClassInPackage.org.apache.catalina.util";
+};
+grant codeBase "file:${catalina.home}/webapps/manager/-" {
+    permission java.lang.RuntimePermission "accessClassInPackage.org.apache.catalina";
+    permission java.lang.RuntimePermission "accessClassInPackage.org.apache.catalina.ha.session";
+    permission java.lang.RuntimePermission "accessClassInPackage.org.apache.catalina.manager";
+    permission java.lang.RuntimePermission "accessClassInPackage.org.apache.catalina.manager.util";
+    permission java.lang.RuntimePermission "accessClassInPackage.org.apache.catalina.util";
 };
 
 // You can assign additional permissions to particular web applications by
diff --git a/webapps/docs/changelog.xml b/webapps/docs/changelog.xml
index e496673..fdb5197 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -30,7 +30,7 @@
     <author email="kkolinko@apache.org">Konstantin Kolinko</author>
     <author email="pero@apache.org">Peter Rossbach</author>
     <author email="kfujino@apache.org">Keiichi Fujino</author>
-    <author email="timw@apache.org">Tim Whittington</author>    
+    <author email="timw@apache.org">Tim Whittington</author>   
     <author email="mturk@apache.org">Mladen Turk</author>
     <author email="schultz@apache.org">Christopher Schultz</author>
     <author email="slaurent@apache.org">Sylvain Laurent</author>
@@ -69,6 +69,11 @@
         to make request data swallowing configurable for requests
         that are too large. (rjung)
       </add>
+      <fix>
+        <bug>50854</bug>: Add additional permissions required by the Manager
+        application when running under a security Manager and support a shared
+        Manager installation when $CATALINA_HOME != CATALINA_BASE. (markt)
+      </fix>
     </changelog>
   </subsection>
   <subsection name="Coyote">

commit 0ff4905158b77787a7f3aca55c9dec93456665dc
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Wed Mar 9 11:16:48 2011 +0000

    CVE-2011-1088
    Complete the fix for this issue. The optimisation not to configure an authenticator of there were no security constraints meant that in that case @ServletSecurity annotations had no effect. The unit tests did not pick this up since they added an authenticator directly.
    Add an explicit unit test for this scenario.
    
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1079752 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/startup/ContextConfig.java b/java/org/apache/catalina/startup/ContextConfig.java
index ee56360..04c7022 100644
--- a/java/org/apache/catalina/startup/ContextConfig.java
+++ b/java/org/apache/catalina/startup/ContextConfig.java
@@ -366,10 +366,7 @@ public class ContextConfig
      */
     protected synchronized void authenticatorConfig() {
 
-        // Does this Context require an Authenticator?
-        SecurityConstraint constraints[] = context.findConstraints();
-        if ((constraints == null) || (constraints.length == 0))
-            return;
+        // Always need an authenticator to support @ServletSecurity annotations
         LoginConfig loginConfig = context.getLoginConfig();
         if (loginConfig == null) {
             loginConfig = DUMMY_LOGIN_CONFIG;
diff --git a/test/org/apache/catalina/core/TestStandardWrapper.java b/test/org/apache/catalina/core/TestStandardWrapper.java
index 89a09da..1fc79cf 100644
--- a/test/org/apache/catalina/core/TestStandardWrapper.java
+++ b/test/org/apache/catalina/core/TestStandardWrapper.java
@@ -125,6 +125,24 @@ public class TestStandardWrapper extends TomcatBaseTest {
         doTestSecurityAnnotationsAddServlet(true);
     }
     
+    public void testSecurityAnnotationsNoWebXmlConstraints() throws Exception {
+        // Setup Tomcat instance
+        Tomcat tomcat = getTomcatInstance();
+        
+        File appDir = new File("test/webapp-3.0-servletsecurity");
+        tomcat.addWebapp(null, "", appDir.getAbsolutePath());
+        
+        tomcat.start();
+        
+        ByteChunk bc = new ByteChunk();
+        int rc;
+        rc = getUrl("http://localhost:" + getPort() + "/",
+                bc, null, null);
+        
+        assertNull(bc.toString());
+        assertEquals(403, rc);
+    }
+
     private void doTestSecurityAnnotationsAddServlet(boolean useCreateServlet)
             throws Exception {
 
diff --git a/test/webapp-3.0-servletsecurity/WEB-INF/web.xml b/test/webapp-3.0-servletsecurity/WEB-INF/web.xml
new file mode 100644
index 0000000..34a1c2c
--- /dev/null
+++ b/test/webapp-3.0-servletsecurity/WEB-INF/web.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the "License"); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<web-app xmlns="http://java.sun.com/xml/ns/javaee"
+  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
+                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
+  version="3.0">  
+
+  <!--
+    WARNING:
+    For the unit tests to work correctly, no security constraints may be
+    configured in the web.xml. A login-config section is permitted but not
+    necessary for the tests. Adding a login-config would require changing the
+    return code checked in the unit tests.
+  -->
+
+  <display-name>Tomcat Test Application</display-name>
+  <description>
+     Used as part of the Tomcat unit tests when a full web application is
+     required.
+  </description>
+  
+  <servlet>
+    <servlet-name>RoleProtected</servlet-name>
+    <servlet-class>org.apache.catalina.core.TestStandardWrapper$RoleAllowServlet</servlet-class>
+  </servlet>
+
+  <servlet-mapping>
+    <servlet-name>RoleProtected</servlet-name>
+    <url-pattern>/</url-pattern>
+  </servlet-mapping>
+
+</web-app>
\ No newline at end of file
diff --git a/webapps/docs/changelog.xml b/webapps/docs/changelog.xml
index 7741494..e496673 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -45,6 +45,10 @@
 <section name="Tomcat 7.0.11 (markt)">
   <subsection name="Catalina">
     <changelog>
+      <fix>
+        CVE-2011-1088: Completed fix. Don&apos;t ignore @ServletSecurity
+        annotations. (markt)
+      </fix>
       <add>
         <bug>25060</bug>: Close Apache Commons DBCP datasources when the
         associated JNDI naming context is stopped (e.g. for a non-global
@@ -88,6 +92,10 @@
   <subsection name="Catalina">
     <changelog>
       <fix>
+        CVE-2011-1088: Partial fix. Don&apos;t ignore @ServletSecurity
+        annotations. (markt)
+      </fix>
+      <fix>
         <bug>27988</bug>: Improve reporting of missing files. (markt)
       </fix>
       <fix>
@@ -103,10 +111,6 @@
         Improve shut down speed by not renewing threads during shut down when
         the <code>ThreadLocalLeakPreventionListener</code> is enabled. (markt)  
       </fix>
-      <fix>
-        CVE-2011-1088: Partial fix. Don&apos;t ignore @ServletSecurity
-        annotations. (markt)
-      </fix>
     </changelog>
   </subsection>
   <subsection name="Coyote">

commit 8fc86a014d4560fcc803f9533f08b0af93fc7deb
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Wed Feb 23 19:25:17 2011 +0000

    Add security listener
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1073893 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/webapps/docs/security-howto.xml b/webapps/docs/security-howto.xml
index de65985..8a879d3 100644
--- a/webapps/docs/security-howto.xml
+++ b/webapps/docs/security-howto.xml
@@ -119,6 +119,9 @@
       <p>The APR Lifecycle Listener is not stable if compiled on Solaris using
       gcc. If using the APR/native connector on Solaris, compile it with the
       Sun Studio compiler.</p>
+      
+      <p>The Security Listener should be enabled and configured as appropriate.  
+      </p>
     </subsection>
     
     <subsection name="Connectors">

commit 215b6c9501c8a35895c3c4d3acf5fd0aa5bc339a
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Fri Feb 4 11:07:18 2011 +0000

    Fix security exception when running under a SecurityManager
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1067147 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index f444b9d..6bc480d 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -131,6 +131,9 @@ public final class SecurityClassLoad {
             throws Exception {
         final String basePackage = "org.apache.coyote.";
         loader.loadClass(basePackage + "http11.AbstractOutputBuffer$1");
+        // Make sure system property is read at this point
+        Class<?> clazz = loader.loadClass(basePackage + "Constants");
+        clazz.newInstance();
     }
 
 
diff --git a/webapps/docs/changelog.xml b/webapps/docs/changelog.xml
index a11110f..418f27b 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -51,6 +51,10 @@
        <bug>50709</bug>: Make <code>ApplicationContextFacade</code> non-final to
        enable extension. (markt)
       </fix>
+      <fix>
+        When running under a security manager, user requests may fail with a
+        security exception. (markt)
+      </fix>
     </changelog>
   </subsection>
   <subsection name="Coyote">

commit cb768c0f232decbf85017b1110c05370290a73c7
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Mon Jan 17 17:31:45 2011 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=50599
    Use correct names of security roles for Manager app
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1060015 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/ant/package.html b/java/org/apache/catalina/ant/package.html
index 1aa06e1..5fa987e 100644
--- a/java/org/apache/catalina/ant/package.html
+++ b/java/org/apache/catalina/ant/package.html
@@ -46,7 +46,7 @@ sent directly to the Manager application.  They are summarized as follows:
     <td align="center">username</td>
     <td>
       The username of a Tomcat user that has been configured with the
-      <code>manager</code> role, as required to execute Manager
+      <code>manager-script</code> role, as required to execute Manager
       application commands.  This attribute is required.
     </td>
   </tr>
@@ -54,7 +54,7 @@ sent directly to the Manager application.  They are summarized as follows:
     <td align="center">password</td>
     <td>
       The password of a Tomcat user that has been configured with the
-      <code>manager</code> role, as required to execute Manager
+      <code>manager-script</code> role, as required to execute Manager
       application commands.  This attribute is required.
     </td>
   </tr>
diff --git a/webapps/docs/appdev/build.xml.txt b/webapps/docs/appdev/build.xml.txt
index 2de66e6..b3cdb5c 100644
--- a/webapps/docs/appdev/build.xml.txt
+++ b/webapps/docs/appdev/build.xml.txt
@@ -113,7 +113,7 @@
                        Defaults to "dist".
 
   manager.password     The login password of a user that is assigned the
-                       "manager" role (so that he or she can execute
+                       "manager-script" role (so that he or she can execute
                        commands via the "/manager" web application)
 
   manager.url          The URL of the "/manager" web application on the
@@ -121,7 +121,7 @@
                        applications and web services.
 
   manager.username     The login username of a user that is assigned the
-                       "manager" role (so that he or she can execute
+                       "manager-script" role (so that he or she can execute
                        commands via the "/manager" web application)
 
 -->
diff --git a/webapps/docs/appdev/processes.xml b/webapps/docs/appdev/processes.xml
index 4c4cd4e..7f2ab7f 100644
--- a/webapps/docs/appdev/processes.xml
+++ b/webapps/docs/appdev/processes.xml
@@ -63,12 +63,12 @@ once (no matter how many web applications you plan to develop).</p>
     <br/><br/></li>
 <li><em>Define one or more Tomcat users</em>.  The <em>Manager</em> web
     application runs under a security constraint that requires a user to be
-    logged in, and have the security role <code>manager</code> assigned to
-    him or her.  How such users are defined depends on which Realm you have
+    logged in, and have the security role <code>manager-script</code> assigned
+    to him or her.  How such users are defined depends on which Realm you have
     configured in Tomcat's <code>conf/server.xml</code> file -- see the
     <a href="../realm-howto.html">Realm Configuration HOW-TO</a> for more
     information.  You may define any number of users (with any username
-    and password that you like) with the <code>manager</code> role.
+    and password that you like) with the <code>manager-script</code> role.
     <br/><br/></li>
 </ul>
 
diff --git a/webapps/docs/changelog.xml b/webapps/docs/changelog.xml
index 68b57c2..a529925 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -121,6 +121,10 @@
         Correct the documentation for the recoveryCount count attribute of the
         the default cluster membership. (markt)
       </fix>
+      <fix>
+        <bug>50599</bug>: Use correct names of roles required to access the 
+        Manager application. (markt)
+      </fix>
     </changelog>
   </subsection>
   <subsection name="Other">
diff --git a/webapps/docs/funcspecs/fs-admin-apps.xml b/webapps/docs/funcspecs/fs-admin-apps.xml
index 1370f2a..93de016 100644
--- a/webapps/docs/funcspecs/fs-admin-apps.xml
+++ b/webapps/docs/funcspecs/fs-admin-apps.xml
@@ -261,10 +261,10 @@
   <p>In addition, this web application shall conform to the following
   requirements:</p>
   <ul>
-  <li>All request URIs shall be protected by a security constraint that
-      requires security role <code>manager</code> for processing.</li>
+  <li>All request URIs shall be protected by security constraints that
+      require a security role to be assigned for processing.</li>
   <li>The default user database shall <strong>not</strong> contain any
-      user that has been assigned the role <code>manager</code>.</li>
+      user that has been assigned a security role.</li>
   </ul>
 
   <h5>HTML-Based Web Application</h5>
diff --git a/webapps/docs/realm-howto.xml b/webapps/docs/realm-howto.xml
index f17590b..a25e3a7 100644
--- a/webapps/docs/realm-howto.xml
+++ b/webapps/docs/realm-howto.xml
@@ -250,15 +250,16 @@ and log on with one of the usernames and passwords described for the default
 
 <p>If you wish to use the <a href="manager-howto.html">Manager Application</a>
 to deploy and undeploy applications in a running Tomcat installation, you
-MUST add the "manager" role to at least one username in your selected Realm
-implementation.  This is because the manager web application itself uses a
-security constraint that requires role "manager" to access ANY request URI
-within that application.</p>
+MUST add the "manager-gui" role to at least one username in your selected
+Realm implementation.  This is because the manager web application itself uses a
+security constraint that requires role "manager-gui" to access ANY request URI
+within the HTML interface of that application.</p>
 
 <p>For security reasons, no username in the default Realm (i.e. using
-<code>conf/tomcat-users.xml</code> is assigned the "manager" role.  Therefore,
-no one will be able to utilize the features of this application until the
-Tomcat administrator specifically assigns this role to one or more users.</p>
+<code>conf/tomcat-users.xml</code> is assigned the "manager-gui" role.
+Therefore, no one will be able to utilize the features of this application
+until the Tomcat administrator specifically assigns this role to one or more
+users.</p>
 
 </subsection>
 

commit 4ef5797dfa358d68a8a7ade8a672a38c4428a1c5
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Fri Jan 7 18:13:38 2011 +0000

    Fix security exception when running Servlet TCK
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1056434 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index abe484a..f444b9d 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -231,6 +231,7 @@ public final class SecurityClassLoad {
                 basePackage + "util.http.FastHttpDateFormat");
         clazz.newInstance();
         loader.loadClass(basePackage + "util.http.HttpMessages");
+        loader.loadClass(basePackage + "util.net.Constants");
         loader.loadClass(basePackage + "util.net.SSLSupport$CipherData");
         loader.loadClass
             (basePackage + "util.net.JIoEndpoint$PrivilegedSetTccl");

commit f2d19a9f06f4a3f16436dc3d8e034c62f8873970
Author: Sylvain Laurent <slaurent@apache.org>
Date:   Fri Dec 3 22:19:11 2010 +0000

    bug 50282 : Load javax.security.auth.login.Configuration with JreMemoryLeakPreventionListener to avoid memory leak when stopping a webapp that would use JAAS.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1042029 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java b/java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java
index 24fdb75..64c9f26 100644
--- a/java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java
+++ b/java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java
@@ -107,7 +107,21 @@ public class JreMemoryLeakPreventionListener implements LifecycleListener {
          this.securityPolicyProtection = securityPolicyProtection;
      }
      
-    /**
+     /**
+      * Protect against the memory leak caused when the first call to
+      * <code>javax.security.auth.login.Configuration</code> is triggered by a web
+      * application. This first call populate a static variable with a reference
+      * to the context class loader. Defaults to <code>true</code>.
+      */
+     private boolean securityLoginConfigurationProtection = true;
+     public boolean isSecurityLoginConfigurationProtection() {
+         return securityLoginConfigurationProtection;
+     }
+     public void setSecurityLoginConfigurationProtection(boolean securityLoginConfigurationProtection) {
+         this.securityLoginConfigurationProtection = securityLoginConfigurationProtection;
+     }
+
+     /**
      * Protect against the memory leak, when the initialization of the
      * Java Cryptography Architecture is triggered by initializing
      * a MessageDigest during web application deployment.
@@ -274,6 +288,19 @@ public class JreMemoryLeakPreventionListener implements LifecycleListener {
                     }
                 }
     
+                
+                /*
+                 * Initializing javax.security.auth.login.Configuration retains a static reference to the context 
+                 * class loader.
+                 */
+                if (securityLoginConfigurationProtection) {
+                    try {
+                        Class.forName("javax.security.auth.login.Configuration", true, ClassLoader.getSystemClassLoader());
+                    } catch(ClassNotFoundException e) {
+                        // Ignore
+                    }
+                }
+
                 /*
                  * Creating a MessageDigest during web application startup
                  * initializes the Java Cryptography Architecture. Under certain
diff --git a/webapps/docs/changelog.xml b/webapps/docs/changelog.xml
index febf50b..677ff96 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -43,6 +43,12 @@
   <subsection name="Catalina">
     <changelog>
       <add>
+        <bug>50282</bug>: Load <code>javax.security.auth.login.Configuration</code>
+        with <code>JreMemoryLeakPreventionListener</code> to avoid memory leak
+        when stopping a webapp that would use JAAS.
+        (slaurent)
+      </add>
+      <add>
         <bug>48973</bug>: Avoid creating a SESSIONS.ser file when stopping an 
         application if there's no session. Patch provided by Marc Guillemot.
         (slaurent)
diff --git a/webapps/docs/config/listeners.xml b/webapps/docs/config/listeners.xml
index 713d1ff..10976e2 100644
--- a/webapps/docs/config/listeners.xml
+++ b/webapps/docs/config/listeners.xml
@@ -270,6 +270,16 @@ service:jmx:rmi://&lt;hostname&gt;:10002/jndi/rmi://&lt;hostname&gt;:10001/jmxrm
         trigger a memory leak on reload. Defaults to <code>true</code>.</p>
       </attribute>
 
+      <attribute name="securityLoginConfigurationProtection" required="false">
+        <p>Enables protection so that usage of the
+        <code>javax.security.auth.login.Configuration</code> class by a web 
+        application does not in a memory leak. The first access of this class will
+        trigger the initializer that will retain a static reference to the context
+        class loader. The protection loads the class with the system classloader 
+        to ensure that the static initializer is not triggered by web application.
+        Defaults to <code>true</code>.</p>
+      </attribute>
+
       <attribute name="securityPolicyProtection" required="false">
         <p>Enables protection so that usage of the deprecated
         <code>javax.security.auth.Policy</code> class by a web application does not

commit e075c4bb778f4514917caa0d9f1f225db8505652
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Fri Nov 12 18:29:12 2010 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=50192
    Improve performance for EL when running under a security manager.
    Based on a patch by Robert Goff.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1034500 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/jasper/el/ELContextImpl.java b/java/org/apache/jasper/el/ELContextImpl.java
index ccc296e..0047708 100644
--- a/java/org/apache/jasper/el/ELContextImpl.java
+++ b/java/org/apache/jasper/el/ELContextImpl.java
@@ -26,8 +26,6 @@ import javax.el.FunctionMapper;
 import javax.el.ValueExpression;
 import javax.el.VariableMapper;
 
-import org.apache.jasper.Constants;
-
 /**
  * Implementation of ELContext
  * 
@@ -66,22 +64,12 @@ public final class ELContextImpl extends ELContext {
 
     private final ELResolver resolver;
 
-    private FunctionMapper functionMapper;
+    private FunctionMapper functionMapper = NullFunctionMapper;
 
     private VariableMapper variableMapper;
 
     public ELContextImpl() {
         this(ELResolverImpl.getDefaultResolver());
-        if (Constants.IS_SECURITY_ENABLED) {
-            functionMapper = new FunctionMapper() {
-                @Override
-                public Method resolveFunction(String prefix, String localName) {
-                    return null;
-                }
-            };
-        } else {
-            functionMapper = NullFunctionMapper;
-        }
     }
 
     public ELContextImpl(ELResolver resolver) {
diff --git a/java/org/apache/jasper/el/ELResolverImpl.java b/java/org/apache/jasper/el/ELResolverImpl.java
index ce408cf..129a2ab 100644
--- a/java/org/apache/jasper/el/ELResolverImpl.java
+++ b/java/org/apache/jasper/el/ELResolverImpl.java
@@ -35,20 +35,27 @@ import javax.servlet.jsp.el.VariableResolver;
 import org.apache.jasper.Constants;
 
 public final class ELResolverImpl extends ELResolver {
-    private final static ELResolver DefaultResolver = new CompositeELResolver();
+    private final static ELResolver DefaultResolver;
 
     static {
-        ((CompositeELResolver) DefaultResolver).add(new MapELResolver());
-        ((CompositeELResolver) DefaultResolver).add(new ResourceBundleELResolver());
-        ((CompositeELResolver) DefaultResolver).add(new ListELResolver());
-        ((CompositeELResolver) DefaultResolver).add(new ArrayELResolver());
-        ((CompositeELResolver) DefaultResolver).add(new BeanELResolver());
+        if (Constants.IS_SECURITY_ENABLED) {
+            DefaultResolver = null;
+        } else {
+            DefaultResolver = new CompositeELResolver();
+            ((CompositeELResolver) DefaultResolver).add(new MapELResolver());
+            ((CompositeELResolver) DefaultResolver).add(new ResourceBundleELResolver());
+            ((CompositeELResolver) DefaultResolver).add(new ListELResolver());
+            ((CompositeELResolver) DefaultResolver).add(new ArrayELResolver());
+            ((CompositeELResolver) DefaultResolver).add(new BeanELResolver());
+        }
     }
 
     private final VariableResolver variableResolver;
+    private final ELResolver elResolver;
 
     public ELResolverImpl(VariableResolver variableResolver) {
         this.variableResolver = variableResolver;
+        this.elResolver = getDefaultResolver();
     }
 
     @Override
@@ -71,7 +78,7 @@ public final class ELResolverImpl extends ELResolver {
         }
 
         if (!context.isPropertyResolved()) {
-            return getDefaultResolver().getValue(context, base, property);
+            return elResolver.getValue(context, base, property);
         }
         return null;
     }
@@ -97,7 +104,7 @@ public final class ELResolverImpl extends ELResolver {
         }
 
         if (!context.isPropertyResolved()) {
-            return getDefaultResolver().getType(context, base, property);
+            return elResolver.getType(context, base, property);
         }
         return null;
     }
@@ -118,7 +125,7 @@ public final class ELResolverImpl extends ELResolver {
         }
 
         if (!context.isPropertyResolved()) {
-            getDefaultResolver().setValue(context, base, property, value);
+            elResolver.setValue(context, base, property, value);
         }
     }
 
@@ -134,12 +141,12 @@ public final class ELResolverImpl extends ELResolver {
             return true;
         }
 
-        return getDefaultResolver().isReadOnly(context, base, property);
+        return elResolver.isReadOnly(context, base, property);
     }
 
     @Override
     public Iterator<java.beans.FeatureDescriptor> getFeatureDescriptors(ELContext context, Object base) {
-        return getDefaultResolver().getFeatureDescriptors(context, base);
+        return elResolver.getFeatureDescriptors(context, base);
     }
 
     @Override
@@ -147,7 +154,7 @@ public final class ELResolverImpl extends ELResolver {
         if (base == null) {
             return String.class;
         }
-        return getDefaultResolver().getCommonPropertyType(context, base);
+        return elResolver.getCommonPropertyType(context, base);
     }
 
     public static ELResolver getDefaultResolver() {
diff --git a/webapps/docs/changelog.xml b/webapps/docs/changelog.xml
index 91785ec..cdd6f55 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -175,6 +175,10 @@
       <add>
         Add logging and JMX support to JSP unloading. (rjung)
       </add>
+      <fix>
+        <bug>50192</bug>: Improve performance for EL when running under a
+        security manager. Based on a patch by Robert Goff. (markt) 
+      </fix>
     </changelog>
   </subsection>
   <subsection name="Cluster">

commit c898c50a126f18b8e8d2c83e8fb14e8d202bd20b
Author: Konstantin Kolinko <kkolinko@apache.org>
Date:   Sun Oct 24 22:52:07 2010 +0000

    Followup to r1026784
    Print a stacktrace if an exception (e.g. IOException) happens when calling store.keys() and running under a security manager.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1026912 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/session/PersistentManagerBase.java b/java/org/apache/catalina/session/PersistentManagerBase.java
index 8a7d3c8..afa70c5 100644
--- a/java/org/apache/catalina/session/PersistentManagerBase.java
+++ b/java/org/apache/catalina/session/PersistentManagerBase.java
@@ -550,7 +550,7 @@ public abstract class PersistentManagerBase extends ManagerBase {
                 }catch(PrivilegedActionException ex){
                     Exception exception = ex.getException();
                     log.error("Exception in the Store during load: "
-                              + exception);
+                              + exception, exception);
                     return;
                 }
             } else {

commit 11e513d5ff361f580767661ac0ee953c307ef8e7
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Fri Oct 8 13:22:04 2010 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=50015
    Re-factor dynamic servlet security implementation to make extensions, such as JACC implementations, simpler. Patch provided by David Jencks.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1005811 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/Context.java b/java/org/apache/catalina/Context.java
index d03f718..3876983 100644
--- a/java/org/apache/catalina/Context.java
+++ b/java/org/apache/catalina/Context.java
@@ -24,8 +24,10 @@ import java.util.Set;
 
 import javax.servlet.ServletContainerInitializer;
 import javax.servlet.ServletContext;
+import javax.servlet.ServletSecurityElement;
 import javax.servlet.descriptor.JspConfigDescriptor;
 
+import org.apache.catalina.core.ApplicationServletRegistration;
 import org.apache.catalina.deploy.ApplicationParameter;
 import org.apache.catalina.deploy.ErrorPage;
 import org.apache.catalina.deploy.FilterDef;
@@ -1222,5 +1224,16 @@ public interface Context extends Container {
      * Is this context using version 2.2 of the Servlet spec?
      */
     boolean isServlet22();
+
+    /**
+     * Notification that servlet security has been dynamically set in a
+     * {@Link ServletRegistration.Dynamic}
+     * @param registration servlet security was modified for
+     * @param servletSecurityElement new security constraints for this servlet
+     * @return urls currently mapped to this registration that are already
+     *         present in web.xml
+     */
+    Set<String> addServletSecurity(ApplicationServletRegistration registration,
+            ServletSecurityElement servletSecurityElement);
 }
 
diff --git a/java/org/apache/catalina/core/ApplicationContext.java b/java/org/apache/catalina/core/ApplicationContext.java
index d76c720..a590c53 100644
--- a/java/org/apache/catalina/core/ApplicationContext.java
+++ b/java/org/apache/catalina/core/ApplicationContext.java
@@ -1082,10 +1082,10 @@ public class ApplicationContext
         } else {
             wrapper.setServletClass(servlet.getClass().getName());
             wrapper.setServlet(servlet);
-       }
-        
-        return new ApplicationServletRegistration(wrapper, context);
-    } 
+        }
+
+        return context.dynamicServletAdded(wrapper);
+    }
 
 
     public <T extends Servlet> T createServlet(Class<T> c)
@@ -1093,6 +1093,7 @@ public class ApplicationContext
         try {
             @SuppressWarnings("unchecked")
             T servlet = (T) context.getInstanceManager().newInstance(c.getName());
+            context.dynamicServletCreated(servlet);
             return servlet;
         } catch (IllegalAccessException e) {
             throw new ServletException(e);
diff --git a/java/org/apache/catalina/core/ApplicationServletRegistration.java b/java/org/apache/catalina/core/ApplicationServletRegistration.java
index dd4a372..4be7e0e 100644
--- a/java/org/apache/catalina/core/ApplicationServletRegistration.java
+++ b/java/org/apache/catalina/core/ApplicationServletRegistration.java
@@ -117,10 +117,12 @@ public class ApplicationServletRegistration
 
         // Have to add in a separate loop since spec requires no updates at all
         // if there is an issue
-        for (Map.Entry<String, String> entry : initParameters.entrySet()) {
-            setInitParameter(entry.getKey(), entry.getValue());
+        if (conflicts.isEmpty()) {
+            for (Map.Entry<String, String> entry : initParameters.entrySet()) {
+                setInitParameter(entry.getKey(), entry.getValue());
+            }
         }
-        
+
         return conflicts;
     }
 
@@ -158,53 +160,7 @@ public class ApplicationServletRegistration
                     getName(), context.getPath()));
         }
 
-        Set<String> conflicts = new HashSet<String>();
-
-        Collection<String> urlPatterns = getMappings();
-        for (String urlPattern : urlPatterns) {
-            boolean foundConflict = false;
-            
-            SecurityConstraint[] securityConstraints =
-                context.findConstraints();
-            for (SecurityConstraint securityConstraint : securityConstraints) {
-                
-                SecurityCollection[] collections =
-                    securityConstraint.findCollections();
-                for (SecurityCollection collection : collections) {
-                    if (collection.findPattern(urlPattern)) {
-                        // First pattern found will indicate if there is a
-                        // conflict since for any given pattern all matching
-                        // constraints will be from either the descriptor or
-                        // not. It is not permitted to have a mixture
-                        if (collection.isFromDescriptor()) {
-                            // Skip this pattern
-                            foundConflict = true;
-                        } else {
-                            // Need to overwrite constraint for this pattern
-                            // so remove every pattern found
-                            context.removeConstraint(securityConstraint);
-                        }
-                    }
-                    if (foundConflict) {
-                        break;
-                    }
-                }
-                if (foundConflict) {
-                    break;
-                }
-            }
-            if (!foundConflict) {
-                SecurityConstraint[] newSecurityConstraints =
-                        SecurityConstraint.createConstraints(constraint,
-                                urlPattern);
-                for (SecurityConstraint securityConstraint :
-                        newSecurityConstraints) {
-                    context.addConstraint(securityConstraint);
-                }
-            }
-        }
-        
-        return conflicts;
+        return context.addServletSecurity(this, constraint);
     }
 
 
diff --git a/java/org/apache/catalina/core/StandardContext.java b/java/org/apache/catalina/core/StandardContext.java
index b80276f..1539318 100644
--- a/java/org/apache/catalina/core/StandardContext.java
+++ b/java/org/apache/catalina/core/StandardContext.java
@@ -26,7 +26,9 @@ import java.io.InputStreamReader;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
@@ -47,14 +49,17 @@ import javax.management.ObjectName;
 import javax.naming.NamingException;
 import javax.naming.directory.DirContext;
 import javax.servlet.FilterConfig;
+import javax.servlet.Servlet;
 import javax.servlet.ServletContainerInitializer;
 import javax.servlet.ServletContext;
 import javax.servlet.ServletContextAttributeListener;
 import javax.servlet.ServletContextEvent;
 import javax.servlet.ServletContextListener;
 import javax.servlet.ServletException;
+import javax.servlet.ServletRegistration;
 import javax.servlet.ServletRequestAttributeListener;
 import javax.servlet.ServletRequestListener;
+import javax.servlet.ServletSecurityElement;
 import javax.servlet.descriptor.JspConfigDescriptor;
 import javax.servlet.http.HttpSessionAttributeListener;
 import javax.servlet.http.HttpSessionListener;
@@ -4050,6 +4055,22 @@ public class StandardContext extends ContainerBase
         return null;
     }
 
+    /**
+     * hook to register that we need to scan for security annotations.
+     * @param registration
+     */
+    public ServletRegistration.Dynamic dynamicServletAdded(Wrapper wrapper) {
+        return new ApplicationServletRegistration(wrapper, this);
+    }
+
+    /**
+     * hook to track which registrations need annotation scanning
+     * @param servlet
+     */
+    public void dynamicServletCreated(Servlet servlet) {
+        // NOOP - Hook for JACC implementations
+    }
+
 
     /**
      * A helper class to manage the filter mappings in a Context.
@@ -5173,6 +5194,71 @@ public class StandardContext extends ContainerBase
 
     }
 
+    public Set<String> addServletSecurity(
+            ApplicationServletRegistration registration,
+            ServletSecurityElement servletSecurityElement) {
+
+        Set<String> conflicts = new HashSet<String>();
+
+        Collection<String> urlPatterns = registration.getMappings();
+        for (String urlPattern : urlPatterns) {
+            boolean foundConflict = false;
+
+            SecurityConstraint[] securityConstraints =
+                findConstraints();
+            for (SecurityConstraint securityConstraint : securityConstraints) {
+
+                SecurityCollection[] collections =
+                    securityConstraint.findCollections();
+                for (SecurityCollection collection : collections) {
+                    if (collection.findPattern(urlPattern)) {
+                        // First pattern found will indicate if there is a
+                        // conflict since for any given pattern all matching
+                        // constraints will be from either the descriptor or
+                        // not. It is not permitted to have a mixture
+                        if (collection.isFromDescriptor()) {
+                            // Skip this pattern
+                            foundConflict = true;
+                            conflicts.add(urlPattern);
+                        } else {
+                            // Need to overwrite constraint for this pattern
+                            // so remove every pattern found
+
+                            // TODO spec 13.4.2 appears to say only the
+                            // conflicting pattern is overwritten, not the
+                            // entire security constraint.
+                            removeConstraint(securityConstraint);
+                        }
+                    }
+                    if (foundConflict) {
+                        break;
+                    }
+                }
+                if (foundConflict) {
+                    break;
+                }
+            }
+            // TODO spec 13.4.2 appears to say that non-conflicting patterns are
+            // still used.
+            // TODO you can't calculate the eventual security constraint now,
+            // you have to wait until the context is started, since application
+            // code can add url patterns after calling setSecurity.
+            if (!foundConflict) {
+                SecurityConstraint[] newSecurityConstraints =
+                        SecurityConstraint.createConstraints(
+                                servletSecurityElement,
+                                urlPattern);
+                for (SecurityConstraint securityConstraint :
+                        newSecurityConstraints) {
+                    addConstraint(securityConstraint);
+                }
+            }
+        }
+
+        return conflicts;
+
+    }
+
 
     /**
      * Return a File object representing the base directory for the
diff --git a/webapps/docs/changelog.xml b/webapps/docs/changelog.xml
index 4292836..ff02e3e 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -89,6 +89,11 @@
         <bug>49994</bug>: As per the Java EE 6 specification, return a new
         object instance for each JNDI look up of a resource reference. (markt) 
       </fix>
+      <fix>
+        <bug>50015</bug>: Re-factor dynamic servlet security implementation to
+        make extensions, such as JACC implementations, simpler. Patch provided
+        by David Jencks. (markt) 
+      </fix>
     </changelog>
   </subsection>
   <subsection name="Coyote">

commit d0d4c756f2656012fc0b8de3923d0978fea14c3e
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Mon Sep 27 23:06:08 2010 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=49209
    Prevent possible AccessControlException during undeployment when running with a security manager
    Patch provided by Sylvain Laurent
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1001955 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/loader/WebappClassLoader.java b/java/org/apache/catalina/loader/WebappClassLoader.java
index 46c88a6..ce24da5 100644
--- a/java/org/apache/catalina/loader/WebappClassLoader.java
+++ b/java/org/apache/catalina/loader/WebappClassLoader.java
@@ -2022,7 +2022,7 @@ public class WebappClassLoader
             }
             Class<?> lpClass =
                 defineClass("org.apache.catalina.loader.JdbcLeakPrevention",
-                    classBytes, 0, offset);
+                    classBytes, 0, offset, this.getClass().getProtectionDomain());
             Object obj = lpClass.newInstance();
             @SuppressWarnings("unchecked") // clearJdbcDriverRegistrations() returns List<String> 
             List<String> driverNames = (List<String>) obj.getClass().getMethod(

commit 587b1a807129c2ab41623358281aa19ff2ff9950
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Mon Sep 27 12:13:32 2010 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=49884
    
    This required a major re-factoring of the async implementation. In summary:
    - Moved state management to the Coyote Processor
    - Added a SocketWrapper to the APR socket
    - Added syncs to ensure only one async state change at a time
    - Added syncs to ensure only one thread changing a socket's state at a time
    
    A number of new bugs were also uncovered and fixed by this re-factoring:
    - delay processing complete() and dispatch() until request where startAsync() is called finished processing
    - onAsyncStart listener event
    
    Currently the test case for bug 49884 passes with the security manager enabled using "ab -n 5000 -c 150 -k ..." (it broke with "ab -n 50 -c 10 ..." previously)
    
    The unit tests pass for all three HTTP connectors.
    
    The AJP connectors have only been modified to ensure the code compiles.
    
    The following work remains:
    - Testing all connectors (HTTP and AJP) with TCK + security manager and fixing whatever is broken
    - Further clean-up
    - There is further scope for reducing code duplication between the connectors / aligning the code so it is easier to maintain.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1001698 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/connector/CoyoteAdapter.java b/java/org/apache/catalina/connector/CoyoteAdapter.java
index 1540920..2fddb77 100644
--- a/java/org/apache/catalina/connector/CoyoteAdapter.java
+++ b/java/org/apache/catalina/connector/CoyoteAdapter.java
@@ -260,55 +260,25 @@ public class CoyoteAdapter implements Adapter {
                     "Dispatch may only happen on an existing request.");
         }
         boolean comet = false;
-        boolean async = false;
         boolean success = true;
-        
+        AsyncContextImpl asyncConImpl = (AsyncContextImpl)request.getAsyncContext();
         try {
             if (status==SocketStatus.TIMEOUT) {
-                AsyncContextImpl asyncConImpl = (AsyncContextImpl)request.getAsyncContext();
-                //TODO SERVLET3 - async
-                //configure settings for timed out
-                asyncConImpl.setTimeoutState();
-            }
-            if (status==SocketStatus.ERROR || status==SocketStatus.DISCONNECT) {
-                AsyncContextImpl asyncConImpl = (AsyncContextImpl)request.getAsyncContext();
-                //TODO SERVLET3 - async
-                //configure settings for timed out
-                asyncConImpl.setErrorState(new IOException("Socket error."));
+                success = true;
+                if (!asyncConImpl.timeout()) {
+                    asyncConImpl.setErrorState(null);
+                }
             }
-            while (success) {
-                AsyncContextImpl impl = (AsyncContextImpl)request.getAsyncContext();
-                    // Calling the container
-                if (impl.getState()==AsyncContextImpl.AsyncState.DISPATCHED) {
-                    // Calling the container
-                    try {
-                        impl.complete();
-                        connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
-                    } finally {
-                        success = false;
-                    }
-                } else if (impl.getState()==AsyncContextImpl.AsyncState.STARTED){
-                    //TODO SERVLET3 - async
-                    res.action(ActionCode.ASYNC_START, request.getAsyncContext());
-                    async = true;
-                    break;
-                } else if (impl.getState()==AsyncContextImpl.AsyncState.NOT_STARTED){
-                    //TODO SERVLET3 - async
-                    async = false;
-                    break;
-                } else if (impl.getState()==AsyncContextImpl.AsyncState.ERROR_DISPATCHING) {
-                    async = false;
-                    success = false;
-                    connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
-                } else {
-                    try {
-                        connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
-                    } catch (RuntimeException x) {
-                        impl.setErrorState(x);
-                    }
+            if (request.isAsyncDispatching()) {
+                success = true;
+                connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
+                Throwable t = (Throwable) request.getAttribute(
+                        Globals.EXCEPTION_ATTR);
+                if (t != null) {
+                    asyncConImpl.setErrorState(t);
                 }
             }
-            
+
             if (request.isComet()) {
                 if (!response.isClosed() && !response.isError()) {
                     if (request.getAvailable() || (request.getContentLength() > 0 && (!request.isParametersParsed()))) {
@@ -327,7 +297,7 @@ public class CoyoteAdapter implements Adapter {
                     request.setFilterChain(null);
                 }
             }
-            if (!async && !comet) {
+            if (!request.isAsync() && !comet) {
                 response.finishResponse();
                 req.action(ActionCode.POST_REQUEST , null);
             }
@@ -341,7 +311,7 @@ public class CoyoteAdapter implements Adapter {
         } finally {
             req.getRequestProcessor().setWorkerThreadName(null);
             // Recycle the wrapper request and response
-            if (!success || (!comet && !async)) {
+            if (!success || (!comet && !request.isAsync())) {
                 request.recycle();
                 response.recycle();
             } else {
@@ -426,15 +396,8 @@ public class CoyoteAdapter implements Adapter {
 
             }
             AsyncContextImpl asyncConImpl = (AsyncContextImpl)request.getAsyncContext();
-            if (asyncConImpl!=null && asyncConImpl.getState()==AsyncContextImpl.AsyncState.STARTED) {
-                res.action(ActionCode.ASYNC_START, request.getAsyncContext());
+            if (asyncConImpl != null) {
                 async = true;
-            } else if (request.isAsyncDispatching()) {
-                asyncDispatch(req, res, SocketStatus.OPEN);
-                if (request.isAsyncStarted()) {
-                    async = true;
-                    res.action(ActionCode.ASYNC_START, request.getAsyncContext());
-                }
             } else if (!comet) {
                 response.finishResponse();
                 req.action(ActionCode.POST_REQUEST , null);
diff --git a/java/org/apache/catalina/connector/Request.java b/java/org/apache/catalina/connector/Request.java
index 175f574..0b65980 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -37,6 +37,7 @@ import java.util.Locale;
 import java.util.Map;
 import java.util.TimeZone;
 import java.util.TreeMap;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import javax.security.auth.Subject;
 import javax.servlet.AsyncContext;
@@ -1613,12 +1614,20 @@ public class Request
         if (asyncContext == null) {
             return false;
         }
-        
-        return (asyncContext.getState()==AsyncContextImpl.AsyncState.DISPATCHING ||
-                asyncContext.getState()==AsyncContextImpl.AsyncState.TIMING_OUT  ||
-                asyncContext.getState()==AsyncContextImpl.AsyncState.STARTED     ||
-                asyncContext.getState()==AsyncContextImpl.AsyncState.ERROR_DISPATCHING ||
-                asyncContext.getState()==AsyncContextImpl.AsyncState.COMPLETING);
+
+        AtomicBoolean result = new AtomicBoolean(false);
+        coyoteRequest.action(ActionCode.ASYNC_IS_DISPATCHING, result);
+        return result.get();
+    }
+
+    public boolean isAsync() {
+        if (asyncContext == null) {
+            return false;
+        }
+
+        AtomicBoolean result = new AtomicBoolean(false);
+        coyoteRequest.action(ActionCode.ASYNC_IS_ASYNC, result);
+        return result.get();
     }
 
     @Override
diff --git a/java/org/apache/catalina/core/AsyncContextImpl.java b/java/org/apache/catalina/core/AsyncContextImpl.java
index bbb2f88..a5fad2f 100644
--- a/java/org/apache/catalina/core/AsyncContextImpl.java
+++ b/java/org/apache/catalina/core/AsyncContextImpl.java
@@ -22,7 +22,6 @@ import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicReference;
 
 import javax.servlet.AsyncContext;
 import javax.servlet.AsyncEvent;
@@ -50,11 +49,6 @@ import org.apache.juli.logging.LogFactory;
  */
 public class AsyncContextImpl implements AsyncContext {
     
-    public static enum AsyncState {
-        NOT_STARTED, STARTED, DISPATCHING, DISPATCHED, COMPLETING, TIMING_OUT,
-        TIMING_OUT_NEED_COMPLETE, ERROR_DISPATCHING
-    }
-    
     private static final Log log = LogFactory.getLog(AsyncContextImpl.class);
     
     private ServletRequest servletRequest = null;
@@ -63,7 +57,6 @@ public class AsyncContextImpl implements AsyncContext {
     private boolean hasOriginalRequestAndResponse = true;
     private volatile Runnable dispatch = null;
     private Context context = null;
-    private AtomicReference<AsyncState> state = new AtomicReference<AsyncState>(AsyncState.NOT_STARTED);
     private long timeout = -1;
     private AsyncEvent event = null;
     
@@ -81,23 +74,46 @@ public class AsyncContextImpl implements AsyncContext {
         if (log.isDebugEnabled()) {
             logDebug("complete   ");
         }
-        if (state.get()==AsyncState.COMPLETING) {
-            //do nothing
-        } else if (state.compareAndSet(AsyncState.DISPATCHED,
-                           AsyncState.COMPLETING) ||
-                   state.compareAndSet(AsyncState.STARTED,
-                           AsyncState.COMPLETING) ||
-                   state.compareAndSet(AsyncState.TIMING_OUT_NEED_COMPLETE,
-                           AsyncState.COMPLETING)) {
-            AtomicBoolean dispatched = new AtomicBoolean(false);
-            request.getCoyoteRequest().action(ActionCode.ASYNC_COMPLETE,
-                    dispatched);
-            if (!dispatched.get()) doInternalComplete(false);
-        } else {
-            throw new IllegalStateException(
-                    "Complete not allowed. Invalid state:"+state.get());
+        request.getCoyoteRequest().action(ActionCode.ASYNC_COMPLETE, null);
+    }
+
+    public void fireOnComplete() {
+        List<AsyncListenerWrapper> listenersCopy =
+            new ArrayList<AsyncListenerWrapper>();
+        listenersCopy.addAll(listeners);
+        for (AsyncListenerWrapper listener : listenersCopy) {
+            try {
+                listener.fireOnComplete(event);
+            } catch (IOException ioe) {
+                log.warn("onComplete() failed for listener of type [" +
+                        listener.getClass().getName() + "]", ioe);
+            }
+        }
+    }
+    
+    public boolean timeout() throws IOException {
+        AtomicBoolean result = new AtomicBoolean();
+        request.getCoyoteRequest().action(ActionCode.ASYNC_TIMEOUT, result);
+        
+        if (result.get()) {
+            boolean listenerInvoked = false;
+            List<AsyncListenerWrapper> listenersCopy =
+                new ArrayList<AsyncListenerWrapper>();
+            listenersCopy.addAll(listeners);
+            for (AsyncListenerWrapper listener : listenersCopy) {
+                listener.fireOnTimeout(event);
+                listenerInvoked = true;
+            }
+            if (listenerInvoked) {
+                request.getCoyoteRequest().action(
+                        ActionCode.ASYNC_IS_TIMINGOUT, result);
+                return !result.get();
+            } else {
+                // No listeners, container calls complete
+                complete();
+            }
         }
-       
+        return true;
     }
 
     @Override
@@ -119,55 +135,37 @@ public class AsyncContextImpl implements AsyncContext {
         if (log.isDebugEnabled()) {
             logDebug("dispatch   ");
         }
-
-        if (state.compareAndSet(AsyncState.STARTED, AsyncState.DISPATCHING) ||
-            state.compareAndSet(AsyncState.DISPATCHED, AsyncState.DISPATCHING)) {
-
-            if (request.getAttribute(ASYNC_REQUEST_URI)==null) {
-                request.setAttribute(ASYNC_REQUEST_URI, request.getRequestURI()+"?"+request.getQueryString());
-                request.setAttribute(ASYNC_CONTEXT_PATH, request.getContextPath());
-                request.setAttribute(ASYNC_SERVLET_PATH, request.getServletPath());
-                request.setAttribute(ASYNC_QUERY_STRING, request.getQueryString());
-            }
-            final RequestDispatcher requestDispatcher = context.getRequestDispatcher(path);
-            final HttpServletRequest servletRequest = (HttpServletRequest)getRequest();
-            final HttpServletResponse servletResponse = (HttpServletResponse)getResponse();
-            Runnable run = new Runnable() {
-                @Override
-                public void run() {
-                    DispatcherType type = (DispatcherType)request.getAttribute(Globals.DISPATCHER_TYPE_ATTR);
-                    try {
-                        //piggy back on the request dispatcher to ensure that filters etc get called.
-                        //TODO SERVLET3 - async should this be include/forward or a new dispatch type
-                        //javadoc suggests include with the type of DispatcherType.ASYNC
-                        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, DispatcherType.ASYNC);
-                        requestDispatcher.include(servletRequest, servletResponse);
-                    }catch (Exception x) {
-                        //log.error("Async.dispatch",x);
-                        throw new RuntimeException(x);
-                    }finally {
-                        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, type);
-                    }
-                }
-            };
-            this.dispatch = run;
-            AtomicBoolean dispatched = new AtomicBoolean(false);
-            request.getCoyoteRequest().action(ActionCode.ASYNC_DISPATCH, dispatched );
-            if (!dispatched.get()) {
+        if (request.getAttribute(ASYNC_REQUEST_URI)==null) {
+            request.setAttribute(ASYNC_REQUEST_URI, request.getRequestURI()+"?"+request.getQueryString());
+            request.setAttribute(ASYNC_CONTEXT_PATH, request.getContextPath());
+            request.setAttribute(ASYNC_SERVLET_PATH, request.getServletPath());
+            request.setAttribute(ASYNC_QUERY_STRING, request.getQueryString());
+        }
+        final RequestDispatcher requestDispatcher = context.getRequestDispatcher(path);
+        final HttpServletRequest servletRequest = (HttpServletRequest)getRequest();
+        final HttpServletResponse servletResponse = (HttpServletResponse)getResponse();
+        Runnable run = new Runnable() {
+            @Override
+            public void run() {
+                request.getCoyoteRequest().action(ActionCode.ASYNC_DISPATCHED, null);
+                DispatcherType type = (DispatcherType)request.getAttribute(Globals.DISPATCHER_TYPE_ATTR);
                 try {
-                    doInternalDispatch();
-                }catch (ServletException sx) {
-                    throw new RuntimeException(sx);
-                }catch (IOException ix) {
-                    throw new RuntimeException(ix);
+                    //piggy back on the request dispatcher to ensure that filters etc get called.
+                    //TODO SERVLET3 - async should this be include/forward or a new dispatch type
+                    //javadoc suggests include with the type of DispatcherType.ASYNC
+                    request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, DispatcherType.ASYNC);
+                    requestDispatcher.include(servletRequest, servletResponse);
+                }catch (Exception x) {
+                    //log.error("Async.dispatch",x);
+                    throw new RuntimeException(x);
+                }finally {
+                    request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, type);
                 }
             }
-            if (state.get().equals(AsyncState.DISPATCHED)) {
-                complete();
-            }
-        } else {
-            throw new IllegalStateException("Dispatch not allowed. Invalid state:"+state.get());
-        }
+        };
+        
+        this.dispatch = run;
+        this.request.getCoyoteRequest().action(ActionCode.ASYNC_DISPATCH, null);
     }
 
     @Override
@@ -186,40 +184,8 @@ public class AsyncContextImpl implements AsyncContext {
             logDebug("start      ");
         }
 
-        if (state.get() ==  AsyncState.STARTED) {
-            // Execute the runnable using a container thread from the
-            // Connector's thread pool. Use a wrapper to prevent a memory leak
-            Runnable wrapper = new RunnableWrapper(run, context);
-            ClassLoader oldCL;
-            if (Globals.IS_SECURITY_ENABLED) {
-                PrivilegedAction<ClassLoader> pa = new PrivilegedGetTccl();
-                oldCL = AccessController.doPrivileged(pa);
-            } else {
-                oldCL = Thread.currentThread().getContextClassLoader();
-            }
-            try {
-                if (Globals.IS_SECURITY_ENABLED) {
-                    PrivilegedAction<Void> pa = new PrivilegedSetTccl(
-                            this.getClass().getClassLoader());
-                    AccessController.doPrivileged(pa);
-                } else {
-                    Thread.currentThread().setContextClassLoader(
-                            this.getClass().getClassLoader());
-                }
-                request.getConnector().getProtocolHandler().getExecutor(
-                        ).execute(wrapper);
-            } finally {
-                if (Globals.IS_SECURITY_ENABLED) {
-                    PrivilegedAction<Void> pa = new PrivilegedSetTccl(
-                            oldCL);
-                    AccessController.doPrivileged(pa);
-                } else {
-                    Thread.currentThread().setContextClassLoader(oldCL);
-                }
-            }
-        } else {
-            throw new IllegalStateException("Start not allowed. Invalid state:"+state.get());
-        }
+        Runnable wrapper = new RunnableWrapper(run, context);
+        this.request.getCoyoteRequest().action(ActionCode.ASYNC_RUN, wrapper);
     }
     
     @Override
@@ -259,31 +225,43 @@ public class AsyncContextImpl implements AsyncContext {
         }
         servletRequest = null;
         servletResponse = null;
-        listeners.clear();
         hasOriginalRequestAndResponse = true;
-        state.set(AsyncState.NOT_STARTED);
         context = null;
         timeout = -1;
         event = null;
     }
 
     public boolean isStarted() {
-        return (state.get() == AsyncState.STARTED ||
-                state.get() == AsyncState.DISPATCHING);
+        AtomicBoolean result = new AtomicBoolean(false);
+        request.getCoyoteRequest().action(
+                ActionCode.ASYNC_IS_STARTED, result);
+        return result.get();
     }
 
     public void setStarted(Context context, ServletRequest request,
-            ServletResponse response, boolean hasOriginalRequestAndResponse) {
-        if (state.compareAndSet(AsyncState.NOT_STARTED, AsyncState.STARTED) ||
-                state.compareAndSet(AsyncState.DISPATCHED, AsyncState.STARTED)) {
-            this.context = context;
-            this.servletRequest = request;
-            this.servletResponse = response;
-            this.hasOriginalRequestAndResponse = hasOriginalRequestAndResponse;
-            this.event = new AsyncEvent(this, request, response); 
-        } else {
-            throw new IllegalStateException("Start illegal. Invalid state: "+state.get());
+            ServletResponse response, boolean originalRequestResponse) {
+        
+        this.request.getCoyoteRequest().action(
+                ActionCode.ASYNC_START, this);
+
+        this.context = context;
+        this.servletRequest = request;
+        this.servletResponse = response;
+        this.hasOriginalRequestAndResponse = originalRequestResponse;
+        this.event = new AsyncEvent(this, request, response);
+        
+        List<AsyncListenerWrapper> listenersCopy =
+            new ArrayList<AsyncListenerWrapper>();
+        listenersCopy.addAll(listeners);
+        for (AsyncListenerWrapper listener : listenersCopy) {
+            try {
+                listener.fireOnStartAsync(event);
+            } catch (IOException ioe) {
+                log.warn("onStartAsync() failed for listener of type [" +
+                        listener.getClass().getName() + "]", ioe);
+            }
         }
+        listeners.clear();
     }
 
     @Override
@@ -295,122 +273,53 @@ public class AsyncContextImpl implements AsyncContext {
         if (log.isDebugEnabled()) {
             logDebug("intDispatch");
         }
-        if (this.state.compareAndSet(AsyncState.TIMING_OUT,
-                AsyncState.TIMING_OUT_NEED_COMPLETE)) {
-            log.debug("TIMING OUT!");
-            boolean listenerInvoked = false;
-            List<AsyncListenerWrapper> listenersCopy =
-                new ArrayList<AsyncListenerWrapper>();
-            listenersCopy.addAll(listeners);
-            for (AsyncListenerWrapper listener : listenersCopy) {
-                listener.fireOnTimeout(event);
-                listenerInvoked = true;
-            }
-            if (listenerInvoked) {
-                // Listener should have called complete
-                if (state.get() != AsyncState.NOT_STARTED) {
-                    ((HttpServletResponse)servletResponse).setStatus(500);
-                    state.set(AsyncState.COMPLETING);
-                    doInternalComplete(true);
-                }
-            } else {
-                // No listeners, container calls complete
-                state.set(AsyncState.COMPLETING);
-                doInternalComplete(false);
-            }
-        } else if (this.state.compareAndSet(AsyncState.ERROR_DISPATCHING, AsyncState.COMPLETING)) {
-            log.debug("ON ERROR!");
-            boolean listenerInvoked = false;
-            for (AsyncListenerWrapper listener : listeners) {
-                try {
-                    listener.fireOnError(event);
-                }catch (IllegalStateException x) {
-                    log.debug("Listener invoked invalid state.",x);
-                }catch (Exception x) {
-                    log.debug("Exception during onError.",x);
-                }
-                listenerInvoked = true;
-            }
-            if (!listenerInvoked) {
-                ((HttpServletResponse)servletResponse).setStatus(500);
-            }
-            doInternalComplete(true);
-        
-        } else if (this.state.compareAndSet(AsyncState.DISPATCHING, AsyncState.DISPATCHED)) {
-            if (this.dispatch!=null) {
-                try {
-                    dispatch.run();
-                } catch (RuntimeException x) {
-                    doInternalComplete(true);
-                    if (x.getCause() instanceof ServletException) throw (ServletException)x.getCause();
-                    if (x.getCause() instanceof IOException) throw (IOException)x.getCause();
-                    throw new ServletException(x);
-                } finally {
-                    dispatch = null;
-                }
-            }
-        } else if (this.state.get()==AsyncState.COMPLETING) {
-            doInternalComplete(false);
-        } else {
-            throw new IllegalStateException("Dispatch illegal. Invalid state: "+state.get());
-        }
-    }
-    
-    private void doInternalComplete(boolean error) {
-        if (log.isDebugEnabled()) {
-            logDebug("intComplete");
-        }
-        if (state.get()==AsyncState.NOT_STARTED) return;
-        if (state.compareAndSet(AsyncState.STARTED, AsyncState.NOT_STARTED)) {
-            //this is the same as
-            //request.startAsync().complete();
-            recycle();
-        } else if (state.compareAndSet(AsyncState.COMPLETING, AsyncState.NOT_STARTED)) {
-            for (AsyncListenerWrapper wrapper : listeners) {
-                try {
-                    wrapper.fireOnComplete(event);
-                }catch (IOException x) {
-                    //how does this propagate, or should it?
-                    //TODO SERVLET3 - async 
-                    log.error("",x);
-                }
+        try {
+            dispatch.run();
+        } catch (RuntimeException x) {
+            // doInternalComplete(true);
+            if (x.getCause() instanceof ServletException) {
+                throw (ServletException)x.getCause();
             }
-            try {
-                if (!error) getResponse().flushBuffer();
-            }catch (Exception x) {
-                log.error("",x);
+            if (x.getCause() instanceof IOException) {
+                throw (IOException)x.getCause();
             }
-            recycle();
-            
-        } else { 
-            throw new IllegalStateException("Complete illegal. Invalid state:"+state.get());
+            throw new ServletException(x);
         }
     }
-    
-    public AsyncState getState() {
-        return state.get();
-    }
+
     
     @Override
     public long getTimeout() {
         return timeout;
     }
-    
+
+
     @Override
     public void setTimeout(long timeout) {
         this.timeout = timeout;
         request.getCoyoteRequest().action(ActionCode.ASYNC_SETTIMEOUT,
                 Long.valueOf(timeout));
     }
-    
-    public void setTimeoutState() {
-        state.set(AsyncState.TIMING_OUT);
-    }
-    
+
+
     public void setErrorState(Throwable t) {
         if (t!=null) request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);
-        state.set(AsyncState.ERROR_DISPATCHING);
+        request.getCoyoteRequest().action(ActionCode.ASYNC_ERROR, null);
+        AsyncEvent errorEvent = new AsyncEvent(event.getAsyncContext(),
+                event.getSuppliedRequest(), event.getSuppliedResponse(), t);
+        List<AsyncListenerWrapper> listenersCopy =
+            new ArrayList<AsyncListenerWrapper>();
+        listenersCopy.addAll(listeners);
+        for (AsyncListenerWrapper listener : listenersCopy) {
+            try {
+                listener.fireOnError(errorEvent);
+            } catch (IOException ioe) {
+                log.warn("onStartAsync() failed for listener of type [" +
+                        listener.getClass().getName() + "]", ioe);
+            }
+        }
     }
+
     
     private void logDebug(String method) {
         String rHashCode;
@@ -457,7 +366,7 @@ public class AsyncContextImpl implements AsyncContext {
                 "Req: %1$8s  CReq: %2$8s  RP: %3$8s  Stage: %4$s  " +
                 "Thread: %5$20s  State: %6$20s  Method: %7$11s  URI: %8$s",
                 rHashCode, crHashCode, rpHashCode, stage,
-                Thread.currentThread().getName(), state, method, uri);
+                Thread.currentThread().getName(), "N/A", method, uri);
         if (log.isTraceEnabled()) {
             log.trace(msg, new DebugException());
         } else {
diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index 385bae2..d565442 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -38,6 +38,7 @@ public final class SecurityClassLoad {
         }
         
         loadCorePackage(loader);
+        loadCoyotePackage(loader);
         loadLoaderPackage(loader);
         loadSessionPackage(loader);
         loadUtilPackage(loader);
@@ -64,9 +65,6 @@ public final class SecurityClassLoad {
             "AsyncContextImpl");
         loader.loadClass
             (basePackage +
-            "AsyncContextImpl$AsyncState");
-        loader.loadClass
-            (basePackage +
             "AsyncContextImpl$DebugException");
         loader.loadClass
             (basePackage +
@@ -129,6 +127,13 @@ public final class SecurityClassLoad {
     }
     
     
+    private final static void loadCoyotePackage(ClassLoader loader)
+            throws Exception {
+        String basePackage = "org.apache.coyote.";
+        loader.loadClass(basePackage + "http11.AbstractOutputBuffer$1");
+    }
+
+
     private final static void loadJavaxPackage(ClassLoader loader)
         throws Exception {
         loader.loadClass("javax.servlet.http.Cookie");
@@ -221,13 +226,16 @@ public final class SecurityClassLoad {
     private final static void loadTomcatPackage(ClassLoader loader)
         throws Exception {
         String basePackage = "org.apache.tomcat.";
-        loader.loadClass(basePackage + "util.net.SSLSupport$CipherData");
-        loader.loadClass
-            (basePackage + "util.net.JIoEndpoint$PrivilegedSetTccl");
         // Make sure system property is read at this point
         Class<?> clazz = loader.loadClass(
                 basePackage + "util.http.FastHttpDateFormat");
         clazz.newInstance();
+        loader.loadClass(basePackage + "util.http.HttpMessages");
+        loader.loadClass(basePackage + "util.net.SSLSupport$CipherData");
+        loader.loadClass
+            (basePackage + "util.net.JIoEndpoint$PrivilegedSetTccl");
+        loader.loadClass
+            (basePackage + "util.net.AprEndpoint$PrivilegedSetTccl");
     }
 }
 
diff --git a/java/org/apache/coyote/ActionCode.java b/java/org/apache/coyote/ActionCode.java
index 043b4dd..5e811f1 100644
--- a/java/org/apache/coyote/ActionCode.java
+++ b/java/org/apache/coyote/ActionCode.java
@@ -133,18 +133,61 @@ public enum ActionCode {
 
     /**
      * Callback for an async call to
+     * {@link javax.servlet.AsyncContext#dispatch()}
+     */
+    ASYNC_DISPATCH,
+
+    /**
+     * Callback to indicate the the actual dispatch has started and that the
+     * async state needs change.
+     */
+    ASYNC_DISPATCHED,
+
+    /**
+     * Callback for an async call to
+     * {@link javax.servlet.AsyncContext#start()}
+     */
+    ASYNC_RUN,
+
+    /**
+     * Callback for an async call to
      * {@link javax.servlet.AsyncContext#complete()}
      */
     ASYNC_COMPLETE,
+    
+    /**
+     * Callback to trigger the processing of an async timeout
+     */
+    ASYNC_TIMEOUT,
+    
+    /**
+     * Callback to trigger the error processing
+     */
+    ASYNC_ERROR,
+    
     /**
      * Callback for an async call to
      * {@link javax.servlet.AsyncContext#setTimeout(long)}
      */
     ASYNC_SETTIMEOUT,
+    
+    /**
+     * Callback to determine if async processing is in progress 
+     */
+    ASYNC_IS_ASYNC,
+    
+    /**
+     * Callback to determine if async dispatch is in progress
+     */
+    ASYNC_IS_STARTED,
 
     /**
-     * Callback for an async call to
-     * {@link javax.servlet.AsyncContext#dispatch()}
+     * Callback to determine if async dispatch is in progress
      */
-    ASYNC_DISPATCH,
+    ASYNC_IS_DISPATCHING,
+
+    /**
+     * Callback to determine if async is timing out
+     */
+    ASYNC_IS_TIMINGOUT
 }
diff --git a/java/org/apache/coyote/ajp/AjpAprProcessor.java b/java/org/apache/coyote/ajp/AjpAprProcessor.java
index c0c3c07..19fd595 100644
--- a/java/org/apache/coyote/ajp/AjpAprProcessor.java
+++ b/java/org/apache/coyote/ajp/AjpAprProcessor.java
@@ -47,6 +47,7 @@ import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.AprEndpoint;
 import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketWrapper;
 import org.apache.tomcat.util.res.StringManager;
 
 
@@ -188,7 +189,7 @@ public class AjpAprProcessor implements ActionHook {
     /**
      * Socket associated with the current connection.
      */
-    protected long socket;
+    protected SocketWrapper<Long> socket;
 
 
     /**
@@ -355,15 +356,16 @@ public class AjpAprProcessor implements ActionHook {
      *
      * @throws IOException error during an I/O operation
      */
-    public boolean process(long socket)
+    public boolean process(SocketWrapper<Long> socket)
         throws IOException {
         RequestInfo rp = request.getRequestProcessor();
         rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
 
         // Setting up the socket
         this.socket = socket;
-        Socket.setrbb(this.socket, inputBuffer);
-        Socket.setsbb(this.socket, outputBuffer);
+        long socketRef = socket.getSocket().longValue();
+        Socket.setrbb(socketRef, inputBuffer);
+        Socket.setsbb(socketRef, outputBuffer);
 
         // Error flag
         error = false;
@@ -388,7 +390,7 @@ public class AjpAprProcessor implements ActionHook {
                 // not regular request processing
                 int type = requestHeaderMessage.getByte();
                 if (type == Constants.JK_AJP13_CPING_REQUEST) {
-                    if (Socket.sendb(socket, pongMessageBuffer, 0,
+                    if (Socket.sendb(socketRef, pongMessageBuffer, 0,
                             pongMessageBuffer.position()) < 0) {
                         error = true;
                     }
@@ -469,7 +471,7 @@ public class AjpAprProcessor implements ActionHook {
 
         // Add the socket to the poller
         if (!error && !endpoint.isPaused()) {
-            endpoint.getPoller().add(socket);
+            endpoint.getPoller().add(socketRef);
         } else {
             openSocket = false;
         }
@@ -483,7 +485,8 @@ public class AjpAprProcessor implements ActionHook {
     }
 
     /* Copied from the AjpProcessor.java */
-    public SocketState asyncDispatch(long socket, SocketStatus status) throws IOException {
+    public SocketState asyncDispatch(SocketWrapper<Long> socket,
+            SocketStatus status) throws IOException {
 
         // Setting up the socket
         this.socket = socket;
@@ -535,6 +538,8 @@ public class AjpAprProcessor implements ActionHook {
      */
     public void action(ActionCode actionCode, Object param) {
 
+        long socketRef = socket.getSocket().longValue();
+        
         if (actionCode == ActionCode.COMMIT) {
 
             if (response.isCommitted())
@@ -564,7 +569,7 @@ public class AjpAprProcessor implements ActionHook {
             try {
                 flush();
                 // Send explicit flush message
-                if (Socket.sendb(socket, flushMessageBuffer, 0,
+                if (Socket.sendb(socketRef, flushMessageBuffer, 0,
                                  flushMessageBuffer.position()) < 0) {
                     error = true;                    
                 }
@@ -661,14 +666,14 @@ public class AjpAprProcessor implements ActionHook {
             }        
         } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {
             if (param==null) return;
-            if (socket==0) return;
+            if (socketRef==0) return;
             long timeout = ((Long)param).longValue();
-            Socket.timeoutSet(socket, timeout * 1000); 
+            Socket.timeoutSet(socketRef, timeout * 1000); 
         } else if (actionCode == ActionCode.ASYNC_DISPATCH) {
            RequestInfo rp = request.getRequestProcessor();
             AtomicBoolean dispatch = (AtomicBoolean)param;
             if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) {//async handling
-                endpoint.getPoller().add(this.socket);
+                endpoint.getPoller().add(socketRef);
                 dispatch.set(true);
             } else {
                 dispatch.set(true);
@@ -1127,7 +1132,7 @@ public class AjpAprProcessor implements ActionHook {
         int nRead;
         while (inputBuffer.remaining() < n) {
             nRead = Socket.recvbb
-                (socket, inputBuffer.limit(),
+                (socket.getSocket().longValue(), inputBuffer.limit(),
                         inputBuffer.capacity() - inputBuffer.limit());
             if (nRead > 0) {
                 inputBuffer.limit(inputBuffer.limit() + nRead);
@@ -1160,7 +1165,7 @@ public class AjpAprProcessor implements ActionHook {
         int nRead;
         while (inputBuffer.remaining() < n) {
             nRead = Socket.recvbb
-                (socket, inputBuffer.limit(),
+                (socket.getSocket().longValue(), inputBuffer.limit(),
                     inputBuffer.capacity() - inputBuffer.limit());
             if (nRead > 0) {
                 inputBuffer.limit(inputBuffer.limit() + nRead);
@@ -1224,7 +1229,7 @@ public class AjpAprProcessor implements ActionHook {
         }
 
         // Request more data immediately
-        Socket.sendb(socket, getBodyMessageBuffer, 0,
+        Socket.sendb(socket.getSocket().longValue(), getBodyMessageBuffer, 0,
                 getBodyMessageBuffer.position());
 
         boolean moreData = receive();
@@ -1305,7 +1310,7 @@ public class AjpAprProcessor implements ActionHook {
     protected void flush()
         throws IOException {
         if (outputBuffer.position() > 0) {
-            if (Socket.sendbb(socket, 0, outputBuffer.position()) < 0) {
+            if (Socket.sendbb(socket.getSocket().longValue(), 0, outputBuffer.position()) < 0) {
                 throw new IOException(sm.getString("ajpprocessor.failedsend"));
             }
             outputBuffer.clear();
diff --git a/java/org/apache/coyote/ajp/AjpAprProtocol.java b/java/org/apache/coyote/ajp/AjpAprProtocol.java
index 84396cc..b0395cd 100644
--- a/java/org/apache/coyote/ajp/AjpAprProtocol.java
+++ b/java/org/apache/coyote/ajp/AjpAprProtocol.java
@@ -42,6 +42,7 @@ import org.apache.tomcat.util.modeler.Registry;
 import org.apache.tomcat.util.net.AprEndpoint;
 import org.apache.tomcat.util.net.AprEndpoint.Handler;
 import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketWrapper;
 import org.apache.tomcat.util.res.StringManager;
 
 
@@ -337,8 +338,8 @@ public class AjpAprProtocol
         protected AtomicLong registerCount = new AtomicLong(0);
         protected RequestGroupInfo global = new RequestGroupInfo();
 
-        protected ConcurrentHashMap<Long, AjpAprProcessor> connections =
-            new ConcurrentHashMap<Long, AjpAprProcessor>();
+        protected ConcurrentHashMap<SocketWrapper<Long>, AjpAprProcessor> connections =
+            new ConcurrentHashMap<SocketWrapper<Long>, AjpAprProcessor>();
 
         protected ConcurrentLinkedQueue<AjpAprProcessor> recycledProcessors = 
             new ConcurrentLinkedQueue<AjpAprProcessor>() {
@@ -384,11 +385,11 @@ public class AjpAprProtocol
         }
 
         // FIXME: Support for this could be added in AJP as well
-        public SocketState event(long socket, SocketStatus status) {
+        public SocketState event(SocketWrapper<Long> socket, SocketStatus status) {
             return SocketState.CLOSED;
         }
         
-        public SocketState process(long socket) {
+        public SocketState process(SocketWrapper<Long> socket) {
             AjpAprProcessor processor = recycledProcessors.poll();
             try {
 
@@ -397,7 +398,7 @@ public class AjpAprProtocol
                 }
 
                 if (processor.process(socket)) {
-                    connections.put(Long.valueOf(socket), processor);
+                    connections.put(socket, processor);
                     return SocketState.OPEN;
                 } else {
                     // recycledProcessors.offer(processor);
@@ -431,9 +432,9 @@ public class AjpAprProtocol
         }
 
         // FIXME: Support for this could be added in AJP as well
-        public SocketState asyncDispatch(long socket, SocketStatus status) {
+        public SocketState asyncDispatch(SocketWrapper<Long> socket, SocketStatus status) {
 
-            AjpAprProcessor result = connections.get(Long.valueOf(socket));
+            AjpAprProcessor result = connections.get(socket);
             
             SocketState state = SocketState.CLOSED; 
             if (result != null) {
@@ -462,10 +463,10 @@ public class AjpAprProtocol
                         (sm.getString("ajpprotocol.proto.error"), e);
                 } finally {
                     if (state != SocketState.LONG) {
-                        connections.remove(Long.valueOf(socket));
+                        connections.remove(socket);
                         recycledProcessors.offer(result);
                         if (state == SocketState.OPEN) {
-                            proto.endpoint.getPoller().add(socket);
+                            proto.endpoint.getPoller().add(socket.getSocket().longValue());
                         }
                     }
                 }
diff --git a/java/org/apache/coyote/http11/AbstractHttp11Processor.java b/java/org/apache/coyote/http11/AbstractHttp11Processor.java
index 9226fd2..4a400c1 100644
--- a/java/org/apache/coyote/http11/AbstractHttp11Processor.java
+++ b/java/org/apache/coyote/http11/AbstractHttp11Processor.java
@@ -17,11 +17,15 @@
 package org.apache.coyote.http11;
 
 import java.io.IOException;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.StringTokenizer;
 import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.regex.Pattern;
 import java.util.regex.PatternSyntaxException;
 
+import org.apache.catalina.core.AsyncContextImpl;
 import org.apache.coyote.ActionCode;
 import org.apache.coyote.Adapter;
 import org.apache.coyote.Request;
@@ -43,6 +47,7 @@ import org.apache.tomcat.util.buf.MessageBytes;
 import org.apache.tomcat.util.http.FastHttpDateFormat;
 import org.apache.tomcat.util.http.MimeHeaders;
 import org.apache.tomcat.util.net.AbstractEndpoint;
+import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.res.StringManager;
 
 public abstract class AbstractHttp11Processor {
@@ -236,12 +241,6 @@ public abstract class AbstractHttp11Processor {
 
     
     /**
-     * Async used
-     */
-    protected boolean async = false;
-
-
-    /**
      * Set compression level.
      */
     public void setCompression(String compression) {
@@ -904,7 +903,24 @@ public abstract class AbstractHttp11Processor {
                 request.getInputBuffer();
             internalBuffer.addActiveFilter(savedBody);
         } else if (actionCode == ActionCode.ASYNC_START) {
-            async = true;
+            asyncStart((AsyncContextImpl) param);
+        } else if (actionCode == ActionCode.ASYNC_DISPATCHED) {
+            asyncDispatched();
+        } else if (actionCode == ActionCode.ASYNC_TIMEOUT) {
+            AtomicBoolean result = (AtomicBoolean) param;
+            result.set(asyncTimeout());
+        } else if (actionCode == ActionCode.ASYNC_RUN) {
+            asyncRun((Runnable) param);
+        } else if (actionCode == ActionCode.ASYNC_ERROR) {
+            asyncError();
+        } else if (actionCode == ActionCode.ASYNC_IS_STARTED) {
+            ((AtomicBoolean) param).set(isAsyncStarted());
+        } else if (actionCode == ActionCode.ASYNC_IS_DISPATCHING) {
+            ((AtomicBoolean) param).set(isAsyncDispatching());
+        } else if (actionCode == ActionCode.ASYNC_IS_ASYNC) {
+            ((AtomicBoolean) param).set(isAsync());
+        } else if (actionCode == ActionCode.ASYNC_IS_TIMINGOUT) {
+            ((AtomicBoolean) param).set(isAsyncTimingOut());
         } else {
             actionInternal(actionCode, param);
         }
@@ -1086,10 +1102,276 @@ public abstract class AbstractHttp11Processor {
     public final void recycle() {
         getInputBuffer().recycle();
         getOutputBuffer().recycle();
+        asyncCtxt = null;
         recycleInternal();
     }
     
     protected abstract void recycleInternal();
     
     protected abstract Executor getExecutor();
+    
+    // -------------------------------------------------- Async state management
+    
+    /*
+     * DISPATCHED    - Standard request. Not in Async mode.
+     * STARTING      - ServletRequest.startAsync() has been called but the
+     *                 request in which that call was made has not finished
+     *                 processing.
+     * STARTED       - ServletRequest.startAsync() has been called and the
+     *                 request in which that call was made has finished
+     *                 processing.
+     * MUST_COMPLETE - complete() has been called before the request in which
+     *                 ServletRequest.startAsync() has finished. As soon as that
+     *                 request finishes, the complete() will be processed.
+     * COMPLETING    - The call to complete() was made once the request was in
+     *                 the STARTED state. May or may not be triggered by a
+     *                 container thread - depends if start(Runnable) was used
+     * 
+     * TODO - markt - Move this to a separate class
+     */
+    private static enum AsyncState {
+        DISPATCHED(false, false, false),
+        STARTING(true, true, false),
+        STARTED(true, true, false),
+        MUST_COMPLETE(true, false, false),
+        COMPLETING(true, false, false),
+        TIMING_OUT(true, false, false),
+        MUST_DISPATCH(true, false, true),
+        DISPATCHING(true, false, true),
+        ERROR(true,false,false);
+    
+        private boolean isAsync;
+        private boolean isStarted;
+        private boolean isDispatching;
+        
+        private AsyncState(boolean isAsync, boolean isStarted,
+                boolean isDispatching) {
+            this.isAsync = isAsync;
+            this.isStarted = isStarted;
+            this.isDispatching = isDispatching;
+        }
+        
+        public boolean isAsync() {
+            return this.isAsync;
+        }
+        
+        public boolean isStarted() {
+            return this.isStarted;
+        }
+        
+        public boolean isDispatching() {
+            return this.isDispatching;
+        }
+    }
+    
+    private volatile AsyncState state = AsyncState.DISPATCHED;
+    // Need this to fire listener on complete
+    private AsyncContextImpl asyncCtxt = null;
+    
+    protected boolean isAsync() {
+        return state.isAsync();
+    }
+
+    protected boolean isAsyncDispatching() {
+        return state.isDispatching();
+    }
+
+    protected boolean isAsyncStarted() {
+        return state.isStarted();
+    }
+
+    protected boolean isAsyncTimingOut() {
+        return state == AsyncState.TIMING_OUT;
+    }
+
+
+    private synchronized void asyncStart(AsyncContextImpl asyncCtxt) {
+        if (state == AsyncState.DISPATCHED) {
+            state = AsyncState.STARTING;
+            this.asyncCtxt = asyncCtxt;
+        } else {
+            throw new IllegalStateException(
+                    sm.getString("abstractHttp11Protocol.invalidAsyncState",
+                            "startAsync()", state));
+        }
+    }
+    
+    /*
+     * Async has been processed. Whether or not to enter a long poll depends on
+     * current state. For example, as per SRV.2.3.3.3 can now process calls to
+     * complete() or dispatch().
+     */
+    protected synchronized SocketState asyncPostProcess() {
+        
+        if (state == AsyncState.STARTING) {
+            state = AsyncState.STARTED;
+            return SocketState.LONG;
+        } else if (state == AsyncState.MUST_COMPLETE) {
+            asyncCtxt.fireOnComplete();
+            state = AsyncState.DISPATCHED;
+            return SocketState.ASYNC_END;
+        } else if (state == AsyncState.COMPLETING) {
+            state = AsyncState.DISPATCHED;
+            return SocketState.ASYNC_END;
+        } else if (state == AsyncState.MUST_DISPATCH) {
+            state = AsyncState.DISPATCHING;
+            return SocketState.ASYNC_END;
+        } else if (state == AsyncState.DISPATCHING) {
+            state = AsyncState.DISPATCHED;
+            return SocketState.ASYNC_END;
+        } else if (state == AsyncState.ERROR) {
+            asyncCtxt.fireOnComplete();
+            state = AsyncState.DISPATCHED;
+            return SocketState.ASYNC_END;
+        //} else if (state == AsyncState.DISPATCHED) {
+        //    // No state change
+        //    return SocketState.OPEN;
+        } else {
+            throw new IllegalStateException(
+                    sm.getString("abstractHttp11Protocol.invalidAsyncState",
+                            "asyncLongPoll()", state));
+        }
+    }
+    
+
+    protected synchronized boolean asyncComplete() {
+        boolean doComplete = false;
+        
+        if (state == AsyncState.STARTING) {
+            state = AsyncState.MUST_COMPLETE;
+        } else if (state == AsyncState.STARTED) {
+            state = AsyncState.COMPLETING;
+            doComplete = true;
+        } else if (state == AsyncState.TIMING_OUT ||
+                state == AsyncState.ERROR) {
+            state = AsyncState.MUST_COMPLETE;
+        } else {
+            throw new IllegalStateException(
+                    sm.getString("abstractHttp11Protocol.invalidAsyncState",
+                            "asyncComplete()", state));
+            
+        }
+        return doComplete;
+    }
+    
+    
+    private synchronized boolean asyncTimeout() {
+        if (state == AsyncState.STARTED) {
+            state = AsyncState.TIMING_OUT;
+            return true;
+        } else if (state == AsyncState.COMPLETING ||
+                state == AsyncState.DISPATCHED) {
+            // NOOP - App called complete between the the timeout firing and
+            // execution reaching this point
+            return false;
+        } else {
+            throw new IllegalStateException(
+                    sm.getString("abstractHttp11Protocol.invalidAsyncState",
+                            "timeoutAsync()", state));
+        }
+    }
+    
+    
+    protected synchronized boolean asyncDispatch() {
+        boolean doDispatch = false;
+        if (state == AsyncState.STARTING) {
+            state = AsyncState.MUST_DISPATCH;
+        } else if (state == AsyncState.STARTED) {
+            state = AsyncState.DISPATCHING;
+            doDispatch = true;
+        } else {
+            throw new IllegalStateException(
+                    sm.getString("abstractHttp11Protocol.invalidAsyncState",
+                            "dispatchAsync()", state));
+        }
+        return doDispatch;
+    }
+    
+    
+    private synchronized void asyncDispatched() {
+        if (state == AsyncState.DISPATCHING) {
+            state = AsyncState.DISPATCHED;
+        } else {
+            throw new IllegalStateException(
+                    sm.getString("abstractHttp11Protocol.invalidAsyncState",
+                            "dispatchAsync()", state));
+        }
+    }
+    
+    
+    private synchronized boolean asyncError() {
+        boolean doDispatch = false;
+        if (state == AsyncState.DISPATCHED ||
+                state == AsyncState.TIMING_OUT) {
+            state = AsyncState.ERROR;
+        } else {
+            throw new IllegalStateException(
+                    sm.getString("abstractHttp11Protocol.invalidAsyncState",
+                            "dispatchAsync()", state));
+        }
+        return doDispatch;
+    }
+    
+    private synchronized void asyncRun(Runnable runnable) {
+        if (state == AsyncState.STARTING || state ==  AsyncState.STARTED) {
+            // Execute the runnable using a container thread from the
+            // Connector's thread pool. Use a wrapper to prevent a memory leak
+            ClassLoader oldCL;
+            if (Constants.IS_SECURITY_ENABLED) {
+                PrivilegedAction<ClassLoader> pa = new PrivilegedGetTccl();
+                oldCL = AccessController.doPrivileged(pa);
+            } else {
+                oldCL = Thread.currentThread().getContextClassLoader();
+            }
+            try {
+                if (Constants.IS_SECURITY_ENABLED) {
+                    PrivilegedAction<Void> pa = new PrivilegedSetTccl(
+                            this.getClass().getClassLoader());
+                    AccessController.doPrivileged(pa);
+                } else {
+                    Thread.currentThread().setContextClassLoader(
+                            this.getClass().getClassLoader());
+                }
+                
+                getExecutor().execute(runnable);
+            } finally {
+                if (Constants.IS_SECURITY_ENABLED) {
+                    PrivilegedAction<Void> pa = new PrivilegedSetTccl(
+                            oldCL);
+                    AccessController.doPrivileged(pa);
+                } else {
+                    Thread.currentThread().setContextClassLoader(oldCL);
+                }
+            }
+        } else {
+            throw new IllegalStateException(
+                    sm.getString("abstractHttp11Protocol.invalidAsyncState",
+                            "runAsync()", state));
+        }
+
+    }
+    
+    private static class PrivilegedSetTccl implements PrivilegedAction<Void> {
+
+        private ClassLoader cl;
+
+        PrivilegedSetTccl(ClassLoader cl) {
+            this.cl = cl;
+        }
+
+        @Override
+        public Void run() {
+            Thread.currentThread().setContextClassLoader(cl);
+            return null;
+        }
+    }
+
+    private static class PrivilegedGetTccl
+            implements PrivilegedAction<ClassLoader> {
+
+        @Override
+        public ClassLoader run() {
+            return Thread.currentThread().getContextClassLoader();
+        }
+    }
 }
diff --git a/java/org/apache/coyote/http11/Constants.java b/java/org/apache/coyote/http11/Constants.java
index ff07a60..46514b4 100644
--- a/java/org/apache/coyote/http11/Constants.java
+++ b/java/org/apache/coyote/http11/Constants.java
@@ -211,5 +211,9 @@ public final class Constants {
      */
     public static final String POST = "POST";
 
-
+    /**
+     * Has security been turned on?
+     */
+    public static final boolean IS_SECURITY_ENABLED =
+        (System.getSecurityManager() != null);
 }
diff --git a/java/org/apache/coyote/http11/Http11AprProcessor.java b/java/org/apache/coyote/http11/Http11AprProcessor.java
index df05c74..ab2ed8c 100644
--- a/java/org/apache/coyote/http11/Http11AprProcessor.java
+++ b/java/org/apache/coyote/http11/Http11AprProcessor.java
@@ -24,7 +24,6 @@ import java.security.cert.CertificateFactory;
 import java.security.cert.X509Certificate;
 import java.util.Locale;
 import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.apache.coyote.ActionCode;
 import org.apache.coyote.ActionHook;
@@ -47,6 +46,7 @@ import org.apache.tomcat.util.net.AbstractEndpoint;
 import org.apache.tomcat.util.net.AbstractEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.net.AprEndpoint;
 import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketWrapper;
 
 
 /**
@@ -124,7 +124,7 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
     /**
      * Socket associated with the current connection.
      */
-    protected long socket = 0;
+    protected SocketWrapper<Long> socket = null;
 
 
     /**
@@ -186,7 +186,7 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
      *
      * @throws IOException error during an I/O operation
      */
-    public SocketState process(long socket)
+    public SocketState process(SocketWrapper<Long> socket)
         throws IOException {
         RequestInfo rp = request.getRequestProcessor();
         rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
@@ -201,13 +201,13 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
 
         // Setting up the socket
         this.socket = socket;
-        inputBuffer.setSocket(socket);
-        outputBuffer.setSocket(socket);
+        long socketRef = socket.getSocket().longValue();
+        inputBuffer.setSocket(socketRef);
+        outputBuffer.setSocket(socketRef);
 
         // Error flag
         error = false;
         comet = false;
-        async = false;
         keepAlive = true;
 
         int keepAliveLeft = maxKeepAliveRequests;
@@ -216,12 +216,12 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
         boolean keptAlive = false;
         boolean openSocket = false;
 
-        while (!error && keepAlive && !comet && !async && !endpoint.isPaused()) {
+        while (!error && keepAlive && !comet && !isAsync() && !endpoint.isPaused()) {
 
             // Parsing the request header
             try {
                 if( !disableUploadTimeout && keptAlive && soTimeout > 0 ) {
-                    Socket.timeoutSet(socket, soTimeout * 1000);
+                    Socket.timeoutSet(socketRef, soTimeout * 1000);
                 }
                 if (!inputBuffer.parseRequestLine(keptAlive)) {
                     // This means that no data is available right now
@@ -229,13 +229,13 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
                     // and the method should return true
                     openSocket = true;
                     // Add the socket to the poller
-                    endpoint.getPoller().add(socket);
+                    endpoint.getPoller().add(socketRef);
                     break;
                 }
                 request.setStartTime(System.currentTimeMillis());
                 keptAlive = true;
                 if (!disableUploadTimeout) {
-                    Socket.timeoutSet(socket, timeout * 1000);
+                    Socket.timeoutSet(socketRef, timeout * 1000);
                 }
                 inputBuffer.parseHeaders();
             } catch (IOException e) {
@@ -296,7 +296,7 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
             }
 
             // Finish the handling of the request
-            if (!comet && !async) {
+            if (!comet && !isAsync()) {
                 // If we know we are closing the connection, don't drain input.
                 // This way uploading a 100GB file doesn't tie up the thread 
                 // if the servlet has rejected it.
@@ -312,7 +312,7 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
             }
             request.updateCounters();
 
-            if (!comet && !async) {
+            if (!comet && !isAsync()) {
                 // Next request
                 inputBuffer.nextRequest();
                 outputBuffer.nextRequest();
@@ -320,7 +320,7 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
             
             // Do sendfile as needed: add socket to sendfile and end
             if (sendfileData != null && !error) {
-                sendfileData.socket = socket;
+                sendfileData.socket = socketRef;
                 sendfileData.keepAlive = keepAlive;
                 if (!endpoint.getSendfile().add(sendfileData)) {
                     openSocket = true;
@@ -335,11 +335,9 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
         rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
 
         if (error || endpoint.isPaused()) {
-            inputBuffer.nextRequest();
-            outputBuffer.nextRequest();
             recycle();
             return SocketState.CLOSED;
-        } else if (comet  || async) {
+        } else if (comet  || isAsync()) {
             return SocketState.LONG;
         } else {
             recycle();
@@ -349,12 +347,14 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
     }
 
     /* Copied from the AjpProcessor.java */
-    public SocketState asyncDispatch(long socket, SocketStatus status) {
+    public SocketState asyncDispatch(SocketWrapper<Long> socket,
+            SocketStatus status) {
 
         // Setting up the socket
         this.socket = socket;
-        inputBuffer.setSocket(socket);
-        outputBuffer.setSocket(socket);
+        long socketRef = socket.getSocket().longValue();
+        inputBuffer.setSocket(socketRef);
+        outputBuffer.setSocket(socketRef);
 
         RequestInfo rp = request.getRequestProcessor();
         try {
@@ -372,30 +372,25 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
 
         rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
 
-        if (async) {
-            if (error) {
-                response.setStatus(500);
-                request.updateCounters();
-                recycle();
+        if (error) {
+            recycle();
+            return SocketState.CLOSED;
+        } else if (isAsync()) {
+            return SocketState.LONG;
+        } else {
+            recycle();
+            if (!keepAlive) {
                 return SocketState.CLOSED;
             } else {
-                return SocketState.LONG;
+                return SocketState.OPEN;
             }
-        } else {
-            if (error) {
-                response.setStatus(500);
-            }
-            request.updateCounters();
-            recycle();
-            return SocketState.CLOSED;
         }
-        
     }
 
 
     @Override
     public void recycleInternal() {
-        this.socket = 0;
+        this.socket = null;
     }
     
 
@@ -411,6 +406,8 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
     @Override
     public void actionInternal(ActionCode actionCode, Object param) {
 
+        long socketRef = socket.getSocket().longValue();
+        
         if (actionCode == ActionCode.CLOSE) {
             // Close
 
@@ -418,7 +415,6 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
             // transactions with the client
 
             comet = false;
-            async = false;
             try {
                 outputBuffer.endRequest();
             } catch (IOException e) {
@@ -429,9 +425,9 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
         } else if (actionCode == ActionCode.REQ_HOST_ADDR_ATTRIBUTE) {
 
             // Get remote host address
-            if (remoteAddr == null && (socket != 0)) {
+            if (remoteAddr == null && (socketRef != 0)) {
                 try {
-                    long sa = Address.get(Socket.APR_REMOTE, socket);
+                    long sa = Address.get(Socket.APR_REMOTE, socketRef);
                     remoteAddr = Address.getip(sa);
                 } catch (Exception e) {
                     log.warn(sm.getString("http11processor.socket.info"), e);
@@ -442,9 +438,9 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
         } else if (actionCode == ActionCode.REQ_LOCAL_NAME_ATTRIBUTE) {
 
             // Get local host name
-            if (localName == null && (socket != 0)) {
+            if (localName == null && (socketRef != 0)) {
                 try {
-                    long sa = Address.get(Socket.APR_LOCAL, socket);
+                    long sa = Address.get(Socket.APR_LOCAL, socketRef);
                     localName = Address.getnameinfo(sa, 0);
                 } catch (Exception e) {
                     log.warn(sm.getString("http11processor.socket.info"), e);
@@ -455,9 +451,9 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
         } else if (actionCode == ActionCode.REQ_HOST_ATTRIBUTE) {
 
             // Get remote host name
-            if (remoteHost == null && (socket != 0)) {
+            if (remoteHost == null && (socketRef != 0)) {
                 try {
-                    long sa = Address.get(Socket.APR_REMOTE, socket);
+                    long sa = Address.get(Socket.APR_REMOTE, socketRef);
                     remoteHost = Address.getnameinfo(sa, 0);
                 } catch (Exception e) {
                     log.warn(sm.getString("http11processor.socket.info"), e);
@@ -468,9 +464,9 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
         } else if (actionCode == ActionCode.REQ_LOCAL_ADDR_ATTRIBUTE) {
 
             // Get local host address
-            if (localAddr == null && (socket != 0)) {
+            if (localAddr == null && (socketRef != 0)) {
                 try {
-                    long sa = Address.get(Socket.APR_LOCAL, socket);
+                    long sa = Address.get(Socket.APR_LOCAL, socketRef);
                     localAddr = Address.getip(sa);
                 } catch (Exception e) {
                     log.warn(sm.getString("http11processor.socket.info"), e);
@@ -482,9 +478,9 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
         } else if (actionCode == ActionCode.REQ_REMOTEPORT_ATTRIBUTE) {
 
             // Get remote port
-            if (remotePort == -1 && (socket != 0)) {
+            if (remotePort == -1 && (socketRef != 0)) {
                 try {
-                    long sa = Address.get(Socket.APR_REMOTE, socket);
+                    long sa = Address.get(Socket.APR_REMOTE, socketRef);
                     Sockaddr addr = Address.getInfo(sa);
                     remotePort = addr.port;
                 } catch (Exception e) {
@@ -496,9 +492,9 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
         } else if (actionCode == ActionCode.REQ_LOCALPORT_ATTRIBUTE) {
 
             // Get local port
-            if (localPort == -1 && (socket != 0)) {
+            if (localPort == -1 && (socketRef != 0)) {
                 try {
-                    long sa = Address.get(Socket.APR_LOCAL, socket);
+                    long sa = Address.get(Socket.APR_LOCAL, socketRef);
                     Sockaddr addr = Address.getInfo(sa);
                     localPort = addr.port;
                 } catch (Exception e) {
@@ -509,24 +505,24 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
 
         } else if (actionCode == ActionCode.REQ_SSL_ATTRIBUTE ) {
 
-            if (ssl && (socket != 0)) {
+            if (ssl && (socketRef != 0)) {
                 try {
                     // Cipher suite
-                    Object sslO = SSLSocket.getInfoS(socket, SSL.SSL_INFO_CIPHER);
+                    Object sslO = SSLSocket.getInfoS(socketRef, SSL.SSL_INFO_CIPHER);
                     if (sslO != null) {
                         request.setAttribute(AbstractEndpoint.CIPHER_SUITE_KEY, sslO);
                     }
                     // Get client certificate and the certificate chain if present
                     // certLength == -1 indicates an error
-                    int certLength = SSLSocket.getInfoI(socket, SSL.SSL_INFO_CLIENT_CERT_CHAIN);
-                    byte[] clientCert = SSLSocket.getInfoB(socket, SSL.SSL_INFO_CLIENT_CERT);
+                    int certLength = SSLSocket.getInfoI(socketRef, SSL.SSL_INFO_CLIENT_CERT_CHAIN);
+                    byte[] clientCert = SSLSocket.getInfoB(socketRef, SSL.SSL_INFO_CLIENT_CERT);
                     X509Certificate[] certs = null;
                     if (clientCert != null  && certLength > -1) {
                         certs = new X509Certificate[certLength + 1];
                         CertificateFactory cf = CertificateFactory.getInstance("X.509");
                         certs[0] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(clientCert));
                         for (int i = 0; i < certLength; i++) {
-                            byte[] data = SSLSocket.getInfoB(socket, SSL.SSL_INFO_CLIENT_CERT_CHAIN + i);
+                            byte[] data = SSLSocket.getInfoB(socketRef, SSL.SSL_INFO_CLIENT_CERT_CHAIN + i);
                             certs[i+1] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(data));
                         }
                     }
@@ -534,12 +530,12 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
                         request.setAttribute(AbstractEndpoint.CERTIFICATE_KEY, certs);
                     }
                     // User key size
-                    sslO = Integer.valueOf(SSLSocket.getInfoI(socket,
+                    sslO = Integer.valueOf(SSLSocket.getInfoI(socketRef,
                             SSL.SSL_INFO_CIPHER_USEKEYSIZE));
                     request.setAttribute(AbstractEndpoint.KEY_SIZE_KEY, sslO);
 
                     // SSL session ID
-                    sslO = SSLSocket.getInfoS(socket, SSL.SSL_INFO_SESSION_ID);
+                    sslO = SSLSocket.getInfoS(socketRef, SSL.SSL_INFO_SESSION_ID);
                     if (sslO != null) {
                         request.setAttribute(AbstractEndpoint.SESSION_ID_KEY, sslO);
                     }
@@ -552,7 +548,7 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
 
         } else if (actionCode == ActionCode.REQ_SSL_CERTIFICATE) {
 
-            if (ssl && (socket != 0)) {
+            if (ssl && (socketRef != 0)) {
                 // Consume and buffer the request body, so that it does not
                 // interfere with the client's handshake messages
                 InputFilter[] inputFilters = inputBuffer.getFilters();
@@ -560,22 +556,22 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
                 inputBuffer.addActiveFilter(inputFilters[Constants.BUFFERED_FILTER]);
                 try {
                     // Configure connection to require a certificate
-                    SSLSocket.setVerify(socket, SSL.SSL_CVERIFY_REQUIRE,
+                    SSLSocket.setVerify(socketRef, SSL.SSL_CVERIFY_REQUIRE,
                             endpoint.getSSLVerifyDepth());
                     // Renegotiate certificates
-                    if (SSLSocket.renegotiate(socket) == 0) {
+                    if (SSLSocket.renegotiate(socketRef) == 0) {
                         // Don't look for certs unless we know renegotiation worked.
                         // Get client certificate and the certificate chain if present
                         // certLength == -1 indicates an error 
-                        int certLength = SSLSocket.getInfoI(socket,SSL.SSL_INFO_CLIENT_CERT_CHAIN);
-                        byte[] clientCert = SSLSocket.getInfoB(socket, SSL.SSL_INFO_CLIENT_CERT);
+                        int certLength = SSLSocket.getInfoI(socketRef,SSL.SSL_INFO_CLIENT_CERT_CHAIN);
+                        byte[] clientCert = SSLSocket.getInfoB(socketRef, SSL.SSL_INFO_CLIENT_CERT);
                         X509Certificate[] certs = null;
                         if (clientCert != null && certLength > -1) {
                             certs = new X509Certificate[certLength + 1];
                             CertificateFactory cf = CertificateFactory.getInstance("X.509");
                             certs[0] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(clientCert));
                             for (int i = 0; i < certLength; i++) {
-                                byte[] data = SSLSocket.getInfoB(socket, SSL.SSL_INFO_CLIENT_CERT_CHAIN + i);
+                                byte[] data = SSLSocket.getInfoB(socketRef, SSL.SSL_INFO_CLIENT_CERT_CHAIN + i);
                                 certs[i+1] = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(data));
                             }
                         }
@@ -599,29 +595,16 @@ public class Http11AprProcessor extends AbstractHttp11Processor implements Actio
         } else if (actionCode == ActionCode.COMET_SETTIMEOUT) {
             //no op
         } else if (actionCode == ActionCode.ASYNC_COMPLETE) {
-          //TODO SERVLET3 - async - that is bit hacky -
-            AtomicBoolean dispatch = (AtomicBoolean)param;
-            RequestInfo rp = request.getRequestProcessor();
-            if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) { //async handling
-                dispatch.set(true);
-                endpoint.getHandler().asyncDispatch(this.socket, SocketStatus.STOP);
-            } else {
-                dispatch.set(false);
+            if (asyncComplete()) {
+                endpoint.processSocketAsync(this.socket, SocketStatus.OPEN);
             }
         } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {
-          //TODO SERVLET3 - async
             if (param==null) return;
-            if (socket==0) return;
             long timeout = ((Long)param).longValue();
-            Socket.timeoutSet(socket, timeout * 1000);
+            socket.setTimeout(timeout);
         } else if (actionCode == ActionCode.ASYNC_DISPATCH) {
-            RequestInfo rp = request.getRequestProcessor();
-            AtomicBoolean dispatch = (AtomicBoolean)param;
-            if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) {//async handling
-                endpoint.getPoller().add(this.socket);
-                dispatch.set(true);
-            } else {
-                dispatch.set(true);
+            if (asyncDispatch()) {
+                endpoint.processSocketAsync(this.socket, SocketStatus.OPEN);
             }
         }
         
diff --git a/java/org/apache/coyote/http11/Http11AprProtocol.java b/java/org/apache/coyote/http11/Http11AprProtocol.java
index 583af68..4c4f67b 100644
--- a/java/org/apache/coyote/http11/Http11AprProtocol.java
+++ b/java/org/apache/coyote/http11/Http11AprProtocol.java
@@ -17,6 +17,8 @@
 
 package org.apache.coyote.http11;
 
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -32,6 +34,7 @@ import org.apache.tomcat.util.modeler.Registry;
 import org.apache.tomcat.util.net.AprEndpoint;
 import org.apache.tomcat.util.net.AprEndpoint.Handler;
 import org.apache.tomcat.util.net.SocketStatus;
+import org.apache.tomcat.util.net.SocketWrapper;
 import org.apache.tomcat.util.res.StringManager;
 
 
@@ -246,8 +249,8 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
         protected AtomicLong registerCount = new AtomicLong(0);
         protected RequestGroupInfo global = new RequestGroupInfo();
         
-        protected ConcurrentHashMap<Long, Http11AprProcessor> connections =
-            new ConcurrentHashMap<Long, Http11AprProcessor>();
+        protected ConcurrentHashMap<SocketWrapper<Long>, Http11AprProcessor> connections =
+            new ConcurrentHashMap<SocketWrapper<Long>, Http11AprProcessor>();
         protected ConcurrentLinkedQueue<Http11AprProcessor> recycledProcessors = 
             new ConcurrentLinkedQueue<Http11AprProcessor>() {
             private static final long serialVersionUID = 1L;
@@ -294,8 +297,8 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
         }
 
         @Override
-        public SocketState event(long socket, SocketStatus status) {
-            Http11AprProcessor result = connections.get(Long.valueOf(socket));
+        public SocketState event(SocketWrapper<Long> socket, SocketStatus status) {
+            Http11AprProcessor result = connections.get(socket);
             
             SocketState state = SocketState.CLOSED; 
             if (result != null) {
@@ -324,16 +327,16 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
                                 "http11protocol.proto.error"), e);
                     } finally {
                         if (state != SocketState.LONG) {
-                            connections.remove(Long.valueOf(socket));
+                            connections.remove(socket);
                             recycledProcessors.offer(result);
                             if (state == SocketState.OPEN) {
-                                ((AprEndpoint)proto.endpoint).getPoller().add(socket);
+                                ((AprEndpoint)proto.endpoint).getPoller().add(socket.getSocket().longValue());
                             }
                         } else {
-                            ((AprEndpoint)proto.endpoint).getCometPoller().add(socket);
+                            ((AprEndpoint)proto.endpoint).getCometPoller().add(socket.getSocket().longValue());
                         }
                     }
-                } else if (result.async) {
+                } else if (result.isAsync()) {
                     state = asyncDispatch(socket, status);
                 }
             }
@@ -341,7 +344,7 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
         }
         
         @Override
-        public SocketState process(long socket) {
+        public SocketState process(SocketWrapper<Long> socket) {
             Http11AprProcessor processor = recycledProcessors.poll();
             try {
                 if (processor == null) {
@@ -350,11 +353,13 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
 
                 SocketState state = processor.process(socket);
                 if (state == SocketState.LONG) {
-                    // Associate the connection with the processor. The next request 
-                    // processed by this thread will use either a new or a recycled
-                    // processor.
-                    connections.put(Long.valueOf(socket), processor);
-                    ((AprEndpoint)proto.endpoint).getCometPoller().add(socket);
+                    // Check if the post processing is going to change the state
+                    state = processor.asyncPostProcess();
+                }
+                if (state == SocketState.LONG || state == SocketState.ASYNC_END) {
+                    // Need to make socket available for next processing cycle
+                    // but no need for the poller
+                    connections.put(socket, processor);
                 } else {
                     recycledProcessors.offer(processor);
                 }
@@ -386,8 +391,8 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
         }
 
         @Override
-        public SocketState asyncDispatch(long socket, SocketStatus status) {
-            Http11AprProcessor result = connections.get(Long.valueOf(socket));
+        public SocketState asyncDispatch(SocketWrapper<Long> socket, SocketStatus status) {
+            Http11AprProcessor result = connections.get(socket);
             
             SocketState state = SocketState.CLOSED; 
             if (result != null) {
@@ -404,11 +409,14 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
                     Http11AprProtocol.log.error
                         (sm.getString("http11protocol.proto.error"), e);
                 } finally {
-                    if (state != SocketState.LONG) {
-                        connections.remove(Long.valueOf(socket));
+                    if (state == SocketState.LONG && result.isAsync()) {
+                        state = result.asyncPostProcess();
+                    }
+                    if (state != SocketState.LONG && state != SocketState.ASYNC_END) {
+                        connections.remove(socket);
                         recycledProcessors.offer(result);
                         if (state == SocketState.OPEN) {
-                            ((AprEndpoint)proto.endpoint).getPoller().add(socket);
+                            ((AprEndpoint)proto.endpoint).getPoller().add(socket.getSocket().longValue());
                         }
                     }
                 }
@@ -440,15 +448,29 @@ public class Http11AprProtocol extends AbstractHttp11Protocol {
                 synchronized (this) {
                     try {
                         long count = registerCount.incrementAndGet();
-                        RequestInfo rp = processor.getRequest().getRequestProcessor();
+                        final RequestInfo rp = processor.getRequest().getRequestProcessor();
                         rp.setGlobalProcessor(global);
-                        ObjectName rpName = new ObjectName
+                        final ObjectName rpName = new ObjectName
                             (proto.getDomain() + ":type=RequestProcessor,worker="
                                 + proto.getName() + ",name=HttpRequest" + count);
                         if (log.isDebugEnabled()) {
                             log.debug("Register " + rpName);
                         }
-                        Registry.getRegistry(null, null).registerComponent(rp, rpName, null);
+                        if (Constants.IS_SECURITY_ENABLED) {
+                            AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                                @Override
+                                public Void run() {
+                                    try {
+                                        Registry.getRegistry(null, null).registerComponent(rp, rpName, null);
+                                    } catch (Exception e) {
+                                        log.warn("Error registering request");
+                                    }
+                                    return null;
+                                }
+                            });
+                        } else {
+                            Registry.getRegistry(null, null).registerComponent(rp, rpName, null);
+                        }
                         rp.setRpName(rpName);
                     } catch (Exception e) {
                         log.warn("Error registering request");
diff --git a/java/org/apache/coyote/http11/Http11NioProcessor.java b/java/org/apache/coyote/http11/Http11NioProcessor.java
index 02ed557..ded2153 100644
--- a/java/org/apache/coyote/http11/Http11NioProcessor.java
+++ b/java/org/apache/coyote/http11/Http11NioProcessor.java
@@ -22,7 +22,6 @@ import java.net.InetAddress;
 import java.nio.channels.SelectionKey;
 import java.util.Locale;
 import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.apache.coyote.ActionCode;
 import org.apache.coyote.ActionHook;
@@ -236,11 +235,13 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
                         Integer comettimeout = (Integer) request.getAttribute("org.apache.tomcat.comet.timeout");
                         if (comettimeout != null) attach.setTimeout(comettimeout.longValue());
                     } else {
-                        //reset the timeout
-                        if (keepAlive && keepAliveTimeout>0) {
-                            attach.setTimeout(keepAliveTimeout);
-                        } else {
-                            attach.setTimeout(soTimeout);
+                        if (isAsyncDispatching()) {
+                            //reset the timeout
+                            if (keepAlive && keepAliveTimeout>0) {
+                                attach.setTimeout(keepAliveTimeout);
+                            } else {
+                                attach.setTimeout(soTimeout);
+                            }
                         }
                     }
 
@@ -261,7 +262,7 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
         if (error) {
             recycle();
             return SocketState.CLOSED;
-        } else if (!comet) {
+        } else if (!comet && !isAsync()) {
             recycle();
             return (keepAlive)?SocketState.OPEN:SocketState.CLOSED;
         } else {
@@ -291,7 +292,6 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
         error = false;
         keepAlive = true;
         comet = false;
-        async = false;
         
         long soTimeout = endpoint.getSoTimeout();
         int keepAliveTimeout = endpoint.getKeepAliveTimeout();
@@ -301,7 +301,7 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
         boolean recycle = true;
         final KeyAttachment ka = (KeyAttachment)socket.getAttachment(false);
         
-        while (!error && keepAlive && !comet && !async && !endpoint.isPaused()) {
+        while (!error && keepAlive && !comet && !isAsync() && !endpoint.isPaused()) {
             //always default to our soTimeout
             ka.setTimeout(soTimeout);
             // Parsing the request header
@@ -412,7 +412,7 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
             }
 
             // Finish the handling of the request
-            if (!comet && !async) {
+            if (!comet && !isAsync()) {
                 // If we know we are closing the connection, don't drain input.
                 // This way uploading a 100GB file doesn't tie up the thread 
                 // if the servlet has rejected it.
@@ -428,7 +428,7 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
             }
             request.updateCounters();
 
-            if (!comet && !async) {
+            if (!comet && !isAsync()) {
                 // Next request
                 inputBuffer.nextRequest();
                 outputBuffer.nextRequest();
@@ -453,7 +453,7 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
         if (error || endpoint.isPaused()) {
             recycle();
             return SocketState.CLOSED;
-        } else if (comet || async) {
+        } else if (comet || isAsync()) {
             return SocketState.LONG;
         } else {
             if (recycle) {
@@ -494,13 +494,11 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
 
         if (actionCode == ActionCode.CLOSE) {
             // Close
-
             // End the processing of the current request, and stop any further
             // transactions with the client
 
             comet = false;
             cometClose = true;
-            async = false;
             SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());
             if ( key != null ) {
                 NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment) key.attachment();
@@ -654,17 +652,10 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
             if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) //async handling
                 attach.setTimeout(timeout);
         } else if (actionCode == ActionCode.ASYNC_COMPLETE) {
-          //TODO SERVLET3 - async
-            AtomicBoolean dispatch = (AtomicBoolean)param;
-            RequestInfo rp = request.getRequestProcessor();
-            if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) { //async handling
-                dispatch.set(true);
-                endpoint.processSocket(this.socket, SocketStatus.STOP, true);
-            } else {
-                dispatch.set(false);
+            if (asyncComplete()) {
+                endpoint.processSocket(this.socket, SocketStatus.OPEN, true);
             }
         } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {
-          //TODO SERVLET3 - async
             if (param==null) return;
             if (socket==null || socket.getAttachment(false)==null) return;
             NioEndpoint.KeyAttachment attach = (NioEndpoint.KeyAttachment)socket.getAttachment(false);
@@ -672,13 +663,8 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
             //if we are not piggy backing on a worker thread, set the timeout
             attach.setTimeout(timeout);
         } else if (actionCode == ActionCode.ASYNC_DISPATCH) {
-            RequestInfo rp = request.getRequestProcessor();
-            AtomicBoolean dispatch = (AtomicBoolean)param;
-            if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) {//async handling
+            if (asyncDispatch()) {
                 endpoint.processSocket(this.socket, SocketStatus.OPEN, true);
-                dispatch.set(true);
-            } else { 
-                dispatch.set(true);
             }
         }
     }
diff --git a/java/org/apache/coyote/http11/Http11NioProtocol.java b/java/org/apache/coyote/http11/Http11NioProtocol.java
index bf1f60e..5acc5ae 100644
--- a/java/org/apache/coyote/http11/Http11NioProtocol.java
+++ b/java/org/apache/coyote/http11/Http11NioProtocol.java
@@ -18,6 +18,8 @@
 package org.apache.coyote.http11;
 
 import java.nio.channels.SocketChannel;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Iterator;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentLinkedQueue;
@@ -288,18 +290,18 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
 
         @Override
         public SocketState event(NioChannel socket, SocketStatus status) {
-            Http11NioProcessor result = connections.get(socket);
+            Http11NioProcessor processor = connections.get(socket);
             NioEndpoint.KeyAttachment att = (NioEndpoint.KeyAttachment)socket.getAttachment(false);
             att.setAsync(false); //no longer check for timeout
             SocketState state = SocketState.CLOSED; 
-            if (result != null) {
-                if (log.isDebugEnabled()) log.debug("Http11NioProcessor.error="+result.error);
+            if (processor != null) {
+                if (log.isDebugEnabled()) log.debug("Http11NioProcessor.error="+processor.error);
                 // Call the appropriate event
                 try {
-                    if (result.async) {
-                        state = result.asyncDispatch(status);
+                    if (processor.comet) {
+                        state = processor.event(status);
                     } else {
-                        state = result.event(status);
+                        state = processor.asyncDispatch(status);
                     }
                 } catch (java.net.SocketException e) {
                     // SocketExceptions are normal
@@ -322,14 +324,21 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
                     Http11NioProtocol.log.error
                         (sm.getString("http11protocol.proto.error"), e);
                 } finally {
-                    if (state != SocketState.LONG) {
+                    if (processor.isAsync()) {
+                        state = processor.asyncPostProcess();
+                    }
+                    if (state != SocketState.LONG && state != SocketState.ASYNC_END) {
                         connections.remove(socket);
-                        recycledProcessors.offer(result);
+                        recycledProcessors.offer(processor);
                         if (state == SocketState.OPEN) {
                             socket.getPoller().add(socket);
                         }
+                    } else if (state == SocketState.ASYNC_END) {
+                        // No further work required
+                    } else if (state == SocketState.LONG) {
+                        att.setAsync(true); // Re-enable timeouts
                     } else {
-                        if (log.isDebugEnabled()) log.debug("Keeping processor["+result);
+                        if (log.isDebugEnabled()) log.debug("Keeping processor["+processor);
                         //add correct poller events here based on Comet stuff
                         socket.getPoller().add(socket,att.getCometOps());
                     }
@@ -369,12 +378,18 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
                     if (processor.comet) {
                         NioEndpoint.KeyAttachment att = (NioEndpoint.KeyAttachment)socket.getAttachment(false);
                         socket.getPoller().add(socket,att.getCometOps());
-                    } else if (processor.async) {
+                    } else if (processor.isAsync()) {
                         NioEndpoint.KeyAttachment att = (NioEndpoint.KeyAttachment)socket.getAttachment(false);
                         att.setAsync(true);
+                        // longPoll may change socket state (e.g. to trigger a
+                        // complete or dispatch)
+                        state = processor.asyncPostProcess();
                     } else {
                         socket.getPoller().add(socket);
                     }
+                }
+                if (state == SocketState.LONG || state == SocketState.ASYNC_END) {
+                    // Already done all we need to do.
                 } else if (state == SocketState.OPEN){
                     // In keep-alive but between requests. OK to recycle
                     // processor. Continue to poll for the next request.
@@ -434,12 +449,26 @@ public class Http11NioProtocol extends AbstractHttp11JsseProtocol {
                     try {
                         registerCount.addAndGet(1);
                         if (log.isDebugEnabled()) log.debug("Register ["+processor+"] count="+registerCount.get());
-                        RequestInfo rp = processor.getRequest().getRequestProcessor();
+                        final RequestInfo rp = processor.getRequest().getRequestProcessor();
                         rp.setGlobalProcessor(global);
-                        ObjectName rpName = new ObjectName
+                        final ObjectName rpName = new ObjectName
                             (proto.getDomain() + ":type=RequestProcessor,worker="
                              + proto.getName() + ",name=HttpRequest" + count++);
-                        Registry.getRegistry(null, null).registerComponent(rp, rpName, null);
+                        if (Constants.IS_SECURITY_ENABLED) {
+                            AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                                @Override
+                                public Void run() {
+                                    try {
+                                        Registry.getRegistry(null, null).registerComponent(rp, rpName, null);
+                                    } catch (Exception e) {
+                                        log.warn("Error registering request");
+                                    }
+                                    return null;
+                                }
+                            });
+                        } else {
+                            Registry.getRegistry(null, null).registerComponent(rp, rpName, null);
+                        }
                         rp.setRpName(rpName);
                     } catch (Exception e) {
                         log.warn("Error registering request");
diff --git a/java/org/apache/coyote/http11/Http11Processor.java b/java/org/apache/coyote/http11/Http11Processor.java
index 6e59e1a..9758396 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -23,7 +23,6 @@ import java.net.InetAddress;
 import java.net.Socket;
 import java.util.Locale;
 import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.apache.coyote.ActionCode;
 import org.apache.coyote.ActionHook;
@@ -265,9 +264,9 @@ public class Http11Processor extends AbstractHttp11Processor implements ActionHo
                 // This way uploading a 100GB file doesn't tie up the thread 
                 // if the servlet has rejected it.
                 
-                if(error && !async)
+                if(error && !isAsync())
                     inputBuffer.setSwallowInput(false);
-                if (!async)
+                if (!isAsync())
                     endRequest();
             } catch (Throwable t) {
                 log.error(sm.getString("http11processor.request.finish"), t);
@@ -296,7 +295,7 @@ public class Http11Processor extends AbstractHttp11Processor implements ActionHo
             // will reset it
             // thrA.setParam(null);
             // Next request
-            if (!async || error) {
+            if (!isAsync() || error) {
                 inputBuffer.nextRequest();
                 outputBuffer.nextRequest();
             }
@@ -309,7 +308,7 @@ public class Http11Processor extends AbstractHttp11Processor implements ActionHo
         if (error || endpoint.isPaused()) {
             recycle();
             return SocketState.CLOSED;
-        } else if (async) {
+        } else if (isAsync()) {
             return SocketState.LONG;
         } else {
             if (!keepAlive) {
@@ -343,7 +342,7 @@ public class Http11Processor extends AbstractHttp11Processor implements ActionHo
         if (error) {
             recycle();
             return SocketState.CLOSED;
-        } else if (async) {
+        } else if (isAsync()) {
             return SocketState.LONG;
         } else {
             recycle();
@@ -360,7 +359,6 @@ public class Http11Processor extends AbstractHttp11Processor implements ActionHo
     protected void recycleInternal() {
         // Recycle
         this.socket = null;
-        async = false;
         // Recycle ssl info
         sslSupport = null;
     }
@@ -380,7 +378,6 @@ public class Http11Processor extends AbstractHttp11Processor implements ActionHo
 
         if (actionCode == ActionCode.CLOSE) {
             // Close
-            async = false;
             // End the processing of the current request, and stop any further
             // transactions with the client
 
@@ -497,33 +494,19 @@ public class Http11Processor extends AbstractHttp11Processor implements ActionHo
                 }
             }
         } else if (actionCode == ActionCode.ASYNC_COMPLETE) {
-            //TODO SERVLET3 - async
-            AtomicBoolean dispatch = (AtomicBoolean)param;
-            RequestInfo rp = request.getRequestProcessor();
-            if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) { //async handling
-                dispatch.set(true);
+            if (asyncComplete()) {
                 endpoint.processSocketAsync(this.socket, SocketStatus.OPEN);
-            } else {
-                dispatch.set(false);
             }
         } else if (actionCode == ActionCode.ASYNC_SETTIMEOUT) {
-          //TODO SERVLET3 - async
-            if (param==null) return;
+            if (param == null) return;
             long timeout = ((Long)param).longValue();
-            //if we are not piggy backing on a worker thread, set the timeout
+            // if we are not piggy backing on a worker thread, set the timeout
             socket.setTimeout(timeout);
         } else if (actionCode == ActionCode.ASYNC_DISPATCH) {
-            RequestInfo rp = request.getRequestProcessor();
-            AtomicBoolean dispatch = (AtomicBoolean)param;
-            if ( rp.getStage() != org.apache.coyote.Constants.STAGE_SERVICE ) {//async handling
+            if (asyncDispatch()) {
                 endpoint.processSocketAsync(this.socket, SocketStatus.OPEN);
-                dispatch.set(true);
-            } else { 
-                dispatch.set(true);
             }
         }
-
-
     }
 
 
diff --git a/java/org/apache/coyote/http11/Http11Protocol.java b/java/org/apache/coyote/http11/Http11Protocol.java
index cf2fba3..e99eccd 100644
--- a/java/org/apache/coyote/http11/Http11Protocol.java
+++ b/java/org/apache/coyote/http11/Http11Protocol.java
@@ -17,7 +17,10 @@
 
 package org.apache.coyote.http11;
 
+import java.io.IOException;
 import java.net.Socket;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Iterator;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentLinkedQueue;
@@ -257,6 +260,9 @@ public class Http11Protocol extends AbstractHttp11JsseProtocol {
                 if (state == SocketState.LONG) {
                     connections.put(socket, processor);
                     socket.setAsync(true);
+                    // longPoll may change socket state (e.g. to trigger a
+                    // complete or dispatch)
+                    return processor.asyncPostProcess();
                 } else {
                     connections.remove(socket);
                     socket.setAsync(false);
@@ -310,15 +316,29 @@ public class Http11Protocol extends AbstractHttp11JsseProtocol {
                 synchronized (this) {
                     try {
                         long count = registerCount.incrementAndGet();
-                        RequestInfo rp = processor.getRequest().getRequestProcessor();
+                        final RequestInfo rp = processor.getRequest().getRequestProcessor();
                         rp.setGlobalProcessor(global);
-                        ObjectName rpName = new ObjectName
+                        final ObjectName rpName = new ObjectName
                             (proto.getDomain() + ":type=RequestProcessor,worker="
                                 + proto.getName() + ",name=HttpRequest" + count);
                         if (log.isDebugEnabled()) {
                             log.debug("Register " + rpName);
                         }
-                        Registry.getRegistry(null, null).registerComponent(rp, rpName, null);
+                        if (Constants.IS_SECURITY_ENABLED) {
+                            AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                                @Override
+                                public Void run() {
+                                    try {
+                                        Registry.getRegistry(null, null).registerComponent(rp, rpName, null);
+                                    } catch (Exception e) {
+                                        log.warn("Error registering request");
+                                    }
+                                    return null;
+                                }
+                            });
+                        } else {
+                            Registry.getRegistry(null, null).registerComponent(rp, rpName, null);
+                        }
                         rp.setRpName(rpName);
                     } catch (Exception e) {
                         log.warn("Error registering request");
diff --git a/java/org/apache/coyote/http11/LocalStrings.properties b/java/org/apache/coyote/http11/LocalStrings.properties
index 298c66e..22b2a03 100644
--- a/java/org/apache/coyote/http11/LocalStrings.properties
+++ b/java/org/apache/coyote/http11/LocalStrings.properties
@@ -13,6 +13,8 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+abstractHttp11Protocol.invalidAsyncState=Calling [{0}] is not valid for a request with Async state [{1}]
+
 http11protocol.destroy=Destroying Coyote HTTP/1.1 on {0}
 http11protocol.endpoint.initerror=Error initializing endpoint
 http11protocol.endpoint.starterror=Error starting endpoint
diff --git a/java/org/apache/tomcat/util/net/AbstractEndpoint.java b/java/org/apache/tomcat/util/net/AbstractEndpoint.java
index 917a6d4..8b936a9 100644
--- a/java/org/apache/tomcat/util/net/AbstractEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AbstractEndpoint.java
@@ -78,7 +78,7 @@ public abstract class AbstractEndpoint {
      */
     public static interface Handler {
         public enum SocketState {
-            OPEN, CLOSED, LONG
+            OPEN, CLOSED, LONG, ASYNC_END
         }
     }
     
diff --git a/java/org/apache/tomcat/util/net/AprEndpoint.java b/java/org/apache/tomcat/util/net/AprEndpoint.java
index fcb9dde..93a4458 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -21,6 +21,8 @@ import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.Iterator;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.RejectedExecutionException;
 
 import org.apache.juli.logging.Log;
@@ -93,6 +95,9 @@ public class AprEndpoint extends AbstractEndpoint {
     private Acceptor acceptors[] = null;
 
 
+    protected ConcurrentLinkedQueue<SocketWrapper<Long>> waitingRequests =
+        new ConcurrentLinkedQueue<SocketWrapper<Long>>();
+    
     // ------------------------------------------------------------- Properties
 
 
@@ -101,6 +106,7 @@ public class AprEndpoint extends AbstractEndpoint {
      */
     protected boolean deferAccept = true;
     public void setDeferAccept(boolean deferAccept) { this.deferAccept = deferAccept; }
+    @Override
     public boolean getDeferAccept() { return deferAccept; }
 
 
@@ -142,6 +148,7 @@ public class AprEndpoint extends AbstractEndpoint {
      */
     protected boolean useSendfile = Library.APR_HAS_SENDFILE;
     public void setUseSendfile(boolean useSendfile) { this.useSendfile = useSendfile; }
+    @Override
     public boolean getUseSendfile() { return useSendfile; }
 
 
@@ -580,6 +587,12 @@ public class AprEndpoint extends AbstractEndpoint {
                 acceptors[i].start();
             }
 
+            // Start async timeout thread
+            Thread timeoutThread = new Thread(new AsyncTimeout(),
+                    getName() + "-AsyncTimeout");
+            timeoutThread.setPriority(threadPriority);
+            timeoutThread.setDaemon(true);
+            timeoutThread.start();
         }
     }
 
@@ -587,6 +600,7 @@ public class AprEndpoint extends AbstractEndpoint {
     /**
      * Stop the endpoint. This will cause all processing threads to stop.
      */
+    @Override
     public void stop() {
         if (!paused) {
             pause();
@@ -748,7 +762,9 @@ public class AprEndpoint extends AbstractEndpoint {
         try {
             // During shutdown, executor may be null - avoid NPE
             if (running) {
-                getExecutor().execute(new SocketWithOptionsProcessor(socket));
+                SocketWrapper<Long> wrapper =
+                    new SocketWrapper<Long>(Long.valueOf(socket));
+                getExecutor().execute(new SocketWithOptionsProcessor(wrapper));
             }
         } catch (RejectedExecutionException x) {
             log.warn("Socket processing request was rejected for:"+socket,x);
@@ -768,7 +784,9 @@ public class AprEndpoint extends AbstractEndpoint {
      */
     protected boolean processSocket(long socket) {
         try {
-            getExecutor().execute(new SocketProcessor(socket));
+            SocketWrapper<Long> wrapper =
+                new SocketWrapper<Long>(Long.valueOf(socket));
+            getExecutor().execute(new SocketProcessor(wrapper, null));
         } catch (RejectedExecutionException x) {
             log.warn("Socket processing request was rejected for:"+socket,x);
             return false;
@@ -789,8 +807,10 @@ public class AprEndpoint extends AbstractEndpoint {
         try {
             if (status == SocketStatus.OPEN || status == SocketStatus.STOP ||
                     status == SocketStatus.TIMEOUT) {
+                SocketWrapper<Long> wrapper =
+                    new SocketWrapper<Long>(Long.valueOf(socket));
                 SocketEventProcessor proc =
-                    new SocketEventProcessor(socket, status);
+                    new SocketEventProcessor(wrapper, status);
                 ClassLoader loader = Thread.currentThread().getContextClassLoader();
                 try {
                     if (IS_SECURITY_ENABLED) {
@@ -822,6 +842,45 @@ public class AprEndpoint extends AbstractEndpoint {
         return true;
     }
 
+    public boolean processSocketAsync(SocketWrapper<Long> socket,
+            SocketStatus status) {
+        try {
+            synchronized (socket) {
+                if (waitingRequests.remove(socket)) {
+                    SocketProcessor proc = new SocketProcessor(socket, status);
+                    ClassLoader loader = Thread.currentThread().getContextClassLoader();
+                    try {
+                        if (IS_SECURITY_ENABLED) {
+                            PrivilegedAction<Void> pa = new PrivilegedSetTccl(
+                                    getClass().getClassLoader());
+                            AccessController.doPrivileged(pa);
+                        } else {
+                            Thread.currentThread().setContextClassLoader(
+                                    getClass().getClassLoader());
+                        }
+                        getExecutor().execute(proc);
+                    } finally {
+                        if (IS_SECURITY_ENABLED) {
+                            PrivilegedAction<Void> pa = new PrivilegedSetTccl(loader);
+                            AccessController.doPrivileged(pa);
+                        } else {
+                            Thread.currentThread().setContextClassLoader(loader);
+                        }
+                    }
+                }
+            }
+        } catch (RejectedExecutionException x) {
+            log.warn("Socket processing request was rejected for:"+socket,x);
+            return false;
+        } catch (Throwable t) {
+            // This means we got an OOM or similar creating a thread, or that
+            // the pool and its queue are full
+            log.error(sm.getString("endpoint.process.fail"), t);
+            return false;
+        }
+        return true;
+    }
+
     private void destroySocket(long socket)
     {
         if (running && socket != 0) {
@@ -898,9 +957,50 @@ public class AprEndpoint extends AbstractEndpoint {
     }
 
 
-    // ----------------------------------------------------- Poller Inner Class
-
+    /**
+     * Async timeout thread
+     */
+    protected class AsyncTimeout implements Runnable {
+        /**
+         * The background thread that checks async requests and fires the
+         * timeout if there has been no activity.
+         */
+        @Override
+        public void run() {
 
+            // Loop until we receive a shutdown command
+            while (running) {
+                try {
+                    Thread.sleep(1000);
+                } catch (InterruptedException e) {
+                    // Ignore
+                }
+                long now = System.currentTimeMillis();
+                Iterator<SocketWrapper<Long>> sockets =
+                    waitingRequests.iterator();
+                while (sockets.hasNext()) {
+                    SocketWrapper<Long> socket = sockets.next();
+                    long access = socket.getLastAccess();
+                    if ((now-access)>socket.getTimeout()) {
+                        processSocketAsync(socket,SocketStatus.TIMEOUT);
+                    }
+                }
+                
+                // Loop if endpoint is paused
+                while (paused && running) {
+                    try {
+                        Thread.sleep(1000);
+                    } catch (InterruptedException e) {
+                        // Ignore
+                    }
+                }
+                
+            }
+        }
+    }
+    
+    
+    // ----------------------------------------------------- Poller Inner Class
     /**
      * Poller class.
      */
@@ -951,6 +1051,7 @@ public class AprEndpoint extends AbstractEndpoint {
         /**
          * Destroy the poller.
          */
+        @Override
         public void destroy() {
             // Close all sockets in the add queue
             for (int i = 0; i < addCount; i++) {
@@ -1015,6 +1116,7 @@ public class AprEndpoint extends AbstractEndpoint {
          * The background thread that listens for incoming TCP/IP connections and
          * hands them off to an appropriate processor.
          */
+        @Override
         public void run() {
 
             long maintainTime = 0;
@@ -1212,6 +1314,7 @@ public class AprEndpoint extends AbstractEndpoint {
         /**
          * Destroy the poller.
          */
+        @Override
         public void destroy() {
             // Close any socket remaining in the add queue
             addCount = 0;
@@ -1314,6 +1417,7 @@ public class AprEndpoint extends AbstractEndpoint {
          * The background thread that listens for incoming TCP/IP connections and
          * hands them off to an appropriate processor.
          */
+        @Override
         public void run() {
 
             long maintainTime = 0;
@@ -1478,15 +1582,16 @@ public class AprEndpoint extends AbstractEndpoint {
      * thread local fields.
      */
     public interface Handler extends AbstractEndpoint.Handler {
-        public SocketState process(long socket);
-        public SocketState event(long socket, SocketStatus status);
-        public SocketState asyncDispatch(long socket, SocketStatus status);
+        public SocketState process(SocketWrapper<Long> socket);
+        public SocketState event(SocketWrapper<Long> socket,
+                SocketStatus status);
+        public SocketState asyncDispatch(SocketWrapper<Long> socket,
+                SocketStatus status);
     }
 
 
     // ---------------------------------------------- SocketProcessor Inner Class
 
-
     /**
      * This class is the equivalent of the Worker, but will simply use in an
      * external Executor thread pool. This will also set the socket options
@@ -1494,29 +1599,32 @@ public class AprEndpoint extends AbstractEndpoint {
      */
     protected class SocketWithOptionsProcessor implements Runnable {
 
-        protected long socket = 0;
+        protected SocketWrapper<Long> socket = null;
 
-        public SocketWithOptionsProcessor(long socket) {
+        public SocketWithOptionsProcessor(SocketWrapper<Long> socket) {
             this.socket = socket;
         }
 
+        @Override
         public void run() {
 
-            if (!deferAccept) {
-                if (setSocketOptions(socket)) {
-                    getPoller().add(socket);
+            synchronized (socket) {
+                if (!deferAccept) {
+                    if (setSocketOptions(socket.getSocket().longValue())) {
+                        getPoller().add(socket.getSocket().longValue());
+                    } else {
+                        // Close socket and pool
+                        destroySocket(socket.getSocket().longValue());
+                        socket = null;
+                    }
                 } else {
-                    // Close socket and pool
-                    destroySocket(socket);
-                    socket = 0;
-                }
-            } else {
-                // Process the request from this socket
-                if (!setSocketOptions(socket)
-                        || handler.process(socket) == Handler.SocketState.CLOSED) {
-                    // Close socket and pool
-                    destroySocket(socket);
-                    socket = 0;
+                    // Process the request from this socket
+                    if (!setSocketOptions(socket.getSocket().longValue())
+                            || handler.process(socket) == Handler.SocketState.CLOSED) {
+                        // Close socket and pool
+                        destroySocket(socket.getSocket().longValue());
+                        socket = null;
+                    }
                 }
             }
 
@@ -1534,27 +1642,34 @@ public class AprEndpoint extends AbstractEndpoint {
      */
     protected class SocketProcessor implements Runnable {
 
-        protected long socket = 0;
-        protected boolean async = false;
-        protected SocketStatus status = SocketStatus.ERROR;
+        protected SocketWrapper<Long> socket = null;
+        protected SocketStatus status = null;
 
-        public SocketProcessor(long socket) {
+        public SocketProcessor(SocketWrapper<Long> socket,
+                SocketStatus status) {
             this.socket = socket;
-            this.async = false;
+            this.status = status;
         }
 
+        @Override
         public void run() {
-
-            // Process the request from this socket
-            Handler.SocketState state = async?handler.asyncDispatch(socket, status):handler.process(socket);
-            if (state == Handler.SocketState.CLOSED) {
-                // Close socket and pool
-                destroySocket(socket);
-                socket = 0;
+            synchronized (socket) {
+                // Process the request from this socket
+                Handler.SocketState state = (status==null)?handler.process(socket):handler.asyncDispatch(socket, status);
+                if (state == Handler.SocketState.CLOSED) {
+                    // Close socket and pool
+                    destroySocket(socket.getSocket().longValue());
+                    socket = null;
+                } else if (state == Handler.SocketState.LONG) {
+                    socket.access();
+                    waitingRequests.add(socket);
+                } else if (state == Handler.SocketState.ASYNC_END) {
+                    socket.access();
+                    SocketProcessor proc = new SocketProcessor(socket, SocketStatus.OPEN);
+                    getExecutor().execute(proc);
+                }
             }
-
         }
-
     }
 
 
@@ -1567,25 +1682,27 @@ public class AprEndpoint extends AbstractEndpoint {
      */
     protected class SocketEventProcessor implements Runnable {
 
-        protected long socket = 0;
+        protected SocketWrapper<Long> socket = null;
         protected SocketStatus status = null;
 
-        public SocketEventProcessor(long socket, SocketStatus status) {
+        public SocketEventProcessor(SocketWrapper<Long> socket,
+                SocketStatus status) {
             this.socket = socket;
             this.status = status;
         }
 
+        @Override
         public void run() {
-
-            // Process the request from this socket
-            if (handler.event(socket, status) == Handler.SocketState.CLOSED) {
-                // Close socket and pool
-                destroySocket(socket);
-                socket = 0;
+            synchronized (socket) {
+                // Process the request from this socket
+                Handler.SocketState state = handler.event(socket, status);
+                if (state == Handler.SocketState.CLOSED) {
+                    // Close socket and pool
+                    destroySocket(socket.getSocket().longValue());
+                    socket = null;
+                }
             }
-
         }
-
     }
 
     private static class PrivilegedSetTccl implements PrivilegedAction<Void> {
@@ -1596,6 +1713,7 @@ public class AprEndpoint extends AbstractEndpoint {
             this.cl = cl;
         }
 
+        @Override
         public Void run() {
             Thread.currentThread().setContextClassLoader(cl);
             return null;
diff --git a/java/org/apache/tomcat/util/net/JIoEndpoint.java b/java/org/apache/tomcat/util/net/JIoEndpoint.java
index 4e5d299..0c489ad 100644
--- a/java/org/apache/tomcat/util/net/JIoEndpoint.java
+++ b/java/org/apache/tomcat/util/net/JIoEndpoint.java
@@ -122,8 +122,6 @@ public class JIoEndpoint extends AbstractEndpoint {
     }
 
 
-    // --------------------------------------------------- Acceptor Inner Class
-
     /**
      * Async timeout thread
      */
@@ -165,6 +163,9 @@ public class JIoEndpoint extends AbstractEndpoint {
             }
         }
     }
+
+    
+    // --------------------------------------------------- Acceptor Inner Class
     /**
      * Server socket acceptor thread.
      */
@@ -199,15 +200,15 @@ public class JIoEndpoint extends AbstractEndpoint {
                     
                     // Configure the socket
                     if (setSocketOptions(socket)) {
-                        // Hand this socket off to an appropriate processor
-                        if (!processSocket(socket)) {
-                            // Close socket right away
-                            try {
-                                socket.close();
-                            } catch (IOException e) {
-                                // Ignore
-                            }
+                    // Hand this socket off to an appropriate processor
+                    if (!processSocket(socket)) {
+                        // Close socket right away
+                        try {
+                            socket.close();
+                        } catch (IOException e) {
+                            // Ignore
                         }
+                    }
                     } else {
                         // Close socket right away
                         try {
@@ -258,56 +259,58 @@ public class JIoEndpoint extends AbstractEndpoint {
         @Override
         public void run() {
             boolean launch = false;
-            try {
-                
-                if (!socket.processing.compareAndSet(false, true)) {
-                    log.error("Unable to process socket. Invalid state.");
-                    return;
-                }
-                
-                SocketState state = SocketState.OPEN;
-
+            synchronized (socket) {
                 try {
-                    // SSL handshake
-                    serverSocketFactory.handshake(socket.getSocket());
-                } catch (Throwable t) {
-                    if (log.isDebugEnabled()) {
-                        log.debug(sm.getString("endpoint.err.handshake"), t);
-                    }
-                    // Tell to close the socket
-                    state = SocketState.CLOSED;
-                }
+                    SocketState state = SocketState.OPEN;
 
-                if ( (state != SocketState.CLOSED) ) {
-                    state = (status==null)?handler.process(socket):handler.process(socket,status);
-                }
-                if (state == SocketState.CLOSED) {
-                    // Close socket
-                    if (log.isTraceEnabled()) {
-                        log.trace("Closing socket:"+socket);
-                    }
                     try {
-                        socket.getSocket().close();
-                    } catch (IOException e) {
-                        // Ignore
+                        // SSL handshake
+                        serverSocketFactory.handshake(socket.getSocket());
+                    } catch (Throwable t) {
+                        if (log.isDebugEnabled()) {
+                            log.debug(sm.getString("endpoint.err.handshake"), t);
+                        }
+                        // Tell to close the socket
+                        state = SocketState.CLOSED;
+                    }
+                        
+                    if ( (state != SocketState.CLOSED) ) {
+                        state = (status==null)?handler.process(socket):handler.process(socket,status);
+                    }
+                    if (state == SocketState.CLOSED) {
+                        // Close socket
+                        if (log.isTraceEnabled()) {
+                            log.trace("Closing socket:"+socket);
+                        }
+                        try {
+                            socket.getSocket().close();
+                        } catch (IOException e) {
+                            // Ignore
+                        }
+                    } else if (state == SocketState.ASYNC_END ||
+                            state == SocketState.OPEN){
+                        socket.setKeptAlive(true);
+                        socket.access();
+                        launch = true;
+                    } else if (state == SocketState.LONG) {
+                        socket.access();
+                        waitingRequests.add(socket);
+                    }
+                } finally {
+                    if (launch) {
+                        try {
+                            getExecutor().execute(new SocketProcessor(socket, SocketStatus.OPEN));
+                        } catch (NullPointerException npe) {
+                            if (running) {
+                                log.error(sm.getString("endpoint.launch.fail"),
+                                        npe);
+                            }
+                        }
                     }
-                } else if (state == SocketState.OPEN){
-                    socket.setKeptAlive(true);
-                    socket.access();
-                    //keepalive connection
-                    //TODO - servlet3 check async status, we may just be in a hold pattern
-                    launch = true;
-                } else if (state == SocketState.LONG) {
-                    socket.access();
-                    waitingRequests.add(socket);
                 }
-            } finally {
-                socket.processing.set(false);
-                if (launch) getExecutor().execute(new SocketProcessor(socket));
-                socket = null;
             }
+            socket = null;
             // Finish up this request
-            
         }
         
     }
@@ -469,7 +472,7 @@ public class JIoEndpoint extends AbstractEndpoint {
      */
     protected boolean setSocketOptions(Socket socket) {
         serverSocketFactory.initSocket(socket);
-
+        
         try {
             // 1: Set socket options: timeout, linger, etc
             socketProperties.setProperties(socket);
@@ -488,7 +491,7 @@ public class JIoEndpoint extends AbstractEndpoint {
         return true;
     }
 
-
+    
     /**
      * Process a new connection from a new client. Wraps the socket so
      * keep-alive and other attributes can be tracked and then passes the socket
diff --git a/java/org/apache/tomcat/util/net/NioEndpoint.java b/java/org/apache/tomcat/util/net/NioEndpoint.java
index 9047a79..9d81150 100644
--- a/java/org/apache/tomcat/util/net/NioEndpoint.java
+++ b/java/org/apache/tomcat/util/net/NioEndpoint.java
@@ -811,10 +811,12 @@ public class NioEndpoint extends AbstractEndpoint {
                             }
                         } 
                     }
-                }catch (SocketTimeoutException sx) {
+                } catch (SocketTimeoutException sx) {
                     //normal condition
-                }catch ( IOException x ) {
-                    if ( running ) log.error(sm.getString("endpoint.accept.fail"), x);
+                } catch (IOException x) {
+                    if (running) {
+                        log.error(sm.getString("endpoint.accept.fail"), x);
+                    }
                 } catch (OutOfMemoryError oom) {
                     try {
                         oomParachuteData = null;
@@ -1352,7 +1354,6 @@ public class NioEndpoint extends AbstractEndpoint {
             this.socket = channel;
             this.poller = poller;
             lastAccess = System.currentTimeMillis();
-            currentAccess = false;
             comet = false;
             timeout = soTimeout;
             error = false;
@@ -1489,82 +1490,96 @@ public class NioEndpoint extends AbstractEndpoint {
          
         @Override
         public void run() {
-            SelectionKey key = null;
-            try {
-                key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());
-                int handshake = -1;
-                
+            boolean launch = false;
+            synchronized (socket) {
+                SelectionKey key = null;
                 try {
-                    if (key!=null) handshake = socket.handshake(key.isReadable(), key.isWritable());
-                }catch ( IOException x ) {
-                    handshake = -1;
-                    if ( log.isDebugEnabled() ) log.debug("Error during SSL handshake",x);
-                }catch ( CancelledKeyException ckx ) {
-                    handshake = -1;
-                }
-                if ( handshake == 0 ) {
-                    SocketState state = SocketState.OPEN;
-                    // Process the request from this socket
-                    state = (status==null)?handler.process(socket):handler.event(socket,status);
-
-                    if (state == SocketState.CLOSED) {
-                        // Close socket and pool
+                    key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());
+                    int handshake = -1;
+                    
+                    try {
+                        if (key!=null) handshake = socket.handshake(key.isReadable(), key.isWritable());
+                    }catch ( IOException x ) {
+                        handshake = -1;
+                        if ( log.isDebugEnabled() ) log.debug("Error during SSL handshake",x);
+                    }catch ( CancelledKeyException ckx ) {
+                        handshake = -1;
+                    }
+                    if ( handshake == 0 ) {
+                        SocketState state = SocketState.OPEN;
+                        // Process the request from this socket
+                        state = (status==null)?handler.process(socket):handler.event(socket,status);
+    
+                        if (state == SocketState.CLOSED) {
+                            // Close socket and pool
+                            try {
+                                KeyAttachment ka = null;
+                                if (key!=null) {
+                                    ka = (KeyAttachment) key.attachment();
+                                    if (ka!=null) ka.setComet(false);
+                                    socket.getPoller().cancelledKey(key, SocketStatus.ERROR, false);
+                                }
+                                if (socket!=null) nioChannels.offer(socket);
+                                socket = null;
+                                if ( ka!=null ) keyCache.offer(ka);
+                                ka = null;
+                            }catch ( Exception x ) {
+                                log.error("",x);
+                            }
+                        } else if (state == SocketState.ASYNC_END) {
+                            launch = true;
+                        }
+                    } else if (handshake == -1 ) {
+                        KeyAttachment ka = null;
+                        if (key!=null) {
+                            ka = (KeyAttachment) key.attachment();
+                            socket.getPoller().cancelledKey(key, SocketStatus.DISCONNECT, false);
+                        }
+                        if (socket!=null) nioChannels.offer(socket);
+                        socket = null;
+                        if ( ka!=null ) keyCache.offer(ka);
+                        ka = null;
+                    } else {
+                        final SelectionKey fk = key;
+                        final int intops = handshake;
+                        final KeyAttachment ka = (KeyAttachment)fk.attachment();
+                        ka.getPoller().add(socket,intops);
+                    }
+                }catch(CancelledKeyException cx) {
+                    socket.getPoller().cancelledKey(key,null,false);
+                } catch (OutOfMemoryError oom) {
+                    try {
+                        oomParachuteData = null;
+                        socket.getPoller().cancelledKey(key,SocketStatus.ERROR,false);
+                        releaseCaches();
+                        log.error("", oom);
+                    }catch ( Throwable oomt ) {
+                        try {
+                            System.err.println(oomParachuteMsg);
+                            oomt.printStackTrace();
+                        }catch (Throwable letsHopeWeDontGetHere){}
+                    }
+                }catch ( Throwable t ) {
+                    log.error("",t);
+                    socket.getPoller().cancelledKey(key,SocketStatus.ERROR,false);
+                } finally {
+                    if (launch) {
                         try {
-                            KeyAttachment ka = null;
-                            if (key!=null) {
-                                ka = (KeyAttachment) key.attachment();
-                                if (ka!=null) ka.setComet(false);
-                                socket.getPoller().cancelledKey(key, SocketStatus.ERROR, false);
+                            getExecutor().execute(new SocketProcessor(socket, SocketStatus.OPEN));
+                        } catch (NullPointerException npe) {
+                            if (running) {
+                                log.error(sm.getString("endpoint.launch.fail"),
+                                        npe);
                             }
-                            if (socket!=null) nioChannels.offer(socket);
-                            socket = null;
-                            if ( ka!=null ) keyCache.offer(ka);
-                            ka = null;
-                        }catch ( Exception x ) {
-                            log.error("",x);
                         }
-                    } 
-                } else if (handshake == -1 ) {
-                    KeyAttachment ka = null;
-                    if (key!=null) {
-                        ka = (KeyAttachment) key.attachment();
-                        socket.getPoller().cancelledKey(key, SocketStatus.DISCONNECT, false);
                     }
-                    if (socket!=null) nioChannels.offer(socket);
                     socket = null;
-                    if ( ka!=null ) keyCache.offer(ka);
-                    ka = null;
-                } else {
-                    final SelectionKey fk = key;
-                    final int intops = handshake;
-                    final KeyAttachment ka = (KeyAttachment)fk.attachment();
-                    ka.getPoller().add(socket,intops);
+                    status = null;
+                    //return to cache
+                    processorCache.offer(this);
                 }
-            }catch(CancelledKeyException cx) {
-                socket.getPoller().cancelledKey(key,null,false);
-            } catch (OutOfMemoryError oom) {
-                try {
-                    oomParachuteData = null;
-                    socket.getPoller().cancelledKey(key,SocketStatus.ERROR,false);
-                    releaseCaches();
-                    log.error("", oom);
-                }catch ( Throwable oomt ) {
-                    try {
-                        System.err.println(oomParachuteMsg);
-                        oomt.printStackTrace();
-                    }catch (Throwable letsHopeWeDontGetHere){}
-                }
-            }catch ( Throwable t ) {
-                log.error("",t);
-                socket.getPoller().cancelledKey(key,SocketStatus.ERROR,false);
-            } finally {
-                socket = null;
-                status = null;
-                //return to cache
-                processorCache.offer(this);
             }
         }
-
     }
 
     // ----------------------------------------------- SendfileData Inner Class
diff --git a/java/org/apache/tomcat/util/net/SocketWrapper.java b/java/org/apache/tomcat/util/net/SocketWrapper.java
index 80df590..a0d11c1 100644
--- a/java/org/apache/tomcat/util/net/SocketWrapper.java
+++ b/java/org/apache/tomcat/util/net/SocketWrapper.java
@@ -16,22 +16,17 @@
  */
 package org.apache.tomcat.util.net;
 
-import java.util.concurrent.atomic.AtomicBoolean;
-
-
 public class SocketWrapper<E> {
     
     protected volatile E socket;
     
     protected volatile long lastAccess = -1;
-    protected volatile boolean currentAccess = false;
     protected long timeout = -1;
     protected boolean error = false;
     protected long lastRegistered = 0;
     protected volatile int keepAliveLeft = 100;
     protected boolean async = false;
     protected boolean keptAlive = false;
-    public AtomicBoolean processing = new AtomicBoolean(false);
     
     public SocketWrapper(E socket) {
         this.socket = socket;
@@ -46,8 +41,6 @@ public class SocketWrapper<E> {
     public long getLastAccess() { return lastAccess; }
     public void access() { access(System.currentTimeMillis()); }
     public void access(long access) { lastAccess = access; }
-    public boolean getCurrentAccess() { return currentAccess; }
-    public void setCurrentAccess(boolean access) { currentAccess = access; }
     public void setTimeout(long timeout) {this.timeout = timeout;}
     public long getTimeout() {return this.timeout;}
     public boolean getError() { return error; }
diff --git a/java/org/apache/tomcat/util/net/res/LocalStrings.properties b/java/org/apache/tomcat/util/net/res/LocalStrings.properties
index 686731c..bb70316 100644
--- a/java/org/apache/tomcat/util/net/res/LocalStrings.properties
+++ b/java/org/apache/tomcat/util/net/res/LocalStrings.properties
@@ -32,6 +32,7 @@ endpoint.init.bind=Socket bind failed: [{0}] {1}
 endpoint.init.listen=Socket listen failed: [{0}] {1}
 endpoint.init.notavail=APR not available
 endpoint.accept.fail=Socket accept failed
+endpoint.launch.fail=Failed to launch new runnable
 endpoint.poll.limitedpollsize=Failed to create poller with specified size of {0}
 endpoint.poll.initfail=Poller creation failed
 endpoint.poll.fail=Critical poller failure (restarting poller): [{0}] {1}
diff --git a/test/org/apache/catalina/core/TestAsyncContextImpl.java b/test/org/apache/catalina/core/TestAsyncContextImpl.java
index 000a410..2ba8902 100644
--- a/test/org/apache/catalina/core/TestAsyncContextImpl.java
+++ b/test/org/apache/catalina/core/TestAsyncContextImpl.java
@@ -24,6 +24,7 @@ import javax.servlet.AsyncContext;
 import javax.servlet.AsyncEvent;
 import javax.servlet.AsyncListener;
 import javax.servlet.ServletException;
+import javax.servlet.ServletResponse;
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
@@ -177,7 +178,7 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
             result  = new StringBuilder();
             result.append('1');
             result.append(req.isAsyncStarted());
-            req.startAsync();
+            req.startAsync().setTimeout(10000);
             result.append('2');
             result.append(req.isAsyncStarted());
             
@@ -305,13 +306,22 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
                 throws ServletException, IOException {
             
             AsyncContext actxt = req.startAsync();
+            actxt.setTimeout(3000);
             resp.setContentType("text/plain");
             resp.getWriter().print("OK");
             actxt.complete();
         }
     }
 
-    public void testTimeout() throws Exception {
+    public void testTimeoutListenerComplete() throws Exception {
+        doTestTimeout(true);
+    }
+    
+    public void testTimeoutListenerNoComplete() throws Exception {
+        doTestTimeout(false);
+    }
+    
+    private void doTestTimeout(boolean completeOnTimeout) throws Exception {
         // Setup Tomcat instance
         Tomcat tomcat = getTomcatInstance();
         
@@ -326,7 +336,7 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
         
         Context ctx = tomcat.addContext("", docBase.getAbsolutePath());
 
-        TimeoutServlet timeout = new TimeoutServlet();
+        TimeoutServlet timeout = new TimeoutServlet(completeOnTimeout);
 
         Wrapper wrapper = Tomcat.addServlet(ctx, "time", timeout);
         wrapper.setAsyncSupported(true);
@@ -334,47 +344,383 @@ public class TestAsyncContextImpl extends TomcatBaseTest {
 
         tomcat.start();
         ByteChunk res = getUrl("http://localhost:" + getPort() + "/async");
-        assertEquals("OK", res.toString());
+        StringBuilder expected = new StringBuilder();
+        expected.append("TimeoutServletGet-onTimeout-");
+        if (!completeOnTimeout) {
+            expected.append("onError-");
+        }
+        expected.append("onComplete-");
+        assertEquals(expected.toString(), res.toString());
     }
     
     private static class TimeoutServlet extends HttpServlet {
         private static final long serialVersionUID = 1L;
 
+        private boolean completeOnTimeout;
+        
+        public TimeoutServlet(boolean completeOnTimeout) {
+            this.completeOnTimeout = completeOnTimeout;
+        }
+        
         @Override
         protected void doGet(HttpServletRequest req, HttpServletResponse resp) 
                 throws ServletException, IOException {
             if (req.isAsyncSupported()) {
-                resp.getWriter().print("OK");
+                resp.getWriter().print("TimeoutServletGet-");
                 final AsyncContext ac = req.startAsync();
-                ac.setTimeout(2000);
+                ac.setTimeout(3000);
                 
-                ac.addListener(new TimeoutListener());
+                ac.addListener(new TrackingListener(false, completeOnTimeout));
             } else
                 resp.getWriter().print("FAIL: Async unsupported");
         }
     }
 
-    private static class TimeoutListener implements AsyncListener {
+    public void testDispatchSingle() throws Exception {
+        doTestDispatch(1, false);
+    }
+    
+    public void testDispatchDouble() throws Exception {
+        doTestDispatch(2, false);
+    }
+    
+    public void testDispatchMultiple() throws Exception {
+        doTestDispatch(5, false);
+    }
+    
+    public void testDispatchWithThreadSingle() throws Exception {
+        doTestDispatch(1, true);
+    }
+    
+    public void testDispatchWithThreadDouble() throws Exception {
+        doTestDispatch(2, true);
+    }
+    
+    public void testDispatchWithThreadMultiple() throws Exception {
+        doTestDispatch(5, true);
+    }
+    
+    private void doTestDispatch(int iter, boolean useThread) throws Exception {
+        // Setup Tomcat instance
+        Tomcat tomcat = getTomcatInstance();
+        
+        // Must have a real docBase - just use temp
+        File docBase = new File(System.getProperty("java.io.tmpdir"));
+        
+        Context ctx = tomcat.addContext("", docBase.getAbsolutePath());
+
+        DispatchingServlet dispatch = new DispatchingServlet(false, false);
+        Wrapper wrapper = Tomcat.addServlet(ctx, "dispatch", dispatch);
+        wrapper.setAsyncSupported(true);
+        ctx.addServletMapping("/stage1", "dispatch");
+
+        NonAsyncServlet nonasync = new NonAsyncServlet();
+        Wrapper wrapper2 = Tomcat.addServlet(ctx, "nonasync", nonasync);
+        wrapper2.setAsyncSupported(true);
+        ctx.addServletMapping("/stage2", "nonasync");
+
+        tomcat.start();
+        
+        StringBuilder url = new StringBuilder(48);
+        url.append("http://localhost:");
+        url.append(getPort());
+        url.append("/stage1?iter=");
+        url.append(iter);
+        if (useThread) {
+            url.append("&useThread=y");
+        }
+        ByteChunk res = getUrl(url.toString());
+        
+        StringBuilder expected = new StringBuilder();
+        int loop = iter;
+        while (loop > 0) {
+            expected.append("DispatchingServletGet-");
+            loop--;
+        }
+        expected.append("NonAsyncServletGet-");
+        assertEquals(expected.toString(), res.toString());
+    }
+    
+    private static class DispatchingServlet extends HttpServlet {
+
+        private static final long serialVersionUID = 1L;
+        private static final String ITER_PARAM = "iter";
+        private boolean addTrackingListener = false;
+        private boolean completeOnError = false;
+        
+        public DispatchingServlet(boolean addTrackingListener,
+                boolean completeOnError) {
+            this.addTrackingListener = addTrackingListener;
+            this.completeOnError = completeOnError;
+        }
+        
+        @Override
+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
+                throws ServletException, IOException {
+            resp.getWriter().write("DispatchingServletGet-");
+            resp.flushBuffer();
+            final int iter = Integer.parseInt(req.getParameter(ITER_PARAM)) - 1;
+            final AsyncContext ctxt = req.startAsync();
+            if (addTrackingListener) {
+                TrackingListener listener =
+                    new TrackingListener(completeOnError, true); 
+                ctxt.addListener(listener);
+            }
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    if (iter > 0) {
+                        ctxt.dispatch("/stage1?" + ITER_PARAM + "=" + iter);
+                    } else {
+                        ctxt.dispatch("/stage2");
+                    }
+                }
+            };
+            if ("y".equals(req.getParameter("useThread"))) {
+                new Thread(run).start();
+            } else {
+                run.run();
+            }
+        }
+    }
+
+    private static class NonAsyncServlet extends HttpServlet {
+
+        private static final long serialVersionUID = 1L;
+
+        @Override
+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
+                throws ServletException, IOException {
+            resp.getWriter().write("NonAsyncServletGet-");
+            resp.flushBuffer();
+        }
+    }
+    
+    public void testListeners() throws Exception {
+        // Setup Tomcat instance
+        Tomcat tomcat = getTomcatInstance();
+        
+        // Must have a real docBase - just use temp
+        File docBase = new File(System.getProperty("java.io.tmpdir"));
+        
+        Context ctx = tomcat.addContext("", docBase.getAbsolutePath());
+
+        TrackingServlet tracking = new TrackingServlet();
+        Wrapper wrapper = Tomcat.addServlet(ctx, "tracking", tracking);
+        wrapper.setAsyncSupported(true);
+        ctx.addServletMapping("/stage1", "tracking");
+
+        TimeoutServlet timeout = new TimeoutServlet(true);
+        Wrapper wrapper2 = Tomcat.addServlet(ctx, "timeout", timeout);
+        wrapper2.setAsyncSupported(true);
+        ctx.addServletMapping("/stage2", "timeout");
+
+        tomcat.start();
+        
+        StringBuilder url = new StringBuilder(48);
+        url.append("http://localhost:");
+        url.append(getPort());
+        url.append("/stage1");
+
+        ByteChunk res = getUrl(url.toString());
+        
+        assertEquals(
+                "DispatchingServletGet-DispatchingServletGet-onStartAsync-" +
+                "TimeoutServletGet-onStartAsync-onTimeout-onComplete-",
+                res.toString());
+    }
+
+    private static class TrackingServlet extends HttpServlet {
+
+        private static final long serialVersionUID = 1L;
+        
+        private static volatile boolean first = true;
+        
+        @Override
+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
+                throws ServletException, IOException {
+            resp.getWriter().write("DispatchingServletGet-");
+            resp.flushBuffer();
+
+            final boolean first = TrackingServlet.first;
+            TrackingServlet.first = false;
+
+            final AsyncContext ctxt = req.startAsync();
+            TrackingListener listener = new TrackingListener(false, true); 
+            ctxt.addListener(listener);
+            ctxt.setTimeout(3000);
+
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    if (first) {
+                        ctxt.dispatch("/stage1");
+                    } else {
+                        ctxt.dispatch("/stage2");
+                    }
+                }
+            };
+            if ("y".equals(req.getParameter("useThread"))) {
+                new Thread(run).start();
+            } else {
+                run.run();
+            }
+        }
+    }
+
+    private static class TrackingListener implements AsyncListener {
+        
+        private boolean completeOnError;
+        private boolean completeOnTimeout;
+        
+        public TrackingListener(boolean completeOnError,
+                boolean completeOnTimeout) {
+            this.completeOnError = completeOnError;
+            this.completeOnTimeout = completeOnTimeout;
+        }
 
         @Override
         public void onComplete(AsyncEvent event) throws IOException {
-            // NO-OP
+            ServletResponse resp = event.getAsyncContext().getResponse(); 
+            resp.getWriter().write("onComplete-");
+            resp.flushBuffer();
         }
 
         @Override
         public void onTimeout(AsyncEvent event) throws IOException {
-            event.getAsyncContext().complete();
+            ServletResponse resp = event.getAsyncContext().getResponse(); 
+            resp.getWriter().write("onTimeout-");
+            resp.flushBuffer();
+            if (completeOnTimeout){
+                event.getAsyncContext().complete();
+            }
         }
 
         @Override
         public void onError(AsyncEvent event) throws IOException {
-            // NOOP
+            ServletResponse resp = event.getAsyncContext().getResponse(); 
+            resp.getWriter().write("onError-");
+            resp.flushBuffer();
+            if (completeOnError) {
+                event.getAsyncContext().complete();
+            }
         }
 
         @Override
         public void onStartAsync(AsyncEvent event) throws IOException {
-            // NOOP
+            ServletResponse resp = event.getAsyncContext().getResponse(); 
+            resp.getWriter().write("onStartAsync-");
+            resp.flushBuffer();
+        }
+    }
+    
+    public void testDispatchErrorSingle() throws Exception {
+        doTestDispatchError(1, false, false);
+    }
+    
+    public void testDispatchErrorDouble() throws Exception {
+        doTestDispatchError(2, false, false);
+    }
+    
+    public void testDispatchErrorMultiple() throws Exception {
+        doTestDispatchError(5, false, false);
+    }
+    
+    public void testDispatchErrorWithThreadSingle() throws Exception {
+        doTestDispatchError(1, true, false);
+    }
+    
+    public void testDispatchErrorWithThreadDouble() throws Exception {
+        doTestDispatchError(2, true, false);
+    }
+    
+    public void testDispatchErrorWithThreadMultiple() throws Exception {
+        doTestDispatchError(5, true, false);
+    }
+    
+    public void testDispatchErrorSingleThenComplete() throws Exception {
+        doTestDispatchError(1, false, true);
+    }
+    
+    public void testDispatchErrorDoubleThenComplete() throws Exception {
+        doTestDispatchError(2, false, true);
+    }
+    
+    public void testDispatchErrorMultipleThenComplete() throws Exception {
+        doTestDispatchError(5, false, true);
+    }
+    
+    public void testDispatchErrorWithThreadSingleThenComplete()
+            throws Exception {
+        doTestDispatchError(1, true, true);
+    }
+    
+    public void testDispatchErrorWithThreadDoubleThenComplete()
+            throws Exception {
+        doTestDispatchError(2, true, true);
+    }
+    
+    public void testDispatchErrorWithThreadMultipleThenComplete()
+            throws Exception {
+        doTestDispatchError(5, true, true);
+    }
+    
+    private void doTestDispatchError(int iter, boolean useThread,
+            boolean completeOnError)
+            throws Exception {
+        // Setup Tomcat instance
+        Tomcat tomcat = getTomcatInstance();
+        
+        // Must have a real docBase - just use temp
+        File docBase = new File(System.getProperty("java.io.tmpdir"));
+        
+        Context ctx = tomcat.addContext("", docBase.getAbsolutePath());
+
+        DispatchingServlet dispatch =
+            new DispatchingServlet(true, completeOnError);
+        Wrapper wrapper = Tomcat.addServlet(ctx, "dispatch", dispatch);
+        wrapper.setAsyncSupported(true);
+        ctx.addServletMapping("/stage1", "dispatch");
+
+        ErrorServlet error = new ErrorServlet();
+        Tomcat.addServlet(ctx, "error", error);
+        ctx.addServletMapping("/stage2", "error");
+
+        tomcat.start();
+        
+        StringBuilder url = new StringBuilder(48);
+        url.append("http://localhost:");
+        url.append(getPort());
+        url.append("/stage1?iter=");
+        url.append(iter);
+        if (useThread) {
+            url.append("&useThread=y");
         }
+        ByteChunk res = getUrl(url.toString());
         
+        StringBuilder expected = new StringBuilder();
+        int loop = iter;
+        while (loop > 0) {
+            expected.append("DispatchingServletGet-");
+            if (loop != iter) {
+                expected.append("onStartAsync-");
+            }
+            loop--;
+        }
+        expected.append("ErrorServletGet-onError-onComplete-");
+        assertEquals(expected.toString(), res.toString());
+    }
+    
+    private static class ErrorServlet extends HttpServlet {
+
+        private static final long serialVersionUID = 1L;
+
+        @Override
+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
+                throws ServletException, IOException {
+            resp.getWriter().write("ErrorServletGet-");
+            resp.flushBuffer();
+            throw new ServletException("Opps.");
+        }
     }
 }
diff --git a/webapps/docs/changelog.xml b/webapps/docs/changelog.xml
index eab9ed7..a215599 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -125,6 +125,11 @@
         <code>UnsupportedOperationException</code>. (markt)
       </fix>
       <fix>
+        <bug>49884</bug>: Fix occassional NullPointerException on async
+        complete(). This resulted in a major refactoring of the async
+        implementation to address a number of threading issues. (markt)
+      </fix>
+      <fix>
         Update the version numbers in ServerInfo defaults to Tomcat 7.0.x.
         (markt)
       </fix>

commit 707f77876cb106572212f0de27d64c891c7006ca
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Mon Aug 23 20:35:03 2010 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=49669
    Another Java class triggering a memory leak. This time javax.security.auth.Policy
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@988296 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java b/java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java
index e3619cd..79a7f41 100644
--- a/java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java
+++ b/java/org/apache/catalina/core/JreMemoryLeakPreventionListener.java
@@ -23,6 +23,7 @@ import java.lang.reflect.Method;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.net.URLConnection;
+import java.security.Policy;
 
 import javax.imageio.ImageIO;
 import javax.xml.parsers.DocumentBuilderFactory;
@@ -93,6 +94,20 @@ public class JreMemoryLeakPreventionListener implements LifecycleListener {
          this.keepAliveProtection = keepAliveProtection;
      }
     
+     /**
+      * Protect against the memory leak caused when the first call to
+      * <code>javax.security.auth.Policy</code> is triggered by a web
+      * application. This first call populate a static variable with a reference
+      * to the context class loader. Defaults to <code>true</code>.
+      */
+     private boolean securityPolicyProtection = true;
+     public boolean iSsecurityPolicyProtection() {
+         return securityPolicyProtection;
+     }
+     public void setSecurityPolicyProtection(boolean securityPolicyProtection) {
+         this.securityPolicyProtection = securityPolicyProtection;
+     }
+     
     /**
      * Protect against the memory leak, when the initialization of the
      * Java Cryptography Architecture is triggered by initializing
@@ -212,6 +227,19 @@ public class JreMemoryLeakPreventionListener implements LifecycleListener {
             }
             
             /*
+             * Calling getPolicy retains a static reference to the context class
+             * loader.
+             */
+            if (securityPolicyProtection) {
+                try {
+                    Policy.getPolicy();
+                } catch(SecurityException e) {
+                    // Ignore. Don't need call to getPolicy() to be successful,
+                    // just need to trigger static initializer.
+                }
+            }
+
+            /*
              * Creating a MessageDigest during web application startup
              * initializes the Java Cryptography Architecture. Under certain
              * conditions this starts a Token poller thread with TCCL equal
diff --git a/webapps/docs/config/listeners.xml b/webapps/docs/config/listeners.xml
index c15c03f..2890919 100644
--- a/webapps/docs/config/listeners.xml
+++ b/webapps/docs/config/listeners.xml
@@ -270,6 +270,16 @@ service:jmx:rmi://&lt;hostname&gt;:10002/jndi/rmi://&lt;hostname&gt;:10001/jmxrm
         trigger a memory leak on reload. Defaults to <code>true</code>.</p>
       </attribute>
 
+      <attribute name="securityPolicyProtection" required="false">
+        <p>Enables protection so that usage of
+        <code>javax.security.auth.Policy</code> by a web application does not
+        result in a memory leak. The first access of this class will trigger the
+        static initializer that will retain a static reference to the context
+        class loader. The protection calls the <code>getPolicy()</code> method
+        of this class to ensure that the static initializer is not triggered by
+        a web application. Defaults to <code>true</code>.</p>
+      </attribute>
+
       <attribute name="tokenPollerProtection" required="false">
         <p>Enables protection so that any token poller thread initialized by
         <code>sun.security.pkcs11.SunPKCS11.initToken()</code> does not

commit d1b97ef87deb717eb946ce10d5d8914d3207b515
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Mon Aug 2 10:49:06 2010 +0000

    Fix running with a security manager
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@981448 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index bb67595..385bae2 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -73,9 +73,6 @@ public final class SecurityClassLoad {
             "AsyncContextImpl$1");
         loader.loadClass
             (basePackage +
-            "AsyncContextImpl$2");
-        loader.loadClass
-            (basePackage +
             "AsyncListenerWrapper");
         loader.loadClass
             (basePackage +
diff --git a/webapps/docs/changelog.xml b/webapps/docs/changelog.xml
index 4906800..97f5488 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -35,7 +35,17 @@
 
 <body>
 <!--  Catalina, Coyote, Jasper, Cluster, Web applications, Extras, Other -->
-<section name="Tomcat 7.0.1 (markt)">
+<section name="Tomcat 7.0.2 (markt)">
+  <subsection name="Catalina">
+    <changelog>
+      <fix>
+        Fix repgrssion that prevented running with a security manager enabled.
+        (markt)
+      </fix>
+    </changelog>
+  </subsection>
+</section>
+<section name="Tomcat 7.0.1 (markt)" rtext="Not released">
   <subsection name="Catalina">
     <changelog>
       <fix>

commit 97bef46b54269a8daaee18bf096fe73c345774e9
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Thu Jul 1 09:57:07 2010 +0000

    Improve default security settings. Enable the LockOutRealm by default.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@959580 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/conf/server.xml b/conf/server.xml
index 338f430..86ad0be 100644
--- a/conf/server.xml
+++ b/conf/server.xml
@@ -106,12 +106,16 @@
       <Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/>
       -->        
 
-      <!-- This Realm uses the UserDatabase configured in the global JNDI
-           resources under the key "UserDatabase".  Any edits
-           that are performed against this UserDatabase are immediately
-           available for use by the Realm.  -->
-      <Realm className="org.apache.catalina.realm.UserDatabaseRealm"
-             resourceName="UserDatabase"/>
+      <!-- Use the LockOutRealm to prevent attempts to guess user passwords
+           via a brute-force attack -->
+      <Realm className="org.apache.catalina.realm.LockOutRealm">
+        <!-- This Realm uses the UserDatabase configured in the global JNDI
+             resources under the key "UserDatabase".  Any edits
+             that are performed against this UserDatabase are immediately
+             available for use by the Realm.  -->
+        <Realm className="org.apache.catalina.realm.UserDatabaseRealm"
+               resourceName="UserDatabase"/>
+      </Realm>
 
       <!-- Define the default virtual host
            Note: XML Schema validation will not work with Xerces 2.2.
diff --git a/webapps/docs/changelog.xml b/webapps/docs/changelog.xml
index af472be..da0bb0a 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -75,6 +75,10 @@
         Add support for <code>*.jar</code> pattern in VirtualWebappLoader.
         (kkolinko)
       </add>
+      <add>
+        Use a LockOutRealm in the default configuration to prevent attempts to
+        guess user passwords by brute-force. (markt)
+      </add>
     </changelog>
   </subsection>
   <subsection name="Coyote">

commit 650eff514eed9876d67e142c91086b9db2dbbc27
Author: Konstantin Kolinko <kkolinko@apache.org>
Date:   Sat Jun 5 00:19:07 2010 +0000

    Wrap long lines, so that this file could be copied to security-manager-howto.xml as is.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@951620 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/conf/catalina.policy b/conf/catalina.policy
index 838758c..19b0530 100644
--- a/conf/catalina.policy
+++ b/conf/catalina.policy
@@ -169,9 +169,12 @@ grant {
      "org.apache.el.parser.COERCE_TO_ZERO", "read";
 
     // The cookie code needs these.
-    permission java.util.PropertyPermission "org.apache.catalina.STRICT_SERVLET_COMPLIANCE", "read";
-    permission java.util.PropertyPermission "org.apache.tomcat.util.http.ServerCookie.STRICT_NAMING", "read";
-    permission java.util.PropertyPermission "org.apache.tomcat.util.http.ServerCookie.FWD_SLASH_IS_SEPARATOR", "read";
+    permission java.util.PropertyPermission
+     "org.apache.catalina.STRICT_SERVLET_COMPLIANCE", "read";
+    permission java.util.PropertyPermission
+     "org.apache.tomcat.util.http.ServerCookie.STRICT_NAMING", "read";
+    permission java.util.PropertyPermission
+     "org.apache.tomcat.util.http.ServerCookie.FWD_SLASH_IS_SEPARATOR", "read";
 
     // Applications using Comet need to be able to access this package
     permission java.lang.RuntimePermission "accessClassInPackage.org.apache.catalina.comet";

commit 21d81ca3b5133fcf05988cc2d0fe3d91ebe14311
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Thu Jun 3 07:56:23 2010 +0000

    Clean up FastHttpDateFormat initialisation when using a security manager as prompted by Konstantin
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@950905 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index be10606..966d2fd 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -43,7 +43,6 @@ public final class SecurityClassLoad {
         loadUtilPackage(loader);
         loadJavaxPackage(loader);
         loadCoyotePackage(loader);        
-        loadHttp11Package(loader);        
         loadTomcatPackage(loader);
     }
     
@@ -141,13 +140,6 @@ public final class SecurityClassLoad {
     }
     
 
-    private final static void loadHttp11Package(ClassLoader loader)
-        throws Exception {
-        String basePackage = "org.apache.coyote.http11.";
-        loader.loadClass(basePackage + "Http11Processor$1");
-    }
-    
-    
     private final static void loadCoyotePackage(ClassLoader loader)
         throws Exception {
         String basePackage = "org.apache.catalina.connector.";
diff --git a/java/org/apache/coyote/http11/Http11AprProcessor.java b/java/org/apache/coyote/http11/Http11AprProcessor.java
index 14a7c93..b8a927c 100644
--- a/java/org/apache/coyote/http11/Http11AprProcessor.java
+++ b/java/org/apache/coyote/http11/Http11AprProcessor.java
@@ -106,10 +106,6 @@ public class Http11AprProcessor implements ActionHook {
 
         // Cause loading of HexUtils
         HexUtils.load();
-
-        // Cause loading of FastHttpDateFormat
-        FastHttpDateFormat.getCurrentDate();
-
     }
 
 
diff --git a/java/org/apache/coyote/http11/Http11NioProcessor.java b/java/org/apache/coyote/http11/Http11NioProcessor.java
index 993b48b..6f70794 100644
--- a/java/org/apache/coyote/http11/Http11NioProcessor.java
+++ b/java/org/apache/coyote/http11/Http11NioProcessor.java
@@ -96,10 +96,6 @@ public class Http11NioProcessor extends AbstractHttp11Processor implements Actio
 
         // Cause loading of HexUtils
         HexUtils.load();
-
-        // Cause loading of FastHttpDateFormat
-        FastHttpDateFormat.getCurrentDate();
-
     }
 
 
diff --git a/java/org/apache/coyote/http11/Http11Processor.java b/java/org/apache/coyote/http11/Http11Processor.java
index f927e01..2dd853a 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -930,19 +930,7 @@ public class Http11Processor extends AbstractHttp11Processor implements ActionHo
         }
 
         // Add date header
-        String date = null;
-        if (isSecurityEnabled){
-            date = AccessController.doPrivileged(
-                    new PrivilegedAction<String>() {
-                        public String run(){
-                            return FastHttpDateFormat.getCurrentDate();
-                        }
-                    }
-            );
-        } else {
-            date = FastHttpDateFormat.getCurrentDate();
-        }
-        headers.setValue("Date").setString(date);
+        headers.setValue("Date").setString(FastHttpDateFormat.getCurrentDate());
 
         // FIXME: Add transfer encoding header
 

commit 38b460726d9739a6a2a1d006d35e0ec5338cc244
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Mon May 24 17:03:37 2010 +0000

    Fix some TCK failures with the BIO AJP connector when using a security manager
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@947717 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index 5898067..be10606 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -129,9 +129,9 @@ public final class SecurityClassLoad {
     
     private final static void loadUtilPackage(ClassLoader loader)
         throws Exception {
-        String basePackage = "org.apache.catalina.";
-        loader.loadClass(basePackage + "util.Enumerator");
-        loader.loadClass(basePackage + "util.ParameterMap");
+        String basePackage = "org.apache.catalina.util.";
+        loader.loadClass(basePackage + "Enumerator");
+        loader.loadClass(basePackage + "ParameterMap");
     }
     
     
@@ -237,6 +237,10 @@ public final class SecurityClassLoad {
         loader.loadClass(basePackage + "util.net.SSLSupport$CipherData");
         loader.loadClass
             (basePackage + "util.net.JIoEndpoint$PrivilegedSetTccl");
+        // Make sure system property is read at this point
+        Class<?> clazz = loader.loadClass(
+                basePackage + "util.http.FastHttpDateFormat");
+        clazz.newInstance();
     }
 }
 

commit 3f18a292e9d187ab60cff1b997dfe93e916cd31f
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Fri May 14 23:43:51 2010 +0000

    TCK failures: Fix remaining failures with APR/native and a security Manager
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@944518 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/TOMCAT-7-RELEASE-PLAN.txt b/TOMCAT-7-RELEASE-PLAN.txt
index 7ee1ac4..d109670 100644
--- a/TOMCAT-7-RELEASE-PLAN.txt
+++ b/TOMCAT-7-RELEASE-PLAN.txt
@@ -27,8 +27,7 @@
 
 3. Implement all the new Servlet 3 features
    NOTE: Status is based on a review of the specification, not the TCK tests
-   - Sections 1 to 15
-   - Strict spec compliance requires deployment descriptor validation
+   - Done
 
 4. Do an initial release (from trunk)
    - Create tc7.0.x\tags to hold release tags - Done
diff --git a/java/org/apache/catalina/core/StandardHostValve.java b/java/org/apache/catalina/core/StandardHostValve.java
index d0757a8..8b235f0 100644
--- a/java/org/apache/catalina/core/StandardHostValve.java
+++ b/java/org/apache/catalina/core/StandardHostValve.java
@@ -20,6 +20,8 @@ package org.apache.catalina.core;
 
 
 import java.io.IOException;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 
 import javax.servlet.DispatcherType;
 import javax.servlet.RequestDispatcher;
@@ -126,8 +128,14 @@ final class StandardHostValve
         if( context.getLoader() != null ) {
             // Not started - it should check for availability first
             // This should eventually move to Engine, it's generic.
-            Thread.currentThread().setContextClassLoader
-                    (context.getLoader().getClassLoader());
+            if (Globals.IS_SECURITY_ENABLED) {
+                PrivilegedAction<Void> pa = new PrivilegedSetTccl(
+                        context.getLoader().getClassLoader());
+                AccessController.doPrivileged(pa);                
+            } else {
+                Thread.currentThread().setContextClassLoader
+                        (context.getLoader().getClassLoader());
+            }
         }
         if (request.isAsyncSupported()) {
             request.setAsyncSupported(context.getPipeline().isAsyncSupported());
@@ -155,8 +163,14 @@ final class StandardHostValve
         }
 
         // Restore the context classloader
-        Thread.currentThread().setContextClassLoader
-            (StandardHostValve.class.getClassLoader());
+        if (Globals.IS_SECURITY_ENABLED) {
+            PrivilegedAction<Void> pa = new PrivilegedSetTccl(
+                    StandardHostValve.class.getClassLoader());
+            AccessController.doPrivileged(pa);                
+        } else {
+            Thread.currentThread().setContextClassLoader
+                    (StandardHostValve.class.getClassLoader());
+        }
 
     }
 
@@ -449,5 +463,18 @@ final class StandardHostValve
 
     }
 
+    
+    private static class PrivilegedSetTccl implements PrivilegedAction<Void> {
 
+        private ClassLoader cl;
+
+        PrivilegedSetTccl(ClassLoader cl) {
+            this.cl = cl;
+        }
+
+        public Void run() {
+            Thread.currentThread().setContextClassLoader(cl);
+            return null;
+        }
+    }
 }
diff --git a/java/org/apache/tomcat/util/net/AprEndpoint.java b/java/org/apache/tomcat/util/net/AprEndpoint.java
index 42774f9..c67cc76 100644
--- a/java/org/apache/tomcat/util/net/AprEndpoint.java
+++ b/java/org/apache/tomcat/util/net/AprEndpoint.java
@@ -17,10 +17,13 @@
 
 package org.apache.tomcat.util.net;
 
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.concurrent.RejectedExecutionException;
 
+import org.apache.catalina.Globals;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.jni.Address;
@@ -36,6 +39,7 @@ import org.apache.tomcat.jni.SSLSocket;
 import org.apache.tomcat.jni.Socket;
 import org.apache.tomcat.jni.Status;
 
+
 /**
  * APR tailored thread pool, providing the following services:
  * <ul>
@@ -759,7 +763,29 @@ public class AprEndpoint extends AbstractEndpoint {
      */
     protected boolean processSocket(long socket, SocketStatus status) {
         try {
-            getExecutor().execute(new SocketEventProcessor(socket, status));
+            if (status == SocketStatus.OPEN || status == SocketStatus.STOP ||
+                    status == SocketStatus.TIMEOUT) {
+                SocketEventProcessor proc =
+                    new SocketEventProcessor(socket, status);
+                ClassLoader loader = Thread.currentThread().getContextClassLoader();
+                try {
+                    if (Globals.IS_SECURITY_ENABLED) {
+                        PrivilegedAction<Void> pa = new PrivilegedSetTccl(
+                                getClass().getClassLoader());
+                        AccessController.doPrivileged(pa);
+                    } else {
+                        Thread.currentThread().setContextClassLoader(
+                                getClass().getClassLoader());
+                    }                
+                    getExecutor().execute(proc);
+                } finally {
+                    if (Globals.IS_SECURITY_ENABLED) {
+                        PrivilegedAction<Void> pa = new PrivilegedSetTccl(loader);
+                        AccessController.doPrivileged(pa);
+                    } else {
+                        Thread.currentThread().setContextClassLoader(loader);
+                    }
+                }            }
         } catch (RejectedExecutionException x) {
             log.warn("Socket processing request was rejected for:"+socket,x);
             return false;
@@ -1481,5 +1507,17 @@ public class AprEndpoint extends AbstractEndpoint {
         
     }
     
-    
+    private static class PrivilegedSetTccl implements PrivilegedAction<Void> {
+
+        private ClassLoader cl;
+
+        PrivilegedSetTccl(ClassLoader cl) {
+            this.cl = cl;
+        }
+
+        public Void run() {
+            Thread.currentThread().setContextClassLoader(cl);
+            return null;
+        }
+    }    
 }
diff --git a/java/org/apache/tomcat/util/net/JIoEndpoint.java b/java/org/apache/tomcat/util/net/JIoEndpoint.java
index 15f9453..28b3eb5 100644
--- a/java/org/apache/tomcat/util/net/JIoEndpoint.java
+++ b/java/org/apache/tomcat/util/net/JIoEndpoint.java
@@ -542,8 +542,7 @@ public class JIoEndpoint extends AbstractEndpoint {
     protected ConcurrentLinkedQueue<SocketWrapper<Socket>> waitingRequests =
         new ConcurrentLinkedQueue<SocketWrapper<Socket>>();
 
-    private static class PrivilegedSetTccl
-    implements PrivilegedAction<Void> {
+    private static class PrivilegedSetTccl implements PrivilegedAction<Void> {
 
         private ClassLoader cl;
 

commit 76e3ae58cb4da887a8c5482497072fa10ad9a60c
Author: Filip Hanik <fhanik@apache.org>
Date:   Thu Apr 29 22:00:17 2010 +0000

    Per documentation:
    http://java.sun.com/javase/6/docs/api/javax/security/auth/Subject.html
    Therefore all concrete Principal implementations associated with Subjects must implement Serializable.
    
    
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@939491 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/connector/CoyotePrincipal.java b/java/org/apache/catalina/connector/CoyotePrincipal.java
index c49d7d5..fd42092 100644
--- a/java/org/apache/catalina/connector/CoyotePrincipal.java
+++ b/java/org/apache/catalina/connector/CoyotePrincipal.java
@@ -18,6 +18,7 @@
 
 package org.apache.catalina.connector;
 
+import java.io.Serializable;
 import java.security.Principal;
 
 /**
@@ -29,7 +30,7 @@ import java.security.Principal;
  */
 
 public class CoyotePrincipal 
-    implements Principal {
+    implements Principal, Serializable {
 
 
     // ----------------------------------------------------------- Constructors

commit f3d0ffaa687182dfcbd0299880af543f9da96450
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Sun Apr 11 22:43:09 2010 +0000

    TCK failures: EL TCK with security manager
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@933007 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/javax/el/ExpressionFactory.java b/java/javax/el/ExpressionFactory.java
index c7b74a2..27e8b79 100644
--- a/java/javax/el/ExpressionFactory.java
+++ b/java/javax/el/ExpressionFactory.java
@@ -27,6 +27,8 @@ import java.io.InputStreamReader;
 import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Properties;
 
 /**
@@ -34,15 +36,46 @@ import java.util.Properties;
  * @since 2.1
  */
 public abstract class ExpressionFactory {
+    
+    private static final boolean IS_SECURITY_ENABLED =
+        (System.getSecurityManager() != null);
 
     private static final String SERVICE_RESOURCE_NAME =
         "META-INF/services/javax.el.ExpressionFactory";
 
-    private static final String SEP = System.getProperty("file.separator");
-    private static final String PROPERTY_FILE =
-        System.getProperty("java.home") + "lib" + SEP + "el.properties";
     private static final String PROPERTY_NAME = "javax.el.ExpressionFactory";
 
+    private static final String SEP;
+    private static final String PROPERTY_FILE;
+
+    static {
+        if (IS_SECURITY_ENABLED) {
+            SEP = AccessController.doPrivileged(
+                    new PrivilegedAction<String>(){
+                        @Override
+                        public String run() {
+                            return System.getProperty("file.separator");
+                        }
+
+                    }
+            );
+            PROPERTY_FILE = AccessController.doPrivileged(
+                    new PrivilegedAction<String>(){
+                        @Override
+                        public String run() {
+                            return System.getProperty("java.home") + "lib" +
+                                    SEP + "el.properties";
+                        }
+
+                    }
+            );
+        } else {
+            SEP = System.getProperty("file.separator");
+            PROPERTY_FILE = System.getProperty("java.home") + "lib" + SEP +
+                    "el.properties";
+        }
+    }
+
     public abstract Object coerceToType(Object obj, Class<?> expectedType)
             throws ELException;
 
@@ -90,12 +123,34 @@ public abstract class ExpressionFactory {
         // First services API
         className = getClassNameServices(tccl);
         if (className == null) {
-            // Second el.properties file
-            className = getClassNameJreDir();
+            if (IS_SECURITY_ENABLED) {
+                className = AccessController.doPrivileged(
+                        new PrivilegedAction<String>() {
+                            @Override
+                            public String run() {
+                                return getClassNameJreDir();
+                            }
+                        }
+                );
+            } else {
+                // Second el.properties file
+                className = getClassNameJreDir();
+            }
         }
         if (className == null) {
-            // Third system property 
-            className = getClassNameSysProp();
+            if (IS_SECURITY_ENABLED) {
+                className = AccessController.doPrivileged(
+                        new PrivilegedAction<String>() {
+                            @Override
+                            public String run() {
+                                return getClassNameSysProp();
+                            }
+                        }
+                );
+            } else {
+                // Third system property 
+                className = getClassNameSysProp();
+            }
         }
         if (className == null) {
             // Fourth - default
@@ -225,4 +280,5 @@ public abstract class ExpressionFactory {
         }
         return null;
     }
+
 }
diff --git a/java/org/apache/el/parser/AstValue.java b/java/org/apache/el/parser/AstValue.java
index a0ce1d7..94c3bdf 100644
--- a/java/org/apache/el/parser/AstValue.java
+++ b/java/org/apache/el/parser/AstValue.java
@@ -20,6 +20,8 @@ package org.apache.el.parser;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 
 import javax.el.ELException;
 import javax.el.ELResolver;
@@ -39,10 +41,31 @@ import org.apache.el.util.ReflectionUtil;
  */
 public final class AstValue extends SimpleNode {
 
-    protected static final boolean COERCE_TO_ZERO =
-        Boolean.valueOf(System.getProperty(
-                "org.apache.el.parser.COERCE_TO_ZERO", "true")).booleanValue();
+    private static final boolean IS_SECURITY_ENABLED =
+        (System.getSecurityManager() != null);
+
+    protected static final boolean COERCE_TO_ZERO;
     
+    static {
+        if (IS_SECURITY_ENABLED) {
+            COERCE_TO_ZERO = AccessController.doPrivileged(
+                    new PrivilegedAction<Boolean>(){
+                        @Override
+                        public Boolean run() {
+                            return Boolean.valueOf(System.getProperty(
+                                    "org.apache.el.parser.COERCE_TO_ZERO",
+                                    "true"));
+                        }
+
+                    }
+            ).booleanValue();
+        } else {
+            COERCE_TO_ZERO = Boolean.valueOf(System.getProperty(
+                    "org.apache.el.parser.COERCE_TO_ZERO",
+                    "true")).booleanValue();
+        }
+    }
+
     protected static class Target {
         protected Object base;
 

commit 36bb7c8354609b6b757bea0f104be6ceda254a1d
Author: Rainer Jung <rjung@apache.org>
Date:   Sun Apr 11 18:26:20 2010 +0000

    Reduce failures of new API when running under security manager.
    
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@932969 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/core/ApplicationContextFacade.java b/java/org/apache/catalina/core/ApplicationContextFacade.java
index 4948ef4..4e1f5f7 100644
--- a/java/org/apache/catalina/core/ApplicationContextFacade.java
+++ b/java/org/apache/catalina/core/ApplicationContextFacade.java
@@ -103,6 +103,15 @@ public final class ApplicationContextFacade
         classCache.put("getRequestDispatcher", clazz);
         classCache.put("getNamedDispatcher", clazz);
         classCache.put("getServlet", clazz);
+        classCache.put("setInitParameter", new Class[]{String.class, String.class});
+        classCache.put("createServlet", new Class[]{Class.class});
+        classCache.put("addServlet", new Class[]{String.class, String.class});
+        classCache.put("createFilter", new Class[]{Class.class});
+        classCache.put("addFilter", new Class[]{String.class, String.class});
+        classCache.put("createListener", new Class[]{Class.class});
+        classCache.put("addListener", clazz);
+        classCache.put("getFilterRegistration", clazz);
+        classCache.put("getServletRegistration", clazz);
         classCache.put("getInitParameter", clazz);
         classCache.put("setAttribute", new Class[]{String.class, Object.class});
         classCache.put("removeAttribute", clazz);
@@ -110,8 +119,6 @@ public final class ApplicationContextFacade
         classCache.put("getAttribute", clazz);
         classCache.put("log", clazz);
         classCache.put("setSessionTrackingModes", new Class[]{EnumSet.class} );
-        classCache.put("setSessionCookieConfig",
-                new Class[]{SessionCookieConfig.class});
     }
 
 
@@ -414,7 +421,7 @@ public final class ApplicationContextFacade
             Filter filter) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
             return (FilterRegistration.Dynamic) doPrivileged(
-                    "addFilter", new Object[]{filterName, filter});
+                    "addFilter", new Class[]{String.class, Filter.class}, new Object[]{filterName, filter});
         } else {
             return context.addFilter(filterName, filter);
         }
@@ -425,7 +432,7 @@ public final class ApplicationContextFacade
             Class<? extends Filter> filterClass) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
             return (FilterRegistration.Dynamic) doPrivileged(
-                    "addFilter", new Object[]{filterName, filterClass});
+                    "addFilter", new Object[]{filterName, filterClass.getName()});
         } else {
             return context.addFilter(filterName, filterClass);
         }
@@ -435,8 +442,15 @@ public final class ApplicationContextFacade
     public <T extends Filter> T createFilter(Class<T> c)
     throws ServletException {
         if (SecurityUtil.isPackageProtectionEnabled()) {
-            return (T) doPrivileged(
-                    "createFilter", new Object[]{c});
+            try {
+                return (T) invokeMethod(context, "createFilter", 
+                                              new Object[]{c});
+            } catch (Throwable t) {
+                if (t instanceof ServletException) {
+                    throw (ServletException) t;
+                }
+                return null;
+            }
         } else {
             return context.createFilter(c);
         }
@@ -446,7 +460,7 @@ public final class ApplicationContextFacade
     public FilterRegistration getFilterRegistration(String filterName) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
             return (FilterRegistration) doPrivileged(
-                    "findFilterRegistration", new Object[]{filterName});
+                    "getFilterRegistration", new Object[]{filterName});
         } else {
             return context.getFilterRegistration(filterName);
         }
@@ -468,7 +482,7 @@ public final class ApplicationContextFacade
             Servlet servlet) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
             return (ServletRegistration.Dynamic) doPrivileged(
-                    "addServlet", new Object[]{servletName, servlet});
+                    "addServlet", new Class[]{String.class, Servlet.class}, new Object[]{servletName, servlet});
         } else {
             return context.addServlet(servletName, servlet);
         }
@@ -479,7 +493,7 @@ public final class ApplicationContextFacade
             Class <? extends Servlet> servletClass) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
             return (ServletRegistration.Dynamic) doPrivileged(
-                    "addServlet", new Object[]{servletName, servletClass});
+                    "addServlet", new Object[]{servletName, servletClass.getName()});
         } else {
             return context.addServlet(servletName, servletClass);
         }
@@ -490,8 +504,15 @@ public final class ApplicationContextFacade
     public <T extends Servlet> T createServlet(Class<T> c)
     throws ServletException {
         if (SecurityUtil.isPackageProtectionEnabled()) {
-            return (T) doPrivileged(
-                    "createServlet", new Object[]{c});
+            try {
+                return (T) invokeMethod(context, "createServlet", 
+                                              new Object[]{c});
+            } catch (Throwable t) {
+                if (t instanceof ServletException) {
+                    throw (ServletException) t;
+                }
+                return null;
+            }
         } else {
             return context.createServlet(c);
         }
@@ -501,7 +522,7 @@ public final class ApplicationContextFacade
     public ServletRegistration getServletRegistration(String servletName) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
             return (ServletRegistration) doPrivileged(
-                    "findServletRegistration", new Object[]{servletName});
+                    "getServletRegistration", new Object[]{servletName});
         } else {
             return context.getServletRegistration(servletName);
         }
@@ -564,7 +585,7 @@ public final class ApplicationContextFacade
     public void addListener(Class<? extends EventListener> listenerClass) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
             doPrivileged("addListener",
-                    new Object[]{listenerClass});
+                    new Object[]{listenerClass.getName()});
         } else {
             context.addListener(listenerClass);
         }
@@ -586,7 +607,7 @@ public final class ApplicationContextFacade
     public <T extends EventListener> void addListener(T t) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
             doPrivileged("addListener",
-                    new Object[]{t});
+                    new Object[]{t.getClass().getName()});
         } else {
             context.addListener(t);
         }
@@ -598,7 +619,15 @@ public final class ApplicationContextFacade
     public <T extends EventListener> T createListener(Class<T> c)
             throws ServletException {
         if (SecurityUtil.isPackageProtectionEnabled()) {
-            return (T) doPrivileged("createListener", new Object[]{c});
+            try {
+                return (T) invokeMethod(context, "createListener", 
+                                              new Object[]{c});
+            } catch (Throwable t) {
+                if (t instanceof ServletException) {
+                    throw (ServletException) t;
+                }
+                return null;
+            }
         } else {
             return context.createListener(c);
         }
@@ -608,6 +637,7 @@ public final class ApplicationContextFacade
     @Override
     public void declareRoles(String... roleNames) {
         if (SecurityUtil.isPackageProtectionEnabled()) {
+//FIXME
             doPrivileged("declareRoles",
                     new Object[]{roleNames});
         } else {
@@ -685,11 +715,10 @@ public final class ApplicationContextFacade
     /**
      * Use reflection to invoke the requested method. Cache the method object 
      * to speed up the process
-     *                   will be invoked
      * @param methodName The method to call.
      * @param params The arguments passed to the called method.
      */
-    private Object doPrivileged(final String methodName, final Object[] params){
+    private Object doPrivileged(final String methodName, final Object[] params) {
         try{
             return invokeMethod(context, methodName, params);
         }catch(Throwable t){
@@ -737,7 +766,7 @@ public final class ApplicationContextFacade
      */    
     private Object doPrivileged(final String methodName, 
                                 final Class<?>[] clazz,
-                                Object[] params){
+                                Object[] params) {
 
         try{
             Method method = context.getClass().getMethod(methodName, clazz);

commit 502aab982bd98ebce522bb73fe5414ebca705a36
Author: Rainer Jung <rjung@apache.org>
Date:   Sun Apr 11 17:47:00 2010 +0000

    Allow JioEndpoint to switch context class loader
    under security manager. Code copied from standard session.
    
    Add two more classes to class pre-loading to improve
    security manager interoperability.
    
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@932953 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index 7e8006c..ed1f975 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -131,6 +131,7 @@ public final class SecurityClassLoad {
         throws Exception {
         String basePackage = "org.apache.catalina.";
         loader.loadClass(basePackage + "util.Enumerator");
+        loader.loadClass(basePackage + "util.ParameterMap");
     }
     
     
@@ -234,6 +235,8 @@ public final class SecurityClassLoad {
         throws Exception {
         String basePackage = "org.apache.tomcat.";
         loader.loadClass(basePackage + "util.net.SSLSupport$CipherData");
+        loader.loadClass
+            (basePackage + "util.net.JIoEndpoint$PrivilegedSetTccl");
     }
 }
 
diff --git a/java/org/apache/tomcat/util/net/JIoEndpoint.java b/java/org/apache/tomcat/util/net/JIoEndpoint.java
index a4b6c02..ca09f7a 100644
--- a/java/org/apache/tomcat/util/net/JIoEndpoint.java
+++ b/java/org/apache/tomcat/util/net/JIoEndpoint.java
@@ -22,10 +22,13 @@ import java.net.BindException;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketException;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Iterator;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.RejectedExecutionException;
 
+import org.apache.catalina.Globals;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.apache.tomcat.util.IntrospectionUtils;
@@ -507,10 +510,22 @@ public class JIoEndpoint extends AbstractEndpoint {
                     ClassLoader loader = Thread.currentThread().getContextClassLoader();
                     try {
                         //threads should not be created by the webapp classloader
-                        Thread.currentThread().setContextClassLoader(getClass().getClassLoader());
+                        if (Globals.IS_SECURITY_ENABLED) {
+                            PrivilegedAction<Void> pa = new PrivilegedSetTccl(
+                                    getClass().getClassLoader());
+                            AccessController.doPrivileged(pa);
+                        } else {
+                            Thread.currentThread().setContextClassLoader(
+                                    getClass().getClassLoader());
+                        }
                         getExecutor().execute(proc);
                     }finally {
-                        Thread.currentThread().setContextClassLoader(loader);
+                        if (Globals.IS_SECURITY_ENABLED) {
+                            PrivilegedAction<Void> pa = new PrivilegedSetTccl(loader);
+                            AccessController.doPrivileged(pa);
+                        } else {
+                            Thread.currentThread().setContextClassLoader(loader);
+                        }
                     }
                 }
             }
@@ -524,5 +539,20 @@ public class JIoEndpoint extends AbstractEndpoint {
     }
 
     protected ConcurrentLinkedQueue<SocketWrapper> waitingRequests = new ConcurrentLinkedQueue<SocketWrapper>();
+
+    private static class PrivilegedSetTccl
+    implements PrivilegedAction<Void> {
+
+        private ClassLoader cl;
+
+        PrivilegedSetTccl(ClassLoader cl) {
+            this.cl = cl;
+        }
+
+        public Void run() {
+            Thread.currentThread().setContextClassLoader(cl);
+            return null;
+        }
+    }
     
 }

commit 8848f504dcbb3ec53df4e2533a2657b355dbeb50
Author: Rainer Jung <rjung@apache.org>
Date:   Sun Apr 11 01:26:43 2010 +0000

    Add another property access to our security policy.
    
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@932823 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/conf/catalina.policy b/conf/catalina.policy
index 625d4e5..5b9ae49 100644
--- a/conf/catalina.policy
+++ b/conf/catalina.policy
@@ -161,8 +161,9 @@ grant {
     permission java.util.PropertyPermission
      "org.apache.el.parser.COERCE_TO_ZERO", "read";
 
-    // E.g. the cookie code needs that.
+    // E.g. the cookie code needs those.
     permission java.util.PropertyPermission "org.apache.catalina.STRICT_SERVLET_COMPLIANCE", "read";
+    permission java.util.PropertyPermission "org.apache.tomcat.util.http.ServerCookie.FWD_SLASH_IS_SEPARATOR", "read";
 
     // Applications using Comet need to be able to access this package
     permission java.lang.RuntimePermission "accessClassInPackage.org.apache.catalina.comet";

commit 528deefeffafd6ad629effb577e065983c5f5d8b
Author: Rainer Jung <rjung@apache.org>
Date:   Sun Apr 11 01:08:09 2010 +0000

    Add permission to read the STRICT_SERVLET_COMPLIANCE property
    to our default policy for the security manager.
    
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@932822 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/conf/catalina.policy b/conf/catalina.policy
index 175dd5e..625d4e5 100644
--- a/conf/catalina.policy
+++ b/conf/catalina.policy
@@ -161,6 +161,9 @@ grant {
     permission java.util.PropertyPermission
      "org.apache.el.parser.COERCE_TO_ZERO", "read";
 
+    // E.g. the cookie code needs that.
+    permission java.util.PropertyPermission "org.apache.catalina.STRICT_SERVLET_COMPLIANCE", "read";
+
     // Applications using Comet need to be able to access this package
     permission java.lang.RuntimePermission "accessClassInPackage.org.apache.catalina.comet";
 };

commit 96ef910b645485beba798206c223bb4421516bf8
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Sat Apr 10 15:53:14 2010 +0000

    TCK failure (with security manager): Preload required class.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@932751 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index 01ddac3..0a9a83f 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -62,6 +62,21 @@ public final class SecurityClassLoad {
              "core.ApplicationDispatcher$PrivilegedInclude");
         loader.loadClass
             (basePackage +
+            "core.AsyncContextImpl");
+        loader.loadClass
+            (basePackage +
+            "core.AsyncContextImpl$AsyncState");
+        loader.loadClass
+            (basePackage +
+            "core.AsyncContextImpl$DebugException");
+        loader.loadClass
+            (basePackage +
+            "core.AsyncContextImpl$1");
+        loader.loadClass
+            (basePackage +
+            "core.AsyncContextImpl$2");
+        loader.loadClass
+            (basePackage +
              "core.ContainerBase$PrivilegedAddChild");
         loader.loadClass
             (basePackage +

commit a8c8750f39ec9927aab36a05a6093dc890439dec
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Mon Mar 22 21:00:24 2010 +0000

    Provide the method expected by the digester for adding security-role-ref elements
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@926332 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/deploy/ServletDef.java b/java/org/apache/catalina/deploy/ServletDef.java
index 38b44c6..a6d3997 100644
--- a/java/org/apache/catalina/deploy/ServletDef.java
+++ b/java/org/apache/catalina/deploy/ServletDef.java
@@ -212,6 +212,17 @@ public class ServletDef implements Serializable {
         securityRoleRefs.add(securityRoleRef);
     }
 
+    /**
+     * Add a security-role-ref to the set of security-role-refs associated
+     * with this servlet.
+     */
+    public void addSecurityRoleRef(String roleName, String roleLink) {
+        SecurityRoleRef srr = new SecurityRoleRef();
+        srr.setName(roleName);
+        srr.setLink(roleLink);
+        securityRoleRefs.add(srr);
+    }
+
     
     /**
      * The multipart configuration, if any, for this servlet

commit bf80ddaa399729c2c76072e2ad10d848110c67a5
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Thu Feb 11 12:23:36 2010 +0000

    This is no longer security related as unsafe usage is blocked
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@908942 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/webapps/docs/config/systemprops.xml b/webapps/docs/config/systemprops.xml
index 7446507..db41d39 100644
--- a/webapps/docs/config/systemprops.xml
+++ b/webapps/docs/config/systemprops.xml
@@ -200,15 +200,6 @@
       be used.</p>
     </property>
 
-    <property
-    name="org.apache.coyote. USE_CUSTOM_STATUS_MSG_IN_HEADER"><p>If this is
-      <code>true</code>, custom HTTP status messages will be used within HTTP
-      headers. If a custom message is specified that is not valid for use in an
-      HTTP header (as defined by RFC2616) then the custom message will be
-      ignored and the default message used. If not specified, the default value
-      of <code>false</code> will be used.</p>
-    </property>
-
   </properties>
 
 </section>
@@ -397,6 +388,15 @@
 
   <properties>
 
+    <property
+    name="org.apache.coyote. USE_CUSTOM_STATUS_MSG_IN_HEADER"><p>If this is
+      <code>true</code>, custom HTTP status messages will be used within HTTP
+      headers. If a custom message is specified that is not valid for use in an
+      HTTP header (as defined by RFC2616) then the custom message will be
+      ignored and the default message used. If not specified, the default value
+      of <code>false</code> will be used.</p>
+    </property>
+
     <property name="catalina.useNaming">
       <p>If this is <code>false</code> it will override the
       <code>useNaming</code> attribute for all <a href="context.html">

commit cf05c25164b05b5735f26ce53fc5c9b93656335c
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Thu Jan 14 21:33:58 2010 +0000

    Fix TCK failures with security manager due to fix for bug 47774
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@899420 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index 483eac6..01ddac3 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -99,6 +99,8 @@ public final class SecurityClassLoad {
         loader.loadClass
             (basePackage + "session.StandardSession");
         loader.loadClass
+            (basePackage + "session.StandardSession$PrivilegedSetTccl");
+        loader.loadClass
             (basePackage +
              "session.StandardSession$1");
         loader.loadClass
diff --git a/java/org/apache/catalina/session/StandardSession.java b/java/org/apache/catalina/session/StandardSession.java
index 19f0612..5236e27 100644
--- a/java/org/apache/catalina/session/StandardSession.java
+++ b/java/org/apache/catalina/session/StandardSession.java
@@ -710,8 +710,14 @@ public class StandardSession
             if (context.getLoader() != null &&
                     context.getLoader().getClassLoader() != null) {
                 oldTccl = Thread.currentThread().getContextClassLoader();
-                Thread.currentThread().setContextClassLoader(
-                        context.getLoader().getClassLoader());
+                if (Globals.IS_SECURITY_ENABLED) {
+                    PrivilegedAction<Void> pa = new PrivilegedSetTccl(
+                            context.getLoader().getClassLoader());
+                    AccessController.doPrivileged(pa);
+                } else {
+                    Thread.currentThread().setContextClassLoader(
+                            context.getLoader().getClassLoader());
+                }
             }
             try {
                 Object listeners[] = context.getApplicationLifecycleListeners();
@@ -747,7 +753,13 @@ public class StandardSession
                 }
             } finally {
                 if (oldTccl != null) {
-                    Thread.currentThread().setContextClassLoader(oldTccl);
+                    if (Globals.IS_SECURITY_ENABLED) {
+                        PrivilegedAction<Void> pa =
+                            new PrivilegedSetTccl(oldTccl);
+                        AccessController.doPrivileged(pa);
+                    } else {
+                        Thread.currentThread().setContextClassLoader(oldTccl);
+                    }
                 }
             }
 
@@ -1732,6 +1744,21 @@ public class StandardSession
     }
 
 
+    private static class PrivilegedSetTccl
+    implements PrivilegedAction<Void> {
+
+        private ClassLoader cl;
+
+        PrivilegedSetTccl(ClassLoader cl) {
+            this.cl = cl;
+        }
+
+        public Void run() {
+            Thread.currentThread().setContextClassLoader(cl);
+            return null;
+        }
+    }
+
 }
 
 

commit 51d5511dd33f82075207de11515235825544add8
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Mon Dec 14 14:53:00 2009 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=47744
    Prevent medium term memory leak when ussing SSL with a security manager
    Based on a patch by Greg Vanore
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@890350 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/tomcat/util/net/jsse/JSSESupport.java b/java/org/apache/tomcat/util/net/jsse/JSSESupport.java
index 30c72ff..8087435 100644
--- a/java/org/apache/tomcat/util/net/jsse/JSSESupport.java
+++ b/java/org/apache/tomcat/util/net/jsse/JSSESupport.java
@@ -23,6 +23,8 @@ import java.io.InputStream;
 import java.net.SocketException;
 import java.security.cert.Certificate;
 import java.security.cert.CertificateFactory;
+import java.util.Map;
+import java.util.WeakHashMap;
 
 import javax.net.ssl.HandshakeCompletedEvent;
 import javax.net.ssl.HandshakeCompletedListener;
@@ -53,6 +55,9 @@ class JSSESupport implements SSLSupport, SSLSessionManager {
     
     private static final org.apache.juli.logging.Log log =
         org.apache.juli.logging.LogFactory.getLog(JSSESupport.class);
+    
+    private static final Map<SSLSession,Integer> keySizeCache =
+        new WeakHashMap<SSLSession, Integer>();
 
     protected SSLSocket ssl;
     protected SSLSession session;
@@ -196,7 +201,12 @@ class JSSESupport implements SSLSupport, SSLSessionManager {
         SSLSupport.CipherData c_aux[]=ciphers;
         if (session == null)
             return null;
-        Integer keySize = (Integer) session.getValue(KEY_SIZE_KEY);
+        
+        Integer keySize = null;
+        synchronized(keySizeCache) {
+            keySize = keySizeCache.get(session);
+        }
+        
         if (keySize == null) {
             int size = 0;
             String cipherSuite = session.getCipherSuite();
@@ -207,7 +217,9 @@ class JSSESupport implements SSLSupport, SSLSessionManager {
                 }
             }
             keySize = new Integer(size);
-            session.putValue(KEY_SIZE_KEY, keySize);
+            synchronized(keySizeCache) {
+                keySizeCache.put(session, keySize);
+            }
         }
         return keySize;
     }

commit df6feed1d22f68c63fd81206441bd11b09ccc9cd
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Mon Dec 14 14:51:12 2009 +0000

    Pre-load a class required for apps to obtain the SSL key size when running under a security manager
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@890349 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index 3c3a5cf..483eac6 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -44,6 +44,7 @@ public final class SecurityClassLoad {
         loadJavaxPackage(loader);
         loadCoyotePackage(loader);        
         loadHttp11Package(loader);        
+        loadTomcatPackage(loader);
     }
     
     
@@ -209,5 +210,10 @@ public final class SecurityClassLoad {
              "Response$3");
     }
 
+    private final static void loadTomcatPackage(ClassLoader loader)
+        throws Exception {
+        String basePackage = "org.apache.tomcat.";
+        loader.loadClass(basePackage + "util.net.SSLSupport$CipherData");
+    }
 }
 

commit 3cb92e016ed9eabbe5456ef8d78f2ba1d2c70fc2
Author: Konstantin Kolinko <kkolinko@apache.org>
Date:   Wed Nov 18 03:00:57 2009 +0000

    Wrapped long lines. As the text of this file is copy-pasted into security-manager-howto.html, it will make it more readable.
    
    Added a comment regarding tomcat-juli.jar
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@881654 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/conf/catalina.policy b/conf/catalina.policy
index 2db96a1..175dd5e 100644
--- a/conf/catalina.policy
+++ b/conf/catalina.policy
@@ -62,22 +62,32 @@ grant codeBase "file:${catalina.home}/bin/commons-daemon.jar" {
 };
 
 // These permissions apply to the logging API
+// Note: If tomcat-juli.jar is in ${catalina.base} and not in ${catalina.home},
+// update this section accordingly.
 grant codeBase "file:${catalina.home}/bin/tomcat-juli.jar" {
         permission java.util.PropertyPermission "java.util.logging.config.class", "read";
         permission java.util.PropertyPermission "java.util.logging.config.file", "read";
         permission java.util.PropertyPermission "catalina.base", "read";
-        permission java.io.FilePermission "${java.home}${file.separator}lib${file.separator}logging.properties", "read"; 
-        permission java.io.FilePermission "${catalina.base}${file.separator}conf${file.separator}logging.properties", "read";
-        permission java.io.FilePermission "${catalina.base}${file.separator}logs", "read, write";
-        permission java.io.FilePermission "${catalina.base}${file.separator}logs${file.separator}*", "read, write";
+        permission java.io.FilePermission
+         "${java.home}${file.separator}lib${file.separator}logging.properties", "read"; 
+        permission java.io.FilePermission
+         "${catalina.base}${file.separator}conf${file.separator}logging.properties", "read";
+        permission java.io.FilePermission
+         "${catalina.base}${file.separator}logs", "read, write";
+        permission java.io.FilePermission
+         "${catalina.base}${file.separator}logs${file.separator}*", "read, write";
         permission java.lang.RuntimePermission "shutdownHooks";
         permission java.lang.RuntimePermission "getClassLoader";
         permission java.lang.RuntimePermission "setContextClassLoader";
         permission java.util.logging.LoggingPermission "control";
-        // To enable per context logging configuration, permit read access to the appropriate file.
-        // Be sure that the logging configuration is secure before enabling such access.
-        // E.g. for the examples web application:
-        // permission java.io.FilePermission "${catalina.base}${file.separator}webapps${file.separator}examples${file.separator}WEB-INF${file.separator}classes${file.separator}logging.properties", "read";
+
+        // To enable per context logging configuration, permit read access to
+        // the appropriate file. Be sure that the logging configuration is
+        // secure before enabling such access. E.g. for the examples web
+        // application:
+        // permission java.io.FilePermission "${catalina.base}${file.separator}
+        //  webapps${file.separator}examples${file.separator}
+        //  WEB-INF${file.separator}classes${file.separator}logging.properties", "read";
 };
 
 // These permissions apply to the server startup code
@@ -142,11 +152,14 @@ grant {
     // Precompiled JSPs need access to these packages.
     permission java.lang.RuntimePermission "accessClassInPackage.org.apache.jasper.el";
     permission java.lang.RuntimePermission "accessClassInPackage.org.apache.jasper.runtime";
-    permission java.lang.RuntimePermission "accessClassInPackage.org.apache.jasper.runtime.*";
+    permission java.lang.RuntimePermission
+     "accessClassInPackage.org.apache.jasper.runtime.*";
 
     // Precompiled JSPs need access to these system properties.
-    permission java.util.PropertyPermission "org.apache.jasper.runtime.BodyContentImpl.LIMIT_BUFFER", "read";
-    permission java.util.PropertyPermission "org.apache.el.parser.COERCE_TO_ZERO", "read";
+    permission java.util.PropertyPermission
+     "org.apache.jasper.runtime.BodyContentImpl.LIMIT_BUFFER", "read";
+    permission java.util.PropertyPermission
+     "org.apache.el.parser.COERCE_TO_ZERO", "read";
 
     // Applications using Comet need to be able to access this package
     permission java.lang.RuntimePermission "accessClassInPackage.org.apache.catalina.comet";

commit f99ee02b332b7b0499ab79bc2acd2a434c325ceb
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Fri Nov 6 18:26:39 2009 +0000

    Comet didn't work at all under a security manger. Need to allow web apps access to the comet interfaces so move those interfaces to a separate package so we can grant access.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@833510 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/conf/catalina.policy b/conf/catalina.policy
index 63e4b62..8a8e51f 100644
--- a/conf/catalina.policy
+++ b/conf/catalina.policy
@@ -146,6 +146,9 @@ grant {
     // Precompiled JSPs need access to these system properties.
     permission java.util.PropertyPermission "org.apache.jasper.runtime.BodyContentImpl.LIMIT_BUFFER", "read";
     permission java.util.PropertyPermission "org.apache.el.parser.COERCE_TO_ZERO", "read";
+    
+    // Applications using Comet need to be able to access this package
+    permission java.lang.RuntimePermission "accessClassInPackage.org.apache.catalina.comet";
 };
 
 
diff --git a/java/org/apache/catalina/CometEvent.java b/java/org/apache/catalina/CometEvent.java
deleted file mode 100644
index 341a57e..0000000
--- a/java/org/apache/catalina/CometEvent.java
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-/**
- * The CometEvent interface.
- * 
- * @author Filip Hanik
- * @author Remy Maucherat
- */
-public interface CometEvent {
-
-    /**
-     * Enumeration describing the major events that the container can invoke 
-     * the CometProcessors event() method with
-     * BEGIN - will be called at the beginning 
-     *  of the processing of the connection. It can be used to initialize any relevant 
-     *  fields using the request and response objects. Between the end of the processing 
-     *  of this event, and the beginning of the processing of the end or error events,
-     *  it is possible to use the response object to write data on the open connection.
-     *  Note that the response object and dependent OutputStream and Writer are still 
-     *  not synchronized, so when they are accessed by multiple threads, 
-     *  synchronization is mandatory. After processing the initial event, the request 
-     *  is considered to be committed.
-     * READ - This indicates that input data is available, and that one read can be made
-     *  without blocking. The available and ready methods of the InputStream or
-     *  Reader may be used to determine if there is a risk of blocking: the servlet
-     *  should read while data is reported available. When encountering a read error, 
-     *  the servlet should report it by propagating the exception properly. Throwing 
-     *  an exception will cause the error event to be invoked, and the connection 
-     *  will be closed. 
-     *  Alternately, it is also possible to catch any exception, perform clean up
-     *  on any data structure the servlet may be using, and using the close method
-     *  of the event. It is not allowed to attempt reading data from the request 
-     *  object outside of the execution of this method.
-     * END - End may be called to end the processing of the request. Fields that have
-     *  been initialized in the begin method should be reset. After this event has
-     *  been processed, the request and response objects, as well as all their dependent
-     *  objects will be recycled and used to process other requests. End will also be 
-     *  called when data is available and the end of file is reached on the request input
-     *  (this usually indicates the client has pipelined a request).
-     * ERROR - Error will be called by the container in the case where an IO exception
-     *  or a similar unrecoverable error occurs on the connection. Fields that have
-     *  been initialized in the begin method should be reset. After this event has
-     *  been processed, the request and response objects, as well as all their dependent
-     *  objects will be recycled and used to process other requests.
-     */
-    public enum EventType {BEGIN, READ, END, ERROR}
-    
-    
-    /**
-     * Event details
-     * TIMEOUT - the connection timed out (sub type of ERROR); note that this ERROR type is not fatal, and
-     *   the connection will not be closed unless the servlet uses the close method of the event
-     * CLIENT_DISCONNECT - the client connection was closed (sub type of ERROR)
-     * IOEXCEPTION - an IO exception occurred, such as invalid content, for example, an invalid chunk block (sub type of ERROR)
-     * WEBAPP_RELOAD - the webapplication is being reloaded (sub type of END)
-     * SERVER_SHUTDOWN - the server is shutting down (sub type of END)
-     * SESSION_END - the servlet ended the session (sub type of END)
-     */
-    public enum EventSubType { TIMEOUT, CLIENT_DISCONNECT, IOEXCEPTION, WEBAPP_RELOAD, SERVER_SHUTDOWN, SESSION_END }
-    
-    
-    /**
-     * Returns the HttpServletRequest.
-     * 
-     * @return HttpServletRequest
-     */
-    public HttpServletRequest getHttpServletRequest();
-    
-    /**
-     * Returns the HttpServletResponse.
-     * 
-     * @return HttpServletResponse
-     */
-    public HttpServletResponse getHttpServletResponse();
-    
-    /**
-     * Returns the event type.
-     * 
-     * @return EventType
-     */
-    public EventType getEventType();
-    
-    /**
-     * Returns the sub type of this event.
-     * 
-     * @return EventSubType
-     */
-    public EventSubType getEventSubType();
-    
-    /**
-     * Ends the Comet session. This signals to the container that 
-     * the container wants to end the comet session. This will send back to the
-     * client a notice that the server has no more data to send as part of this
-     * request. The servlet should perform any needed cleanup as if it had received
-     * an END or ERROR event. 
-     * 
-     * @throws IOException if an IO exception occurs
-     */
-    public void close() throws IOException;
-    
-    /**
-     * Sets the timeout for this Comet connection. Please NOTE, that the implementation 
-     * of a per connection timeout is OPTIONAL and MAY NOT be implemented.<br/>
-     * This method sets the timeout in milliseconds of idle time on the connection.
-     * The timeout is reset every time data is received from the connection or data is flushed
-     * using <code>response.flushBuffer()</code>. If a timeout occurs, the 
-     * <code>error(HttpServletRequest, HttpServletResponse)</code> method is invoked. The 
-     * web application SHOULD NOT attempt to reuse the request and response objects after a timeout
-     * as the <code>error(HttpServletRequest, HttpServletResponse)</code> method indicates.<br/>
-     * This method should not be called asynchronously, as that will have no effect.
-     * 
-     * @param timeout The timeout in milliseconds for this connection, must be a positive value, larger than 0
-     * @throws IOException An IOException may be thrown to indicate an IO error, 
-     *         or that the EOF has been reached on the connection
-     * @throws ServletException An exception has occurred, as specified by the root
-     *         cause
-     * @throws UnsupportedOperationException if per connection timeout is not supported, either at all or at this phase
-     *         of the invocation.
-     */
-    public void setTimeout(int timeout)
-        throws IOException, ServletException, UnsupportedOperationException;
-
-}
diff --git a/java/org/apache/catalina/CometFilter.java b/java/org/apache/catalina/CometFilter.java
deleted file mode 100644
index 55cd327..0000000
--- a/java/org/apache/catalina/CometFilter.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina;
-
-import java.io.IOException;
-
-import javax.servlet.Filter;
-import javax.servlet.ServletException;
-
-/**
- * A Comet filter, similar to regular filters, performs filtering tasks on either 
- * the request to a resource (a Comet servlet), or on the response from a resource, or both.
- * <br><br>
- * Filters perform filtering in the <code>doFilterEvent</code> method. Every Filter has access to 
- * a FilterConfig object from which it can obtain its initialization parameters, a
- * reference to the ServletContext which it can use, for example, to load resources
- * needed for filtering tasks.
- * <p>
- * Filters are configured in the deployment descriptor of a web application
- * <p>
- * Examples that have been identified for this design are<br>
- * 1) Authentication Filters <br>
- * 2) Logging and Auditing Filters <br>
- * 3) Image conversion Filters <br>
- * 4) Data compression Filters <br>
- * 5) Encryption Filters <br>
- * 6) Tokenizing Filters <br>
- * 7) Filters that trigger resource access events <br>
- * 8) XSL/T filters <br>
- * 9) Mime-type chain Filter <br>
- * <br>
- * 
- * @author Remy Maucherat
- * @author Filip Hanik
- */
-public interface CometFilter extends Filter {
-
-    
-    /**
-     * The <code>doFilterEvent</code> method of the CometFilter is called by the container
-     * each time a request/response pair is passed through the chain due
-     * to a client event for a resource at the end of the chain. The CometFilterChain passed in to this
-     * method allows the Filter to pass on the event to the next entity in the
-     * chain.<p>
-     * A typical implementation of this method would follow the following pattern:- <br>
-     * 1. Examine the request<br>
-     * 2. Optionally wrap the request object contained in the event with a custom implementation to
-     * filter content or headers for input filtering and pass a CometEvent instance containing
-     * the wrapped request to the next filter<br>
-     * 3. Optionally wrap the response object contained in the event with a custom implementation to
-     * filter content or headers for output filtering and pass a CometEvent instance containing
-     * the wrapped request to the next filter<br>
-     * 4. a) <strong>Either</strong> invoke the next entity in the chain using the CometFilterChain object (<code>chain.doFilterEvent()</code>), <br>   
-     * 4. b) <strong>or</strong> not pass on the request/response pair to the next entity in the filter chain to block the event processing<br>
-     * 5. Directly set fields on the response after invocation of the next entity in the filter chain.
-     * 
-     * @param event the event that is being processed. Another event may be passed along the chain.
-     * @param chain 
-     * @throws IOException
-     * @throws ServletException
-     */
-    public void doFilterEvent(CometEvent event, CometFilterChain chain)
-        throws IOException, ServletException;
-    
-
-}
diff --git a/java/org/apache/catalina/CometFilterChain.java b/java/org/apache/catalina/CometFilterChain.java
deleted file mode 100644
index f0632fc..0000000
--- a/java/org/apache/catalina/CometFilterChain.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-
-/**
- * A CometFilterChain is an object provided by the servlet container to the developer
- * giving a view into the invocation chain of a filtered event for a resource. Filters
- * use the CometFilterChain to invoke the next filter in the chain, or if the calling filter
- * is the last filter in the chain, to invoke the resource at the end of the chain.
- * 
- * @author Remy Maucherat
- * @author Filip Hanik
- */
-public interface CometFilterChain {
-
-    
-    /**
-     * Causes the next filter in the chain to be invoked, or if the calling filter is the last filter
-     * in the chain, causes the resource at the end of the chain to be invoked.
-     *
-     * @param event the event to pass along the chain.
-     */
-    public void doFilterEvent(CometEvent event) throws IOException, ServletException;
-    
-
-}
diff --git a/java/org/apache/catalina/CometProcessor.java b/java/org/apache/catalina/CometProcessor.java
deleted file mode 100644
index 38e9f3b..0000000
--- a/java/org/apache/catalina/CometProcessor.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina;
-
-import java.io.IOException;
-
-import javax.servlet.ServletException;
-import javax.servlet.Servlet;
-
-/**
- * This interface should be implemented by servlets which would like to handle
- * asynchronous IO, receiving events when data is available for reading, and
- * being able to output data without the need for being invoked by the container.
- * Note: When this interface is implemented, the service method of the servlet will
- * never be called, and will be replaced with a begin event.
- */
-public interface CometProcessor extends Servlet{
-
-    /**
-     * Process the given Comet event.
-     * 
-     * @param event The Comet event that will be processed
-     * @throws IOException
-     * @throws ServletException
-     */
-    public void event(CometEvent event)
-        throws IOException, ServletException;
-
-}
diff --git a/java/org/apache/catalina/Valve.java b/java/org/apache/catalina/Valve.java
index 4143170..e2a29fc 100644
--- a/java/org/apache/catalina/Valve.java
+++ b/java/org/apache/catalina/Valve.java
@@ -22,6 +22,7 @@ package org.apache.catalina;
 import java.io.IOException;
 import javax.servlet.ServletException;
 
+import org.apache.catalina.comet.CometEvent;
 import org.apache.catalina.connector.Request;
 import org.apache.catalina.connector.Response;
 
diff --git a/java/org/apache/catalina/comet/CometEvent.java b/java/org/apache/catalina/comet/CometEvent.java
new file mode 100644
index 0000000..29a884a
--- /dev/null
+++ b/java/org/apache/catalina/comet/CometEvent.java
@@ -0,0 +1,147 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.comet;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+/**
+ * The CometEvent interface.
+ * 
+ * @author Filip Hanik
+ * @author Remy Maucherat
+ */
+public interface CometEvent {
+
+    /**
+     * Enumeration describing the major events that the container can invoke 
+     * the CometProcessors event() method with
+     * BEGIN - will be called at the beginning 
+     *  of the processing of the connection. It can be used to initialize any relevant 
+     *  fields using the request and response objects. Between the end of the processing 
+     *  of this event, and the beginning of the processing of the end or error events,
+     *  it is possible to use the response object to write data on the open connection.
+     *  Note that the response object and dependent OutputStream and Writer are still 
+     *  not synchronized, so when they are accessed by multiple threads, 
+     *  synchronization is mandatory. After processing the initial event, the request 
+     *  is considered to be committed.
+     * READ - This indicates that input data is available, and that one read can be made
+     *  without blocking. The available and ready methods of the InputStream or
+     *  Reader may be used to determine if there is a risk of blocking: the servlet
+     *  should read while data is reported available. When encountering a read error, 
+     *  the servlet should report it by propagating the exception properly. Throwing 
+     *  an exception will cause the error event to be invoked, and the connection 
+     *  will be closed. 
+     *  Alternately, it is also possible to catch any exception, perform clean up
+     *  on any data structure the servlet may be using, and using the close method
+     *  of the event. It is not allowed to attempt reading data from the request 
+     *  object outside of the execution of this method.
+     * END - End may be called to end the processing of the request. Fields that have
+     *  been initialized in the begin method should be reset. After this event has
+     *  been processed, the request and response objects, as well as all their dependent
+     *  objects will be recycled and used to process other requests. End will also be 
+     *  called when data is available and the end of file is reached on the request input
+     *  (this usually indicates the client has pipelined a request).
+     * ERROR - Error will be called by the container in the case where an IO exception
+     *  or a similar unrecoverable error occurs on the connection. Fields that have
+     *  been initialized in the begin method should be reset. After this event has
+     *  been processed, the request and response objects, as well as all their dependent
+     *  objects will be recycled and used to process other requests.
+     */
+    public enum EventType {BEGIN, READ, END, ERROR}
+    
+    
+    /**
+     * Event details
+     * TIMEOUT - the connection timed out (sub type of ERROR); note that this ERROR type is not fatal, and
+     *   the connection will not be closed unless the servlet uses the close method of the event
+     * CLIENT_DISCONNECT - the client connection was closed (sub type of ERROR)
+     * IOEXCEPTION - an IO exception occurred, such as invalid content, for example, an invalid chunk block (sub type of ERROR)
+     * WEBAPP_RELOAD - the webapplication is being reloaded (sub type of END)
+     * SERVER_SHUTDOWN - the server is shutting down (sub type of END)
+     * SESSION_END - the servlet ended the session (sub type of END)
+     */
+    public enum EventSubType { TIMEOUT, CLIENT_DISCONNECT, IOEXCEPTION, WEBAPP_RELOAD, SERVER_SHUTDOWN, SESSION_END }
+    
+    
+    /**
+     * Returns the HttpServletRequest.
+     * 
+     * @return HttpServletRequest
+     */
+    public HttpServletRequest getHttpServletRequest();
+    
+    /**
+     * Returns the HttpServletResponse.
+     * 
+     * @return HttpServletResponse
+     */
+    public HttpServletResponse getHttpServletResponse();
+    
+    /**
+     * Returns the event type.
+     * 
+     * @return EventType
+     */
+    public EventType getEventType();
+    
+    /**
+     * Returns the sub type of this event.
+     * 
+     * @return EventSubType
+     */
+    public EventSubType getEventSubType();
+    
+    /**
+     * Ends the Comet session. This signals to the container that 
+     * the container wants to end the comet session. This will send back to the
+     * client a notice that the server has no more data to send as part of this
+     * request. The servlet should perform any needed cleanup as if it had received
+     * an END or ERROR event. 
+     * 
+     * @throws IOException if an IO exception occurs
+     */
+    public void close() throws IOException;
+    
+    /**
+     * Sets the timeout for this Comet connection. Please NOTE, that the implementation 
+     * of a per connection timeout is OPTIONAL and MAY NOT be implemented.<br/>
+     * This method sets the timeout in milliseconds of idle time on the connection.
+     * The timeout is reset every time data is received from the connection or data is flushed
+     * using <code>response.flushBuffer()</code>. If a timeout occurs, the 
+     * <code>error(HttpServletRequest, HttpServletResponse)</code> method is invoked. The 
+     * web application SHOULD NOT attempt to reuse the request and response objects after a timeout
+     * as the <code>error(HttpServletRequest, HttpServletResponse)</code> method indicates.<br/>
+     * This method should not be called asynchronously, as that will have no effect.
+     * 
+     * @param timeout The timeout in milliseconds for this connection, must be a positive value, larger than 0
+     * @throws IOException An IOException may be thrown to indicate an IO error, 
+     *         or that the EOF has been reached on the connection
+     * @throws ServletException An exception has occurred, as specified by the root
+     *         cause
+     * @throws UnsupportedOperationException if per connection timeout is not supported, either at all or at this phase
+     *         of the invocation.
+     */
+    public void setTimeout(int timeout)
+        throws IOException, ServletException, UnsupportedOperationException;
+
+}
diff --git a/java/org/apache/catalina/comet/CometFilter.java b/java/org/apache/catalina/comet/CometFilter.java
new file mode 100644
index 0000000..2b69bc4
--- /dev/null
+++ b/java/org/apache/catalina/comet/CometFilter.java
@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.comet;
+
+import java.io.IOException;
+
+import javax.servlet.Filter;
+import javax.servlet.ServletException;
+
+/**
+ * A Comet filter, similar to regular filters, performs filtering tasks on either 
+ * the request to a resource (a Comet servlet), or on the response from a resource, or both.
+ * <br><br>
+ * Filters perform filtering in the <code>doFilterEvent</code> method. Every Filter has access to 
+ * a FilterConfig object from which it can obtain its initialization parameters, a
+ * reference to the ServletContext which it can use, for example, to load resources
+ * needed for filtering tasks.
+ * <p>
+ * Filters are configured in the deployment descriptor of a web application
+ * <p>
+ * Examples that have been identified for this design are<br>
+ * 1) Authentication Filters <br>
+ * 2) Logging and Auditing Filters <br>
+ * 3) Image conversion Filters <br>
+ * 4) Data compression Filters <br>
+ * 5) Encryption Filters <br>
+ * 6) Tokenizing Filters <br>
+ * 7) Filters that trigger resource access events <br>
+ * 8) XSL/T filters <br>
+ * 9) Mime-type chain Filter <br>
+ * <br>
+ * 
+ * @author Remy Maucherat
+ * @author Filip Hanik
+ */
+public interface CometFilter extends Filter {
+
+    
+    /**
+     * The <code>doFilterEvent</code> method of the CometFilter is called by the container
+     * each time a request/response pair is passed through the chain due
+     * to a client event for a resource at the end of the chain. The CometFilterChain passed in to this
+     * method allows the Filter to pass on the event to the next entity in the
+     * chain.<p>
+     * A typical implementation of this method would follow the following pattern:- <br>
+     * 1. Examine the request<br>
+     * 2. Optionally wrap the request object contained in the event with a custom implementation to
+     * filter content or headers for input filtering and pass a CometEvent instance containing
+     * the wrapped request to the next filter<br>
+     * 3. Optionally wrap the response object contained in the event with a custom implementation to
+     * filter content or headers for output filtering and pass a CometEvent instance containing
+     * the wrapped request to the next filter<br>
+     * 4. a) <strong>Either</strong> invoke the next entity in the chain using the CometFilterChain object (<code>chain.doFilterEvent()</code>), <br>   
+     * 4. b) <strong>or</strong> not pass on the request/response pair to the next entity in the filter chain to block the event processing<br>
+     * 5. Directly set fields on the response after invocation of the next entity in the filter chain.
+     * 
+     * @param event the event that is being processed. Another event may be passed along the chain.
+     * @param chain 
+     * @throws IOException
+     * @throws ServletException
+     */
+    public void doFilterEvent(CometEvent event, CometFilterChain chain)
+        throws IOException, ServletException;
+    
+
+}
diff --git a/java/org/apache/catalina/comet/CometFilterChain.java b/java/org/apache/catalina/comet/CometFilterChain.java
new file mode 100644
index 0000000..b4ca50e
--- /dev/null
+++ b/java/org/apache/catalina/comet/CometFilterChain.java
@@ -0,0 +1,46 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.comet;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+
+/**
+ * A CometFilterChain is an object provided by the servlet container to the developer
+ * giving a view into the invocation chain of a filtered event for a resource. Filters
+ * use the CometFilterChain to invoke the next filter in the chain, or if the calling filter
+ * is the last filter in the chain, to invoke the resource at the end of the chain.
+ * 
+ * @author Remy Maucherat
+ * @author Filip Hanik
+ */
+public interface CometFilterChain {
+
+    
+    /**
+     * Causes the next filter in the chain to be invoked, or if the calling filter is the last filter
+     * in the chain, causes the resource at the end of the chain to be invoked.
+     *
+     * @param event the event to pass along the chain.
+     */
+    public void doFilterEvent(CometEvent event) throws IOException, ServletException;
+    
+
+}
diff --git a/java/org/apache/catalina/comet/CometProcessor.java b/java/org/apache/catalina/comet/CometProcessor.java
new file mode 100644
index 0000000..a652129
--- /dev/null
+++ b/java/org/apache/catalina/comet/CometProcessor.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.catalina.comet;
+
+import java.io.IOException;
+
+import javax.servlet.ServletException;
+import javax.servlet.Servlet;
+
+/**
+ * This interface should be implemented by servlets which would like to handle
+ * asynchronous IO, receiving events when data is available for reading, and
+ * being able to output data without the need for being invoked by the container.
+ * Note: When this interface is implemented, the service method of the servlet will
+ * never be called, and will be replaced with a begin event.
+ */
+public interface CometProcessor extends Servlet{
+
+    /**
+     * Process the given Comet event.
+     * 
+     * @param event The Comet event that will be processed
+     * @throws IOException
+     * @throws ServletException
+     */
+    public void event(CometEvent event)
+        throws IOException, ServletException;
+
+}
diff --git a/java/org/apache/catalina/connector/CometEventImpl.java b/java/org/apache/catalina/connector/CometEventImpl.java
index 0da2f56..051d566 100644
--- a/java/org/apache/catalina/connector/CometEventImpl.java
+++ b/java/org/apache/catalina/connector/CometEventImpl.java
@@ -24,7 +24,7 @@ import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
-import org.apache.catalina.CometEvent;
+import org.apache.catalina.comet.CometEvent;
 import org.apache.tomcat.util.res.StringManager;
 
 public class CometEventImpl implements CometEvent {
diff --git a/java/org/apache/catalina/connector/CoyoteAdapter.java b/java/org/apache/catalina/connector/CoyoteAdapter.java
index 2aabdc7..16c1d42 100644
--- a/java/org/apache/catalina/connector/CoyoteAdapter.java
+++ b/java/org/apache/catalina/connector/CoyoteAdapter.java
@@ -24,11 +24,11 @@ import java.util.EnumSet;
 
 import javax.servlet.SessionTrackingMode;
 
-import org.apache.catalina.CometEvent;
 import org.apache.catalina.Context;
 import org.apache.catalina.Globals;
 import org.apache.catalina.Wrapper;
 import org.apache.tomcat.util.res.StringManager;
+import org.apache.catalina.comet.CometEvent;
 import org.apache.catalina.core.AsyncContextImpl;
 import org.apache.catalina.util.URLEncoder;
 import org.apache.coyote.ActionCode;
diff --git a/java/org/apache/catalina/core/ApplicationFilterChain.java b/java/org/apache/catalina/core/ApplicationFilterChain.java
index 2b577a9..49da22a 100644
--- a/java/org/apache/catalina/core/ApplicationFilterChain.java
+++ b/java/org/apache/catalina/core/ApplicationFilterChain.java
@@ -32,12 +32,12 @@ import javax.servlet.ServletResponse;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
-import org.apache.catalina.CometEvent;
-import org.apache.catalina.CometFilter;
-import org.apache.catalina.CometFilterChain;
-import org.apache.catalina.CometProcessor;
 import org.apache.catalina.Globals;
 import org.apache.catalina.InstanceEvent;
+import org.apache.catalina.comet.CometEvent;
+import org.apache.catalina.comet.CometFilter;
+import org.apache.catalina.comet.CometFilterChain;
+import org.apache.catalina.comet.CometProcessor;
 import org.apache.catalina.security.SecurityUtil;
 import org.apache.catalina.util.InstanceSupport;
 import org.apache.tomcat.util.res.StringManager;
diff --git a/java/org/apache/catalina/core/ApplicationFilterFactory.java b/java/org/apache/catalina/core/ApplicationFilterFactory.java
index b8b981c..6a450e6 100644
--- a/java/org/apache/catalina/core/ApplicationFilterFactory.java
+++ b/java/org/apache/catalina/core/ApplicationFilterFactory.java
@@ -23,9 +23,9 @@ import javax.servlet.DispatcherType;
 import javax.servlet.Servlet;
 import javax.servlet.ServletRequest;
 
-import org.apache.catalina.CometFilter;
 import org.apache.catalina.Globals;
 import org.apache.catalina.Wrapper;
+import org.apache.catalina.comet.CometFilter;
 import org.apache.catalina.connector.Request;
 import org.apache.catalina.deploy.FilterMap;
 
diff --git a/java/org/apache/catalina/core/StandardContextValve.java b/java/org/apache/catalina/core/StandardContextValve.java
index 9e8a008..5b91e3e 100644
--- a/java/org/apache/catalina/core/StandardContextValve.java
+++ b/java/org/apache/catalina/core/StandardContextValve.java
@@ -27,10 +27,10 @@ import javax.servlet.ServletRequestEvent;
 import javax.servlet.ServletRequestListener;
 import javax.servlet.http.HttpServletResponse;
 
-import org.apache.catalina.CometEvent;
 import org.apache.catalina.Container;
 import org.apache.catalina.Globals;
 import org.apache.catalina.Wrapper;
+import org.apache.catalina.comet.CometEvent;
 import org.apache.catalina.connector.Request;
 import org.apache.catalina.connector.Response;
 import org.apache.tomcat.util.res.StringManager;
diff --git a/java/org/apache/catalina/core/StandardEngineValve.java b/java/org/apache/catalina/core/StandardEngineValve.java
index b2df268..320720e 100644
--- a/java/org/apache/catalina/core/StandardEngineValve.java
+++ b/java/org/apache/catalina/core/StandardEngineValve.java
@@ -24,8 +24,8 @@ import java.io.IOException;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletResponse;
 
-import org.apache.catalina.CometEvent;
 import org.apache.catalina.Host;
+import org.apache.catalina.comet.CometEvent;
 import org.apache.catalina.connector.Request;
 import org.apache.catalina.connector.Response;
 import org.apache.tomcat.util.res.StringManager;
diff --git a/java/org/apache/catalina/core/StandardHostValve.java b/java/org/apache/catalina/core/StandardHostValve.java
index 9dd2433..f22b948 100644
--- a/java/org/apache/catalina/core/StandardHostValve.java
+++ b/java/org/apache/catalina/core/StandardHostValve.java
@@ -27,10 +27,10 @@ import javax.servlet.ServletContext;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletResponse;
 
-import org.apache.catalina.CometEvent;
 import org.apache.catalina.Context;
 import org.apache.catalina.Globals;
 import org.apache.catalina.Wrapper;
+import org.apache.catalina.comet.CometEvent;
 import org.apache.catalina.connector.ClientAbortException;
 import org.apache.catalina.connector.Request;
 import org.apache.catalina.connector.Response;
diff --git a/java/org/apache/catalina/core/StandardWrapperValve.java b/java/org/apache/catalina/core/StandardWrapperValve.java
index 88c72f3..d4d377c 100644
--- a/java/org/apache/catalina/core/StandardWrapperValve.java
+++ b/java/org/apache/catalina/core/StandardWrapperValve.java
@@ -29,10 +29,10 @@ import javax.servlet.ServletException;
 import javax.servlet.UnavailableException;
 import javax.servlet.http.HttpServletResponse;
 
-import org.apache.catalina.CometEvent;
-import org.apache.catalina.CometProcessor;
 import org.apache.catalina.Context;
 import org.apache.catalina.Globals;
+import org.apache.catalina.comet.CometEvent;
+import org.apache.catalina.comet.CometProcessor;
 import org.apache.catalina.connector.ClientAbortException;
 import org.apache.catalina.connector.Request;
 import org.apache.catalina.connector.Response;
diff --git a/java/org/apache/catalina/filters/RemoteAddrFilter.java b/java/org/apache/catalina/filters/RemoteAddrFilter.java
index cc3febc..ffb252d 100644
--- a/java/org/apache/catalina/filters/RemoteAddrFilter.java
+++ b/java/org/apache/catalina/filters/RemoteAddrFilter.java
@@ -26,8 +26,8 @@ import javax.servlet.ServletException;
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
 
-import org.apache.catalina.CometEvent;
-import org.apache.catalina.CometFilterChain;
+import org.apache.catalina.comet.CometEvent;
+import org.apache.catalina.comet.CometFilterChain;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 
diff --git a/java/org/apache/catalina/filters/RemoteHostFilter.java b/java/org/apache/catalina/filters/RemoteHostFilter.java
index 6778b58..0b4c12d 100644
--- a/java/org/apache/catalina/filters/RemoteHostFilter.java
+++ b/java/org/apache/catalina/filters/RemoteHostFilter.java
@@ -26,8 +26,8 @@ import javax.servlet.ServletException;
 import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
 
-import org.apache.catalina.CometEvent;
-import org.apache.catalina.CometFilterChain;
+import org.apache.catalina.comet.CometEvent;
+import org.apache.catalina.comet.CometFilterChain;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 
diff --git a/java/org/apache/catalina/filters/RequestFilter.java b/java/org/apache/catalina/filters/RequestFilter.java
index 97f9b95..2499dc5 100644
--- a/java/org/apache/catalina/filters/RequestFilter.java
+++ b/java/org/apache/catalina/filters/RequestFilter.java
@@ -30,9 +30,9 @@ import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
 import javax.servlet.http.HttpServletResponse;
 
-import org.apache.catalina.CometEvent;
-import org.apache.catalina.CometFilter;
-import org.apache.catalina.CometFilterChain;
+import org.apache.catalina.comet.CometEvent;
+import org.apache.catalina.comet.CometFilter;
+import org.apache.catalina.comet.CometFilterChain;
 import org.apache.tomcat.util.res.StringManager;
 
 /**
diff --git a/java/org/apache/catalina/valves/CometConnectionManagerValve.java b/java/org/apache/catalina/valves/CometConnectionManagerValve.java
index a928164..0800ed1 100644
--- a/java/org/apache/catalina/valves/CometConnectionManagerValve.java
+++ b/java/org/apache/catalina/valves/CometConnectionManagerValve.java
@@ -30,13 +30,13 @@ import javax.servlet.http.HttpSession;
 import javax.servlet.http.HttpSessionEvent;
 import javax.servlet.http.HttpSessionListener;
 
-import org.apache.catalina.CometEvent;
-import org.apache.catalina.CometProcessor;
 import org.apache.catalina.Context;
 import org.apache.catalina.Lifecycle;
 import org.apache.catalina.LifecycleEvent;
 import org.apache.catalina.LifecycleException;
 import org.apache.catalina.LifecycleListener;
+import org.apache.catalina.comet.CometEvent;
+import org.apache.catalina.comet.CometProcessor;
 import org.apache.catalina.connector.CometEventImpl;
 import org.apache.catalina.connector.Request;
 import org.apache.catalina.connector.Response;
diff --git a/java/org/apache/catalina/valves/ValveBase.java b/java/org/apache/catalina/valves/ValveBase.java
index 524b536..a5f41fc 100644
--- a/java/org/apache/catalina/valves/ValveBase.java
+++ b/java/org/apache/catalina/valves/ValveBase.java
@@ -27,7 +27,6 @@ import javax.management.MalformedObjectNameException;
 import javax.management.ObjectName;
 import javax.servlet.ServletException;
 
-import org.apache.catalina.CometEvent;
 import org.apache.catalina.Contained;
 import org.apache.catalina.Container;
 import org.apache.catalina.Context;
@@ -36,6 +35,7 @@ import org.apache.catalina.Host;
 import org.apache.catalina.Pipeline;
 import org.apache.catalina.Valve;
 import org.apache.catalina.Wrapper;
+import org.apache.catalina.comet.CometEvent;
 import org.apache.catalina.connector.Request;
 import org.apache.catalina.connector.Response;
 import org.apache.catalina.core.ContainerBase;
diff --git a/modules/bayeux/java/org/apache/tomcat/bayeux/BayeuxServlet.java b/modules/bayeux/java/org/apache/tomcat/bayeux/BayeuxServlet.java
index dfb81b3..f0ce85b 100644
--- a/modules/bayeux/java/org/apache/tomcat/bayeux/BayeuxServlet.java
+++ b/modules/bayeux/java/org/apache/tomcat/bayeux/BayeuxServlet.java
@@ -24,8 +24,8 @@ import javax.servlet.ServletRequest;
 import javax.servlet.ServletResponse;
 import javax.servlet.http.HttpServletResponse;
 
-import org.apache.catalina.CometEvent;
-import org.apache.catalina.CometProcessor;
+import org.apache.catalina.comet.CometEvent;
+import org.apache.catalina.comet.CometProcessor;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
 import org.json.JSONArray;
diff --git a/modules/bayeux/java/org/apache/tomcat/bayeux/ClientImpl.java b/modules/bayeux/java/org/apache/tomcat/bayeux/ClientImpl.java
index 3705e1f..b03f7a8 100644
--- a/modules/bayeux/java/org/apache/tomcat/bayeux/ClientImpl.java
+++ b/modules/bayeux/java/org/apache/tomcat/bayeux/ClientImpl.java
@@ -22,7 +22,7 @@ import java.util.Map;
 import java.util.Queue;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
-import org.apache.catalina.CometEvent;
+import org.apache.catalina.comet.CometEvent;
 import org.json.JSONObject;
 import org.apache.cometd.bayeux.Bayeux;
 import org.apache.cometd.bayeux.Client;
diff --git a/modules/bayeux/java/org/apache/tomcat/bayeux/RequestBase.java b/modules/bayeux/java/org/apache/tomcat/bayeux/RequestBase.java
index 9f6036e..a813abf 100644
--- a/modules/bayeux/java/org/apache/tomcat/bayeux/RequestBase.java
+++ b/modules/bayeux/java/org/apache/tomcat/bayeux/RequestBase.java
@@ -28,7 +28,7 @@ import java.util.Date;
 import java.text.SimpleDateFormat;
 import javax.servlet.ServletException;
 
-import org.apache.catalina.CometEvent;
+import org.apache.catalina.comet.CometEvent;
 import org.apache.tomcat.bayeux.HttpError;
 
 import org.apache.juli.logging.Log;
diff --git a/modules/bayeux/java/org/apache/tomcat/bayeux/RequestFactory.java b/modules/bayeux/java/org/apache/tomcat/bayeux/RequestFactory.java
index c617180..203d94dc 100644
--- a/modules/bayeux/java/org/apache/tomcat/bayeux/RequestFactory.java
+++ b/modules/bayeux/java/org/apache/tomcat/bayeux/RequestFactory.java
@@ -18,7 +18,7 @@ package org.apache.tomcat.bayeux;
 
 import org.json.JSONObject;
 import org.apache.tomcat.bayeux.request.MetaHandshakeRequest;
-import org.apache.catalina.CometEvent;
+import org.apache.catalina.comet.CometEvent;
 import org.json.JSONException;
 import org.apache.tomcat.bayeux.request.MetaConnectRequest;
 import org.apache.tomcat.bayeux.request.MetaDisconnectRequest;
diff --git a/modules/bayeux/java/org/apache/tomcat/bayeux/TomcatBayeux.java b/modules/bayeux/java/org/apache/tomcat/bayeux/TomcatBayeux.java
index e7d33c0..f8d6882 100644
--- a/modules/bayeux/java/org/apache/tomcat/bayeux/TomcatBayeux.java
+++ b/modules/bayeux/java/org/apache/tomcat/bayeux/TomcatBayeux.java
@@ -20,7 +20,7 @@ import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
 
-import org.apache.catalina.CometEvent;
+import org.apache.catalina.comet.CometEvent;
 import org.apache.catalina.tribes.util.Arrays;
 import org.apache.catalina.tribes.util.UUIDGenerator;
 import org.apache.cometd.bayeux.Bayeux;
diff --git a/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaConnectRequest.java b/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaConnectRequest.java
index 2eacdbc..f2f509a 100644
--- a/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaConnectRequest.java
+++ b/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaConnectRequest.java
@@ -20,7 +20,7 @@ import java.io.IOException;
 import java.util.HashMap;
 import javax.servlet.ServletException;
 
-import org.apache.catalina.CometEvent;
+import org.apache.catalina.comet.CometEvent;
 import org.apache.tomcat.bayeux.HttpError;
 import org.apache.tomcat.bayeux.BayeuxException;
 import org.apache.tomcat.bayeux.BayeuxRequest;
diff --git a/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaDisconnectRequest.java b/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaDisconnectRequest.java
index b3dde94..78bf7b4 100644
--- a/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaDisconnectRequest.java
+++ b/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaDisconnectRequest.java
@@ -20,7 +20,7 @@ import java.io.IOException;
 import java.util.HashMap;
 import javax.servlet.ServletException;
 
-import org.apache.catalina.CometEvent;
+import org.apache.catalina.comet.CometEvent;
 import org.apache.tomcat.bayeux.HttpError;
 import org.apache.tomcat.bayeux.BayeuxException;
 import org.apache.tomcat.bayeux.BayeuxRequest;
diff --git a/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaHandshakeRequest.java b/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaHandshakeRequest.java
index 0883ae9..593cfef 100644
--- a/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaHandshakeRequest.java
+++ b/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaHandshakeRequest.java
@@ -20,7 +20,7 @@ import java.io.IOException;
 import java.util.HashMap;
 import javax.servlet.ServletException;
 
-import org.apache.catalina.CometEvent;
+import org.apache.catalina.comet.CometEvent;
 import org.apache.tomcat.bayeux.HttpError;
 import org.apache.tomcat.bayeux.BayeuxException;
 import org.apache.tomcat.bayeux.BayeuxRequest;
diff --git a/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaSubscribeRequest.java b/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaSubscribeRequest.java
index b6af0b2..af42d09 100644
--- a/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaSubscribeRequest.java
+++ b/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaSubscribeRequest.java
@@ -22,7 +22,7 @@ import java.util.Iterator;
 import java.util.List;
 import javax.servlet.ServletException;
 
-import org.apache.catalina.CometEvent;
+import org.apache.catalina.comet.CometEvent;
 import org.apache.tomcat.bayeux.HttpError;
 import org.apache.tomcat.bayeux.BayeuxException;
 import org.apache.tomcat.bayeux.BayeuxRequest;
diff --git a/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaUnsubscribeRequest.java b/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaUnsubscribeRequest.java
index e8b3e16..62e4c8f 100644
--- a/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaUnsubscribeRequest.java
+++ b/modules/bayeux/java/org/apache/tomcat/bayeux/request/MetaUnsubscribeRequest.java
@@ -22,7 +22,7 @@ import java.util.Iterator;
 import java.util.List;
 import javax.servlet.ServletException;
 
-import org.apache.catalina.CometEvent;
+import org.apache.catalina.comet.CometEvent;
 import org.apache.tomcat.bayeux.HttpError;
 import org.apache.tomcat.bayeux.BayeuxException;
 import org.apache.tomcat.bayeux.BayeuxRequest;
diff --git a/modules/bayeux/java/org/apache/tomcat/bayeux/request/PublishRequest.java b/modules/bayeux/java/org/apache/tomcat/bayeux/request/PublishRequest.java
index 017d181..b714d11 100644
--- a/modules/bayeux/java/org/apache/tomcat/bayeux/request/PublishRequest.java
+++ b/modules/bayeux/java/org/apache/tomcat/bayeux/request/PublishRequest.java
@@ -20,7 +20,7 @@ import java.io.IOException;
 import java.util.HashMap;
 import javax.servlet.ServletException;
 
-import org.apache.catalina.CometEvent;
+import org.apache.catalina.comet.CometEvent;
 import org.apache.tomcat.bayeux.HttpError;
 import org.apache.tomcat.bayeux.BayeuxException;
 import org.apache.tomcat.bayeux.BayeuxRequest;
diff --git a/webapps/docs/aio.xml b/webapps/docs/aio.xml
index 4cc4c53..4cb28fe 100644
--- a/webapps/docs/aio.xml
+++ b/webapps/docs/aio.xml
@@ -58,7 +58,7 @@
   <subsection name="CometEvent">
   
   <p>
-    Servlets which implement the <code>org.apache.catalina.CometProcessor</code>
+    Servlets which implement the <code>org.apache.catalina.comet.CometProcessor</code>
     interface will have their event method invoked rather than the usual service
     method, according to the event which occurred. The event object gives
     access to the usual request and response objects, which may be used in the
diff --git a/webapps/examples/WEB-INF/classes/chat/ChatServlet.java b/webapps/examples/WEB-INF/classes/chat/ChatServlet.java
index 8028f40..8e24cbf 100644
--- a/webapps/examples/WEB-INF/classes/chat/ChatServlet.java
+++ b/webapps/examples/WEB-INF/classes/chat/ChatServlet.java
@@ -24,8 +24,8 @@ import java.io.InputStream;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 
-import org.apache.catalina.CometEvent;
-import org.apache.catalina.CometProcessor;
+import org.apache.catalina.comet.CometEvent;
+import org.apache.catalina.comet.CometProcessor;
 
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServlet;

commit bbf9abbb1c2f6824d076003d0f8720ce20db9f4b
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Sat Oct 3 16:20:49 2009 +0000

    Fix BASE/HOME swap and add note re security manager.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@821353 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/webapps/docs/logging.xml b/webapps/docs/logging.xml
index 4d2666e..8b4ff9f 100644
--- a/webapps/docs/logging.xml
+++ b/webapps/docs/logging.xml
@@ -302,11 +302,13 @@ log4j.logger.org.apache.catalina.session=DEBUG<br />
 
     <p>
       If you have multiple instances of Tomcat, each with a separate
-      <code>$CATALINA_HOME</code> but a shared <code>$CATALINA_BASE</code> then
+      <code>$CATALINA_BASE</code> but a shared <code>$CATALINA_HOME</code> then
       you can configure log4j on a per instance basis by replacing references to
       <code>$CATALINA_HOME</code> in the above instructions with
       <code>$CATALINA_BASE</code>. Note that you may need to create a
-      <code>$CATALINA_BASE/lib</code> directory. 
+      <code>$CATALINA_BASE/lib</code> directory and if you are running with a
+      security manager you will need to adjust the codebase for JULI in 
+      <code>$CATALINA_BASE/conf/catalina.policy</code>.
     </p>
   </section>
 

commit d19f64e23ab64e3cb4cb5473a0feafeaf4c37e8b
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Mon Sep 21 22:31:47 2009 +0000

    Separate out Manager app roles
    Move /manager to /manager/text to simplify permissions
    Allows the future addition of extra security measures to one interface that might not make sense for another (usually these will be added to the HTML interface but that might not always be the case).
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@817446 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/webapps/docs/changelog.xml b/webapps/docs/changelog.xml
index c3c81bc..a1a0055 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -182,12 +182,17 @@
       </update>
     </changelog>
   </subsection>
-  <subsection name="Documentation">
+  <subsection name="Web applications">
      <changelog>
       <update>
-        <rev>631321</rev> Update changelog to support the &lt;rev&gt; element.
-        (fhanik)
+        <rev>631321</rev> Update changelog to support the &lt;rev&gt; element
+        in the documentation. (fhanik)
       </update>
+      <add>
+        A number of additional roles were added to the Manager application to
+        separate out permissions for the HTML interface, the text interface and
+        the JMX proxy. (markt) 
+      </add>
     </changelog>
   </subsection>
   <subsection name="Extras">
diff --git a/webapps/docs/manager-howto.xml b/webapps/docs/manager-howto.xml
index 3b0ff1f..b631bc4 100644
--- a/webapps/docs/manager-howto.xml
+++ b/webapps/docs/manager-howto.xml
@@ -211,7 +211,7 @@ an example of restricting access to the localhost by IP address:
 <p>All commands that the Manager application knows how to process are
 specified in a single request URI like this:</p>
 <source>
-http://{host}:{port}/manager/{command}?{parameters}
+http://{host}:{port}/manager/text/{command}?{parameters}
 </source>
 <p>where <code>{host}</code> and <code>{port}</code> represent the hostname
 and port number on which Tomcat is running, <code>{command}</code>
@@ -270,7 +270,7 @@ version of the messages.</p>
 <subsection name="Deploy A New Application Remotely">
 
 <source>
-http://localhost:8080/manager/deploy?path=/foo
+http://localhost:8080/manager/text/deploy?path=/foo
 </source>
 
 <p>Upload the web application archive (WAR) file that is specified as the
@@ -343,7 +343,7 @@ has been deployed using the <code>tag</code> attribute. Note that the work
 directory for the manager webapp will contain the previously deployed WARs;
 removing it would make the deployment fail.
 <source>
-http://localhost:8080/manager/deploy?path=/footoo&amp;tag=footag
+http://localhost:8080/manager/text/deploy?path=/footoo&amp;tag=footag
 </source>
 </p>
 
@@ -362,7 +362,7 @@ the entire WAR file.</p>
 <code>/path/to/foo</code> on the Tomcat server is deployed as the
 web application context named <code>/footoo</code>.
 <source>
-http://localhost:8080/manager/deploy?path=/footoo&amp;war=file:/path/to/foo
+http://localhost:8080/manager/text/deploy?path=/footoo&amp;war=file:/path/to/foo
 </source>
 </p>
 
@@ -372,7 +372,7 @@ Tomcat server is deployed as the web application context named
 so the context path defaults to the name of the web application archive
 file without the ".war" extension.
 <source>
-http://localhost:8080/manager/deploy?war=jar:file:/path/to/bar.war!/
+http://localhost:8080/manager/text/deploy?war=jar:file:/path/to/bar.war!/
 </source>
 </p>
 
@@ -387,7 +387,7 @@ extension is used as the path.</p>
 deployed as the web application context named <code>/foo</code>. Notice
 that the context path used is the name of the web application directory.
 <source>
-http://localhost:8080/manager/deploy?war=foo
+http://localhost:8080/manager/text/deploy?war=foo
 </source>
 </p>
 
@@ -395,7 +395,7 @@ http://localhost:8080/manager/deploy?war=foo
 Host appBase directory on the Tomcat server is deployed as the web
 application context named <code>/bar</code>.
 <source>
-http://localhost:8080/manager/deploy?war=bar.war
+http://localhost:8080/manager/text/deploy?war=bar.war
 </source>
 </p>
 
@@ -430,7 +430,7 @@ docBase configured in the context configuration ".xml" file.</p>
 <p>Here is an example of deploying an application using a Context
 configuration ".xml" file.
 <source>
-http://localhost:8080/manager/deploy?config=file:/path/context.xml
+http://localhost:8080/manager/text/deploy?config=file:/path/context.xml
 </source>
 </p>
 
@@ -438,7 +438,7 @@ http://localhost:8080/manager/deploy?config=file:/path/context.xml
 configuration ".xml" file and a web application ".war" file located
 on the server.
 <source>
-http://localhost:8080/manager/deploy?config=file:/path/context.xml&amp;war=jar:file:/path/bar.war!/
+http://localhost:8080/manager/text/deploy?config=file:/path/context.xml&amp;war=jar:file:/path/bar.war!/
 </source>
 </p>
 
@@ -529,7 +529,7 @@ error message.  Possible causes for problems include:</p>
 <subsection name="List Currently Deployed Applications">
 
 <source>
-http://localhost:8080/manager/list
+http://localhost:8080/manager/text/list
 </source>
 
 <p>List the context paths, current status (<code>running</code> or
@@ -549,7 +549,7 @@ OK - Listed applications for virtual host localhost
 <subsection name="Reload An Existing Application">
 
 <source>
-http://localhost:8080/manager/reload?path=/examples
+http://localhost:8080/manager/text/reload?path=/examples
 </source>
 
 <p>Signal an existing application to shut itself down and reload.  This can
@@ -608,7 +608,7 @@ error message.  Possible causes for problems include:</p>
 <subsection name="List OS and JVM Properties">
 
 <source>
-http://localhost:8080/manager/serverinfo
+http://localhost:8080/manager/text/serverinfo
 </source>
 
 <p>Lists information about the Tomcat version, OS, and JVM properties.</p>
@@ -628,7 +628,7 @@ include an error message.  Possible causes for problems include:</p>
 <subsection name="List Available Global JNDI Resources">
 
 <source>
-http://localhost:8080/manager/resources[?type=xxxxx]
+http://localhost:8080/manager/text/resources[?type=xxxxx]
 </source>
 
 <p>List the global JNDI resources that are available for use in resource
@@ -680,7 +680,7 @@ include an error message.  Possible causes for problems include:</p>
 <subsection name="List Available Security Roles">
 
 <source>
-http://localhost:8080/manager/roles
+http://localhost:8080/manager/text/roles
 </source>
 
 <p>List the security role names (and corresponding descriptions) that are
@@ -733,7 +733,7 @@ include an error message.  Possible causes for problems include:</p>
 <subsection name="Session Statistics">
 
 <source>
-http://localhost:8080/manager/sessions?path=/examples
+http://localhost:8080/manager/text/sessions?path=/examples
 </source>
 
 <p>Display the default session timeout for a web application, and the
@@ -753,7 +753,7 @@ Default maximum session inactive interval 30 minutes
 <subsection name="Start an Existing Application">
 
 <source>
-http://localhost:8080/manager/start?path=/examples
+http://localhost:8080/manager/text/start?path=/examples
 </source>
 
 <p>Signal a stopped application to restart, and make itself available again.
@@ -796,7 +796,7 @@ error message.  Possible causes for problems include:</p>
 <subsection name="Stop an Existing Application">
 
 <source>
-http://localhost:8080/manager/stop?path=/examples
+http://localhost:8080/manager/text/stop?path=/examples
 </source>
 
 <p>Signal an existing application to make itself unavailable, but leave it
@@ -839,7 +839,7 @@ error message.  Possible causes for problems include:</p>
 <subsection name="Undeploy an Existing Application">
 
 <source>
-http://localhost:8080/manager/undeploy?path=/examples
+http://localhost:8080/manager/text/undeploy?path=/examples
 </source>
 
 <p><strong><font color="red">WARNING</font> - This command will delete any web 
@@ -928,7 +928,7 @@ file might look something like this:</p>
   &lt;property name="path"     value="/myapp"/&gt;
 
   &lt;!-- Configure properties to access the Manager application --&gt;
-  &lt;property name="url"      value="http://localhost:8080/manager"/&gt;
+  &lt;property name="url"      value="http://localhost:8080/manager/text"/&gt;
   &lt;property name="username" value="myusername"/&gt;
   &lt;property name="password" value="mypassword"/&gt;
 
diff --git a/webapps/manager/401.jsp b/webapps/manager/401.jsp
index fb45a1b..ab1721d 100644
--- a/webapps/manager/401.jsp
+++ b/webapps/manager/401.jsp
@@ -35,17 +35,33 @@
     You are not authorized to view this page. If you have not changed
     any configuration files, please examine the file
     <tt>conf/tomcat-users.xml</tt> in your installation. That
-    file will contain the credentials to let you use this webapp.
+    file must contain the credentials to let you use this webapp.
    </p>
    <p>
-    You will need to add <tt>manager</tt> role to the config file listed above.
-    For example:
+    For example, to add the <tt>manager</tt> role to a user named
+    <tt>tomcat</tt> with a password of <tt>s3cret</tt>, add the following to the
+    config file listed above.
 <pre>
 &lt;role rolename="manager"/&gt;
 &lt;user username="tomcat" password="s3cret" roles="manager"/&gt;
 </pre>
    </p>
    <p>
+    Note that for Tomcat 7 onwards, the roles required to use the manager
+    application were changed from the single <tt>manager</tt> role to the
+    following four roles. You will need to assign the role(s) required for
+    the functionality you wish to access.
+    <ul>
+      <li><tt>manager</tt> - allows access to the HTML GUI and the status
+          pages</li>
+      <li><tt>manager-scripts</tt> - allows access to the text interface and the
+          status pages</li>
+      <li><tt>manager-jmx</tt> - allows access to the JMX proxy and the status
+          pages</li>
+      <li><tt>manager-status</tt> - allows access to the just status pages</li>
+    </ul>
+   </p>
+   <p>
     For more information - please see the
     <a href="/docs/manager-howto.html">Manager App HOW-TO</a>.
    </p>
diff --git a/webapps/manager/404.jsp b/webapps/manager/404.jsp
new file mode 100644
index 0000000..661bb67
--- /dev/null
+++ b/webapps/manager/404.jsp
@@ -0,0 +1,59 @@
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the "License"); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<%@ page import="org.apache.catalina.util.RequestUtil" %>
+<html>
+ <head>
+  <title>404 Not found</title>
+  <style>
+    <!--
+    BODY {font-family:Tahoma,Arial,sans-serif;color:black;background-color:white;font-size:12px;}
+    H1 {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;font-size:22px;}
+    PRE, TT {border: 1px dotted #525D76}
+    A {color : black;}A.name {color : black;}
+    -->
+  </style>
+ </head>
+ <body>
+   <h1>404 Not found</h1>
+   <p>
+    The page you tried to access
+    (<%=RequestUtil.filter((String) request.getAttribute(
+            "javax.servlet.error.request_uri"))%>)
+    does not exist.
+   </p>
+   <p>
+    The Manager application has been re-structured for Tomcat 7 onwards and some
+    of URLs have changed. All URLs used to access the Manager application should
+    now start with one of the following options:
+    <ul>
+      <li><%=request.getContextPath()%>/html for the HTML GUI</li>
+      <li><%=request.getContextPath()%>/text for the text interface</li>
+      <li><%=request.getContextPath()%>/jmxproxy for the JMX proxy</li>
+      <li><%=request.getContextPath()%>/status for the status pages</li>
+    </ul>
+    Note that the URL for the text interface has changed from
+    &quot;<%=request.getContextPath()%>&quot; to
+    &quot;<%=request.getContextPath()%>/text&quot;.
+   </p>
+   <p>
+    You probably need to adjust the URL you are using to access the Manager
+    application. However, there is always a chance you have found a bug in the
+    Manager application. If you are sure you have found a bug, and that the bug
+    has not already been reported, please report it to the Apache Tomcat team.
+   </p>
+ </body>
+</html>
diff --git a/webapps/manager/WEB-INF/web.xml b/webapps/manager/WEB-INF/web.xml
index a067f21..ff19a20 100644
--- a/webapps/manager/WEB-INF/web.xml
+++ b/webapps/manager/WEB-INF/web.xml
@@ -27,12 +27,6 @@
     Manager lets you view, load/unload/etc particular web applications.
   </description>
 
-  <!-- Define the Manager Servlet
-       Change servlet-class to: org.apache.catalina.servlets.HTMLManagerServlet
-       to get a Servlet with a more intuitive HTML interface, don't change if you
-       have software that is expected to parse the output from ManagerServlet
-       since they're not compatible.
-   -->
   <servlet>
     <servlet-name>Manager</servlet-name>
     <servlet-class>org.apache.catalina.manager.ManagerServlet</servlet-class>
@@ -66,59 +60,7 @@
   <!-- Define the Manager Servlet Mapping -->
   <servlet-mapping>
     <servlet-name>Manager</servlet-name>
-      <url-pattern>/list</url-pattern>
-  </servlet-mapping>
-  <servlet-mapping>
-    <servlet-name>Manager</servlet-name>
-      <url-pattern>/expire</url-pattern>
-  </servlet-mapping>
-  <servlet-mapping>
-    <servlet-name>Manager</servlet-name>
-      <url-pattern>/sessions</url-pattern>
-  </servlet-mapping>
-  <servlet-mapping>
-    <servlet-name>Manager</servlet-name>
-      <url-pattern>/start</url-pattern>
-  </servlet-mapping>
-  <servlet-mapping>
-    <servlet-name>Manager</servlet-name>
-      <url-pattern>/stop</url-pattern>
-  </servlet-mapping>
-  <servlet-mapping>
-    <servlet-name>Manager</servlet-name>
-      <url-pattern>/install</url-pattern>
-  </servlet-mapping>
-  <servlet-mapping>
-    <servlet-name>Manager</servlet-name>
-      <url-pattern>/remove</url-pattern>
-  </servlet-mapping>
-  <servlet-mapping>
-    <servlet-name>Manager</servlet-name>
-      <url-pattern>/deploy</url-pattern>
-  </servlet-mapping>
-  <servlet-mapping>
-    <servlet-name>Manager</servlet-name>
-      <url-pattern>/undeploy</url-pattern>
-  </servlet-mapping>
-  <servlet-mapping>
-    <servlet-name>Manager</servlet-name>
-      <url-pattern>/reload</url-pattern>
-  </servlet-mapping>
-  <servlet-mapping>
-    <servlet-name>Manager</servlet-name>
-      <url-pattern>/save</url-pattern>
-  </servlet-mapping>
-  <servlet-mapping>
-    <servlet-name>Manager</servlet-name>
-      <url-pattern>/serverinfo</url-pattern>
-  </servlet-mapping>
-  <servlet-mapping>
-    <servlet-name>Manager</servlet-name>
-      <url-pattern>/roles</url-pattern>
-  </servlet-mapping>
-  <servlet-mapping>
-    <servlet-name>Manager</servlet-name>
-      <url-pattern>/resources</url-pattern>
+      <url-pattern>/text/*</url-pattern>
   </servlet-mapping>
   <servlet-mapping>
     <servlet-name>Status</servlet-name>
@@ -148,30 +90,44 @@
   </resource-env-ref>
 
   <!-- Define a Security Constraint on this Application -->
+  <!-- NOTE:  None of these roles are present in the default users file -->
   <security-constraint>
     <web-resource-collection>
-      <web-resource-name>HTMLManger and Manager command</web-resource-name>
-      <url-pattern>/jmxproxy/*</url-pattern>
+      <web-resource-name>HTML Manger interface (for humans)</web-resource-name>
       <url-pattern>/html/*</url-pattern>
-      <url-pattern>/list</url-pattern>
-      <url-pattern>/expire</url-pattern>
-      <url-pattern>/sessions</url-pattern>
-      <url-pattern>/start</url-pattern>
-      <url-pattern>/stop</url-pattern>
-      <url-pattern>/install</url-pattern>
-      <url-pattern>/remove</url-pattern>
-      <url-pattern>/deploy</url-pattern>
-      <url-pattern>/undeploy</url-pattern>
-      <url-pattern>/reload</url-pattern>
-      <url-pattern>/save</url-pattern>
-      <url-pattern>/serverinfo</url-pattern>
+    </web-resource-collection>
+    <auth-constraint>
+       <role-name>manager</role-name>
+    </auth-constraint>
+  </security-constraint>
+  <security-constraint>
+    <web-resource-collection>
+      <web-resource-name>Text Manger interface (for scripts)</web-resource-name>
+      <url-pattern>/text/*</url-pattern>
+    </web-resource-collection>
+    <auth-constraint>
+       <role-name>manager-scripts</role-name>
+    </auth-constraint>
+  </security-constraint>
+  <security-constraint>
+    <web-resource-collection>
+      <web-resource-name>JMX Proxy interface</web-resource-name>
+      <url-pattern>/jmxproxy/*</url-pattern>
+    </web-resource-collection>
+    <auth-constraint>
+       <role-name>manager-jmx</role-name>
+    </auth-constraint>
+  </security-constraint>
+  <security-constraint>
+    <web-resource-collection>
+      <web-resource-name>Status interface</web-resource-name>
       <url-pattern>/status/*</url-pattern>
-      <url-pattern>/roles</url-pattern>
-      <url-pattern>/resources</url-pattern>
     </web-resource-collection>
     <auth-constraint>
-       <!-- NOTE:  This role is not present in the default users file -->
        <role-name>manager</role-name>
+       <role-name>manager-scripts</role-name>
+       <role-name>manager-jmx</role-name>
+       <role-name>manager-status</role-name>
     </auth-constraint>
   </security-constraint>
 
@@ -184,14 +140,36 @@
   <!-- Security roles referenced by this web application -->
   <security-role>
     <description>
-      The role that is required to log in to the Manager Application
+      The role that is required to access the HTML Manager pages
     </description>
     <role-name>manager</role-name>
   </security-role>
+  <security-role>
+    <description>
+      The role that is required to access the text Manager pages
+    </description>
+    <role-name>manager-scripts</role-name>
+  </security-role>
+  <security-role>
+    <description>
+      The role that is required to access the HTML JMX Proxy
+    </description>
+    <role-name>manager-jmx</role-name>
+  </security-role>
+  <security-role>
+    <description>
+      The role that is required to access to the Manager Status pages 
+    </description>
+    <role-name>manager-status</role-name>
+  </security-role>
 
   <error-page>
     <error-code>401</error-code>
     <location>/401.jsp</location>
   </error-page>
+  <error-page>
+    <error-code>404</error-code>
+    <location>/404.jsp</location>
+  </error-page>
 
 </web-app>

commit 6f71be5c4165d4c79ca8af5e531dc44d9689e95c
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Tue Sep 8 10:24:29 2009 +0000

    Make the JDBC leak prevention play nicely with a security manager
    Don't use a fixed size buffer to load the class.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@812432 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/loader/JdbcLeakPrevention.java b/java/org/apache/catalina/loader/JdbcLeakPrevention.java
index 19c45c6..1fd7ea2 100644
--- a/java/org/apache/catalina/loader/JdbcLeakPrevention.java
+++ b/java/org/apache/catalina/loader/JdbcLeakPrevention.java
@@ -23,41 +23,26 @@ import java.sql.DriverManager;
 import java.sql.SQLException;
 import java.util.Enumeration;
 
-import org.apache.tomcat.util.res.StringManager;
-
 /**
- * This class is loaded by the  {@link WebappClassLoader} to enable it to
+ * This class is loaded by the {@link WebappClassLoader} to enable it to
  * deregister JDBC drivers forgotten by the web application. There are some
  * classloading hacks involved - see {@link WebappClassLoader#clearReferences()}
  * for details - but the short version is do not just create a new instance of
  * this class with the new keyword.
+ * 
+ * Since this class is loaded by {@link WebappClassLoader}, it can not refer to
+ * any internal Tomcat classes as that will cause the security manager to
+ * complain.
  */
 public class JdbcLeakPrevention {
 
-    /**
-     * The logger for this class.
-     */
-    protected static org.apache.juli.logging.Log log=
-        org.apache.juli.logging.LogFactory.getLog( JdbcLeakPrevention.class );
-
-    /**
-     * The string manager for this package.
-     */
-    protected static final StringManager sm =
-        StringManager.getManager(Constants.Package);
-
-    public void clearJdbcDriverRegistrations() {
+    public void clearJdbcDriverRegistrations() throws SQLException {
         // Unregister any JDBC drivers loaded by the class loader that loaded
         // this class - ie the webapp class loader
         Enumeration<Driver> drivers = DriverManager.getDrivers();
         while (drivers.hasMoreElements()) {
             Driver driver = drivers.nextElement();
-            try {
-                DriverManager.deregisterDriver(driver);
-            } catch (SQLException sqle) {
-                log.warn(sm.getString("jdbcLeakPrevention.jdbcRemoveFailed",
-                        driver.toString()), sqle);
-            }
+            DriverManager.deregisterDriver(driver);
         }
         
     }
diff --git a/java/org/apache/catalina/loader/WebappClassLoader.java b/java/org/apache/catalina/loader/WebappClassLoader.java
index f48c860..442eb0b 100644
--- a/java/org/apache/catalina/loader/WebappClassLoader.java
+++ b/java/org/apache/catalina/loader/WebappClassLoader.java
@@ -1619,16 +1619,21 @@ public class WebappClassLoader
          */
         InputStream is = getResourceAsStream(
                 "org/apache/catalina/loader/JdbcLeakPrevention.class");
-        // Cheat - we know roughly how big the class will be (~1K) but allow
-        // plenty room to grow
-        // TODO Let buffer grow as required
-        byte[] classBytes = new byte[4096];
+        // We know roughly how big the class will be (~ 1K) so allow 2k as a
+        // starting point
+        byte[] classBytes = new byte[2048];
         int offset = 0;
         try {
-            int read = is.read(classBytes, offset, 4096-offset);
+            int read = is.read(classBytes, offset, classBytes.length-offset);
             while (read > -1) {
                 offset += read;
-                read = is.read(classBytes, offset, 4096-offset);
+                if (offset == classBytes.length) {
+                    // Buffer full - double size
+                    byte[] tmp = new byte[classBytes.length * 2];
+                    System.arraycopy(classBytes, 0, tmp, 0, classBytes.length);
+                    classBytes = tmp;
+                }
+                read = is.read(classBytes, offset, classBytes.length-offset);
             }
             Class<?> lpClass =
                 defineClass("org.apache.catalina.loader.JdbcLeakPrevention",

commit 79f6ed4b410807d57531ee170c37c0fe8914357c
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Sat Jun 13 19:19:18 2009 +0000

    Remove case insensitivity option. It was a workaround for a change in Tomcat 3 and has security implications if used on case insensitive file systems.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@784455 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/core/StandardContext.java b/java/org/apache/catalina/core/StandardContext.java
index dceb058..1838ef1 100644
--- a/java/org/apache/catalina/core/StandardContext.java
+++ b/java/org/apache/catalina/core/StandardContext.java
@@ -640,12 +640,6 @@ public class StandardContext
 
 
     /**
-     * Case sensitivity.
-     */
-    protected boolean caseSensitive = true;
-
-
-    /**
      * Allow linking.
      */
     protected boolean allowLinking = false;
@@ -774,22 +768,6 @@ public class StandardContext
 
 
     /**
-     * Set case sensitivity.
-     */
-    public void setCaseSensitive(boolean caseSensitive) {
-        this.caseSensitive = caseSensitive;
-    }
-
-
-    /**
-     * Is case sensitive ?
-     */
-    public boolean isCaseSensitive() {
-        return caseSensitive;
-    }
-
-
-    /**
      * Set allow linking.
      */
     public void setAllowLinking(boolean allowLinking) {
@@ -1937,7 +1915,6 @@ public class StandardContext
         }
         if (resources instanceof FileDirContext) {
             filesystemBased = true;
-            ((FileDirContext) resources).setCaseSensitive(isCaseSensitive());
             ((FileDirContext) resources).setAllowLinking(isAllowLinking());
         }
         this.webappResources = resources;
@@ -4108,8 +4085,6 @@ public class StandardContext
                 new ProxyDirContext(env, webappResources);
             if (webappResources instanceof FileDirContext) {
                 filesystemBased = true;
-                ((FileDirContext) webappResources).setCaseSensitive
-                    (isCaseSensitive());
                 ((FileDirContext) webappResources).setAllowLinking
                     (isAllowLinking());
             }
diff --git a/java/org/apache/catalina/core/mbeans-descriptors.xml b/java/org/apache/catalina/core/mbeans-descriptors.xml
index 6b81ae9..ce19c0d 100644
--- a/java/org/apache/catalina/core/mbeans-descriptors.xml
+++ b/java/org/apache/catalina/core/mbeans-descriptors.xml
@@ -74,11 +74,6 @@
                is="true"
                type="boolean"/>
       
-    <attribute name="caseSensitive"
-               description="Should case sensitivity checks be performed"
-               is="true"
-               type="boolean"/>
-      
     <attribute name="children"
                description="Object names of all children"
                type="[Ljavax.management.ObjectName;"/>
diff --git a/java/org/apache/naming/resources/FileDirContext.java b/java/org/apache/naming/resources/FileDirContext.java
index 4e840d1..677a6ba 100644
--- a/java/org/apache/naming/resources/FileDirContext.java
+++ b/java/org/apache/naming/resources/FileDirContext.java
@@ -101,12 +101,6 @@ public class FileDirContext extends BaseDirContext {
 
 
     /**
-     * Case sensitivity.
-     */
-    protected boolean caseSensitive = true;
-
-
-    /**
      * Allow linking.
      */
     protected boolean allowLinking = false;
@@ -151,22 +145,6 @@ public class FileDirContext extends BaseDirContext {
 
 
     /**
-     * Set case sensitivity.
-     */
-    public void setCaseSensitive(boolean caseSensitive) {
-        this.caseSensitive = caseSensitive;
-    }
-
-
-    /**
-     * Is case sensitive ?
-     */
-    public boolean isCaseSensitive() {
-        return caseSensitive;
-    }
-
-
-    /**
      * Set allow linking.
      */
     public void setAllowLinking(boolean allowLinking) {
@@ -227,7 +205,6 @@ public class FileDirContext extends BaseDirContext {
             FileDirContext tempContext = new FileDirContext(env);
             tempContext.setDocBase(file.getPath());
             tempContext.setAllowLinking(getAllowLinking());
-            tempContext.setCaseSensitive(isCaseSensitive());
             result = tempContext;
         } else {
             result = new FileResource(file);
@@ -824,26 +801,24 @@ public class FileDirContext extends BaseDirContext {
                 return null;
             }
 
-            // Case sensitivity check
-            if (caseSensitive) {
-                String fileAbsPath = file.getAbsolutePath();
-                if (fileAbsPath.endsWith("."))
-                    fileAbsPath = fileAbsPath + "/";
-                String absPath = normalize(fileAbsPath);
-                canPath = normalize(canPath);
-                if ((absoluteBase.length() < absPath.length())
-                    && (absoluteBase.length() < canPath.length())) {
-                    absPath = absPath.substring(absoluteBase.length() + 1);
-                    if (absPath == null)
-                        return null;
-                    if (absPath.equals(""))
-                        absPath = "/";
-                    canPath = canPath.substring(absoluteBase.length() + 1);
-                    if (canPath.equals(""))
-                        canPath = "/";
-                    if (!canPath.equals(absPath))
-                        return null;
-                }
+            // Case sensitivity check - this is now always done
+            String fileAbsPath = file.getAbsolutePath();
+            if (fileAbsPath.endsWith("."))
+                fileAbsPath = fileAbsPath + "/";
+            String absPath = normalize(fileAbsPath);
+            canPath = normalize(canPath);
+            if ((absoluteBase.length() < absPath.length())
+                && (absoluteBase.length() < canPath.length())) {
+                absPath = absPath.substring(absoluteBase.length() + 1);
+                if (absPath == null)
+                    return null;
+                if (absPath.equals(""))
+                    absPath = "/";
+                canPath = canPath.substring(absoluteBase.length() + 1);
+                if (canPath.equals(""))
+                    canPath = "/";
+                if (!canPath.equals(absPath))
+                    return null;
             }
 
         } else {
@@ -887,7 +862,6 @@ public class FileDirContext extends BaseDirContext {
                 FileDirContext tempContext = new FileDirContext(env);
                 tempContext.setDocBase(file.getPath());
                 tempContext.setAllowLinking(getAllowLinking());
-                tempContext.setCaseSensitive(isCaseSensitive());
                 object = tempContext;
             } else {
                 object = new FileResource(currentFile);
diff --git a/java/org/apache/tomcat/util/buf/MessageBytes.java b/java/org/apache/tomcat/util/buf/MessageBytes.java
index 95fc78f..422edbe 100644
--- a/java/org/apache/tomcat/util/buf/MessageBytes.java
+++ b/java/org/apache/tomcat/util/buf/MessageBytes.java
@@ -51,9 +51,6 @@ public final class MessageBytes implements Cloneable, Serializable {
     // did we computed the hashcode ? 
     private boolean hasHashCode=false;
 
-    // Is the represented object case sensitive ?
-    private boolean caseSensitive=true;
-
     // Internal objects to represent array + offset, and specific methods
     private ByteChunk byteC=new ByteChunk();
     private CharChunk charC=new CharChunk();
@@ -78,12 +75,6 @@ public final class MessageBytes implements Cloneable, Serializable {
 	return factory.newInstance();
     }
 
-    /** Configure the case sensitivity
-     */
-    public void setCaseSenitive( boolean b ) {
-	caseSensitive=b;
-    }
-
     public MessageBytes getClone() {
 	try {
 	    return (MessageBytes)this.clone();
@@ -107,7 +98,6 @@ public final class MessageBytes implements Cloneable, Serializable {
 	charC.recycle();
 
 	strValue=null;
-	caseSensitive=true;
 
 	hasStrValue=false;
 	hasHashCode=false;
@@ -298,8 +288,6 @@ public final class MessageBytes implements Cloneable, Serializable {
      * @return true if the comparison succeeded, false otherwise
      */
     public boolean equals(String s) {
-	if( ! caseSensitive )
-	    return equalsIgnoreCase( s );
 	switch (type) {
 	case T_STR:
 	    if( strValue==null && s!=null) return false;
@@ -413,16 +401,13 @@ public final class MessageBytes implements Cloneable, Serializable {
 
     // -------------------- Hash code  --------------------
     public  int hashCode() {
-	if( hasHashCode ) return hashCode;
-	int code = 0;
+        if( hasHashCode ) return hashCode;
+        int code = 0;
 
-	if( caseSensitive ) 
-	    code=hash(); 
-	else
-	    code=hashIgnoreCase();
-	hashCode=code;
-	hasHashCode=true;
-	return code;
+        code=hash(); 
+        hashCode=code;
+        hasHashCode=true;
+        return code;
     }
 
     // normal hash. 
@@ -444,24 +429,6 @@ public final class MessageBytes implements Cloneable, Serializable {
 	}
     }
 
-    // hash ignoring case
-    private int hashIgnoreCase() {
-	int code=0;
-	switch (type) {
-	case T_STR:
-	    for (int i = 0; i < strValue.length(); i++) {
-		code = code * 37 + Ascii.toLower(strValue.charAt( i ));
-	    }
-	    return code;
-	case T_CHARS:
-	    return charC.hashIgnoreCase();
-	case T_BYTES:
-	    return byteC.hashIgnoreCase();
-	default:
-	    return 0;
-	}
-    }
-
     public int indexOf(char c) {
 	return indexOf( c, 0);
     }
diff --git a/webapps/docs/config/context.xml b/webapps/docs/config/context.xml
index 7bbe2de..d228212 100644
--- a/webapps/docs/config/context.xml
+++ b/webapps/docs/config/context.xml
@@ -328,16 +328,6 @@
         of the flag is <code>true</code>.</p>
       </attribute>
 
-      <attribute name="caseSensitive" required="false">
-        <p>If the value of this flag is <code>false</code>, all case sensitivity
-        checks will be disabled. If not 
-        specified, the default value of the flag is <code>true</code>.</p>
-        <p><b>NOTE: This flag MUST NOT be set to false on the Windows platform
-        (or any other OS which does not have a case sensitive filesystem),
-        as it will disable case sensitivity checks, allowing JSP source code
-        disclosure, among other security problems.</b></p>
-      </attribute>
-
       <attribute name="processTlds" required="false">
         <p>Whether the context should process TLDs on startup.  The default
         is true.  The false setting is intended for special cases

commit cab7c49a8e06defd61a0248602374c6ac90ba58a
Author: Mladen Turk <mturk@apache.org>
Date:   Wed May 27 08:19:13 2009 +0000

    Fix bz41564 by adding /user option to service.bat which respawns the service.bat
    using runas command. This pops-up a new window with elevated security on Vista+
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@779047 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/bin/service.bat b/bin/service.bat
index 7a40f82..5120c9c 100755
--- a/bin/service.bat
+++ b/bin/service.bat
@@ -24,11 +24,12 @@ rem                        Service is installed using default settings.
 rem remove                 Remove the service from the System.
 rem
 rem name        (optional) If the second argument is present it is considered
-rem                        to be new service name                                           
+rem                        to be new service name
 rem
 rem $Id$
 rem ---------------------------------------------------------------------------
 
+set SELF=%~dp0%service.bat
 rem Guess CATALINA_HOME if not defined
 set CURRENT_DIR=%cd%
 if not "%CATALINA_HOME%" == "" goto gotHome
@@ -47,35 +48,54 @@ rem Make sure prerequisite environment variables are set
 if not "%JAVA_HOME%" == "" goto okHome
 echo The JAVA_HOME environment variable is not defined
 echo This environment variable is needed to run this program
-goto end 
+goto end
 :okHome
 if not "%CATALINA_BASE%" == "" goto gotBase
 set CATALINA_BASE=%CATALINA_HOME%
 :gotBase
- 
+
 set EXECUTABLE=%CATALINA_HOME%\bin\tomcat@VERSION_MAJOR@.exe
 
 rem Set default Service name
 set SERVICE_NAME=Tomcat@VERSION_MAJOR@
 set PR_DISPLAYNAME=Apache Tomcat @VERSION_MAJOR@
 
-if "%1" == "" goto displayUsage
-if "%2" == "" goto setServiceName
-set SERVICE_NAME=%2
-set PR_DISPLAYNAME=Apache Tomcat %2
-:setServiceName
-if %1 == install goto doInstall
-if %1 == remove goto doRemove
-if %1 == uninstall goto doRemove
+if "x%1x" == "xx" goto displayUsage
+set SERVICE_CMD=%1
+shift
+if "x%1x" == "xx" goto checkServiceCmd
+:checkUser
+if "x%1x" == "x/userx" goto runAsUser
+if "x%1x" == "x--userx" goto runAsUser
+set SERVICE_NAME=%1
+set PR_DISPLAYNAME=Apache Tomcat %1
+shift
+if "x%1x" == "xx" goto checkServiceCmd
+goto checkUser
+:runAsUser
+shift
+if "x%1x" == "xx" goto displayUsage
+set SERVICE_USER=%1
+shift
+runas /env /savecred /user:%SERVICE_USER% "%COMSPEC% /K \"%SELF%\" %SERVICE_CMD% %SERVICE_NAME%"
+goto end
+:checkServiceCmd
+if /i %SERVICE_CMD% == install goto doInstall
+if /i %SERVICE_CMD% == remove goto doRemove
+if /i %SERVICE_CMD% == uninstall goto doRemove
 echo Unknown parameter "%1"
 :displayUsage
 echo.
-echo Usage: service.bat install/remove [service_name]
+echo Usage: service.bat install/remove [service_name] [/user username]
 goto end
 
 :doRemove
 rem Remove the service
 "%EXECUTABLE%" //DS//%SERVICE_NAME%
+if not errorlevel 1 goto removed
+echo Failed removing '%SERVICE_NAME%' service
+goto end
+:removed
 echo The service '%SERVICE_NAME%' has been removed
 goto end
 

commit 008407e60426ce9935596caed54fb221f1dc1a79
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Wed Apr 8 17:15:16 2009 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=46509
    Use correct link on error page in JSP security example
    Patch provided by Michael Moody
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@763325 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/webapps/examples/jsp/security/protected/error.jsp b/webapps/examples/jsp/security/protected/error.jsp
index 71ff515..5fc22ef 100644
--- a/webapps/examples/jsp/security/protected/error.jsp
+++ b/webapps/examples/jsp/security/protected/error.jsp
@@ -20,6 +20,6 @@
 </head>
 <body bgcolor="white">
 Invalid username and/or password, please try
-<a href='<%= response.encodeURL("login.jsp") %>'>again</a>.
+<a href='<%= response.encodeURL("index.jsp") %>'>again</a>.
 </body>
 </html>

commit 243aa86a06ea538f2988f8cc15f861593474b37b
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Wed Apr 8 12:59:21 2009 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=46967 and make behaviour consistent when running under a security manager.
    Based on a patch provided by Kirk Wolf
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@763228 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/session/ManagerBase.java b/java/org/apache/catalina/session/ManagerBase.java
index 9a46d24..5c67855 100644
--- a/java/org/apache/catalina/session/ManagerBase.java
+++ b/java/org/apache/catalina/session/ManagerBase.java
@@ -223,7 +223,11 @@ public abstract class ManagerBase implements Manager, MBeanRegistration {
 
     private class PrivilegedSetRandomFile implements PrivilegedAction<DataInputStream>{
         
-        public DataInputStream run(){               
+        public PrivilegedSetRandomFile(String s) {
+            devRandomSource = s;
+        }
+        
+        public DataInputStream run(){
             try {
                 File f=new File( devRandomSource );
                 if( ! f.exists() ) return null;
@@ -233,8 +237,18 @@ public abstract class ManagerBase implements Manager, MBeanRegistration {
                     log.debug( "Opening " + devRandomSource );
                 return randomIS;
             } catch (IOException ex){
+                log.warn("Error reading " + devRandomSource, ex);
+                if (randomIS != null) {
+                    try {
+                        randomIS.close();
+                    } catch (Exception e) {
+                        log.warn("Failed to close randomIS.");
+                    }
+                }
+                devRandomSource = null;
+                randomIS=null;
                 return null;
-            }
+            }            
         }
     }
 
@@ -505,10 +519,10 @@ public abstract class ManagerBase implements Manager, MBeanRegistration {
      *  - so use it if available.
      */
     public void setRandomFile( String s ) {
-        // as a hack, you can use a static file - and genarate the same
+        // as a hack, you can use a static file - and generate the same
         // session ids ( good for strange debugging )
         if (Globals.IS_SECURITY_ENABLED){
-            randomIS = AccessController.doPrivileged(new PrivilegedSetRandomFile());
+            randomIS = AccessController.doPrivileged(new PrivilegedSetRandomFile(s));
         } else {
             try{
                 devRandomSource=s;
@@ -519,12 +533,15 @@ public abstract class ManagerBase implements Manager, MBeanRegistration {
                 if( log.isDebugEnabled() )
                     log.debug( "Opening " + devRandomSource );
             } catch( IOException ex ) {
-                try {
-                    randomIS.close();
-                } catch (Exception e) {
-                    log.warn("Failed to close randomIS.");
+                log.warn("Error reading " + devRandomSource, ex);
+                if (randomIS != null) {
+                    try {
+                        randomIS.close();
+                    } catch (Exception e) {
+                        log.warn("Failed to close randomIS.");
+                    }
                 }
-                
+                devRandomSource = null;
                 randomIS=null;
             }
         }

commit 5249eaef2929f4805c1db0543f4ab431bfeffa42
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Sat Feb 21 00:44:33 2009 +0000

    Address Bill's security concerns in previous patch to get TCK to pass under a security manager.
    TCK passes after this patch with and without security manager.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@746425 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/jasper/el/ELContextImpl.java b/java/org/apache/jasper/el/ELContextImpl.java
index 34e550c..1421c7a 100644
--- a/java/org/apache/jasper/el/ELContextImpl.java
+++ b/java/org/apache/jasper/el/ELContextImpl.java
@@ -26,6 +26,8 @@ import javax.el.FunctionMapper;
 import javax.el.ValueExpression;
 import javax.el.VariableMapper;
 
+import org.apache.catalina.Globals;
+
 /**
  * Implementation of ELContext
  * 
@@ -61,12 +63,21 @@ public final class ELContextImpl extends ELContext {
 
     private final ELResolver resolver;
 
-    private FunctionMapper functionMapper = NullFunctionMapper; // immutable
+    private FunctionMapper functionMapper;
 
     private VariableMapper variableMapper;
 
     public ELContextImpl() {
-        this(ELResolverImpl.DefaultResolver);
+        this(ELResolverImpl.getDefaultResolver());
+        if (Globals.IS_SECURITY_ENABLED) {
+            functionMapper = new FunctionMapper() {
+                public Method resolveFunction(String prefix, String localName) {
+                    return null;
+                }
+            };
+        } else {
+            functionMapper = NullFunctionMapper;
+        }
     }
 
     public ELContextImpl(ELResolver resolver) {
diff --git a/java/org/apache/jasper/el/ELResolverImpl.java b/java/org/apache/jasper/el/ELResolverImpl.java
index 0c13095..ba35e27 100644
--- a/java/org/apache/jasper/el/ELResolverImpl.java
+++ b/java/org/apache/jasper/el/ELResolverImpl.java
@@ -32,8 +32,10 @@ import javax.el.PropertyNotWritableException;
 import javax.el.ResourceBundleELResolver;
 import javax.servlet.jsp.el.VariableResolver;
 
+import org.apache.catalina.Globals;
+
 public final class ELResolverImpl extends ELResolver {
-	
+	/** @deprecated - Use getDefaultResolver(). Needs to be made private */
 	public final static ELResolver DefaultResolver = new CompositeELResolver();
 
 	static {
@@ -69,7 +71,7 @@ public final class ELResolverImpl extends ELResolver {
 		}
 
 		if (!context.isPropertyResolved()) {
-			return DefaultResolver.getValue(context, base, property);
+			return getDefaultResolver().getValue(context, base, property);
 		}
 		return null;
 	}
@@ -94,7 +96,7 @@ public final class ELResolverImpl extends ELResolver {
 		}
 
 		if (!context.isPropertyResolved()) {
-			return DefaultResolver.getType(context, base, property);
+			return getDefaultResolver().getType(context, base, property);
 		}
 		return null;
 	}
@@ -114,7 +116,7 @@ public final class ELResolverImpl extends ELResolver {
 		}
 
 		if (!context.isPropertyResolved()) {
-			DefaultResolver.setValue(context, base, property, value);
+			getDefaultResolver().setValue(context, base, property, value);
 		}
 	}
 
@@ -129,18 +131,31 @@ public final class ELResolverImpl extends ELResolver {
 			return true;
 		}
 
-		return DefaultResolver.isReadOnly(context, base, property);
+		return getDefaultResolver().isReadOnly(context, base, property);
 	}
 
 	public Iterator<java.beans.FeatureDescriptor> getFeatureDescriptors(ELContext context, Object base) {
-		return DefaultResolver.getFeatureDescriptors(context, base);
+		return getDefaultResolver().getFeatureDescriptors(context, base);
 	}
 
 	public Class<?> getCommonPropertyType(ELContext context, Object base) {
 		if (base == null) {
 			return String.class;
 		}
-		return DefaultResolver.getCommonPropertyType(context, base);
+		return getDefaultResolver().getCommonPropertyType(context, base);
 	}
 
+	public static ELResolver getDefaultResolver() {
+	    if (Globals.IS_SECURITY_ENABLED) {
+	        ELResolver defaultResolver = new CompositeELResolver();
+	        ((CompositeELResolver) defaultResolver).add(new MapELResolver());
+	        ((CompositeELResolver) defaultResolver).add(new ResourceBundleELResolver());
+	        ((CompositeELResolver) defaultResolver).add(new ListELResolver());
+	        ((CompositeELResolver) defaultResolver).add(new ArrayELResolver());
+	        ((CompositeELResolver) defaultResolver).add(new BeanELResolver());
+	        return defaultResolver;
+	    } else {
+	        return DefaultResolver;
+	    }
+	}
 }
diff --git a/java/org/apache/jasper/el/ExpressionEvaluatorImpl.java b/java/org/apache/jasper/el/ExpressionEvaluatorImpl.java
index 56c099d..f08704f 100644
--- a/java/org/apache/jasper/el/ExpressionEvaluatorImpl.java
+++ b/java/org/apache/jasper/el/ExpressionEvaluatorImpl.java
@@ -37,7 +37,8 @@ public final class ExpressionEvaluatorImpl extends ExpressionEvaluator {
 	public Expression parseExpression(String expression, Class expectedType,
 			FunctionMapper fMapper) throws ELException {
 		try {
-			ELContextImpl ctx = new ELContextImpl(ELResolverImpl.DefaultResolver);
+			ELContextImpl ctx =
+			    new ELContextImpl(ELResolverImpl.getDefaultResolver());
             if (fMapper != null) {
                 ctx.setFunctionMapper(new FunctionMapperImpl(fMapper));
             }

commit 61cc509f2bd3d968c894826393656d830bcdc48c
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Fri Dec 26 19:25:01 2008 +0000

    o.a.c.security generics changes
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@729527 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityUtil.java b/java/org/apache/catalina/security/SecurityUtil.java
index 89bef1f..fda5b0c 100644
--- a/java/org/apache/catalina/security/SecurityUtil.java
+++ b/java/org/apache/catalina/security/SecurityUtil.java
@@ -66,7 +66,8 @@ public final class SecurityUtil{
     /**
      * Cache every object for which we are creating method on it.
      */
-    private static HashMap objectCache = new HashMap();
+    private static HashMap<Object,Method[]> objectCache =
+        new HashMap<Object,Method[]>();
         
     private static org.apache.juli.logging.Log log=
         org.apache.juli.logging.LogFactory.getLog( SecurityUtil.class );
@@ -112,7 +113,7 @@ public final class SecurityUtil{
      */
     public static void doAsPrivilege(final String methodName, 
                                      final Servlet targetObject, 
-                                     final Class[] targetType,
+                                     final Class<?>[] targetType,
                                      final Object[] targetArguments) 
         throws java.lang.Exception{    
 
@@ -140,7 +141,7 @@ public final class SecurityUtil{
      */    
     public static void doAsPrivilege(final String methodName, 
                                      final Servlet targetObject, 
-                                     final Class[] targetType,
+                                     final Class<?>[] targetType,
                                      final Object[] targetArguments,
                                      Principal principal) 
         throws java.lang.Exception{
@@ -148,7 +149,7 @@ public final class SecurityUtil{
         Method method = null;
         Method[] methodsCache = null;
         if(objectCache.containsKey(targetObject)){
-            methodsCache = (Method[])objectCache.get(targetObject);
+            methodsCache = objectCache.get(targetObject);
             method = findMethod(methodsCache, methodName);
             if (method == null){
                 method = createMethodAndCacheIt(methodsCache,
@@ -197,7 +198,7 @@ public final class SecurityUtil{
      */    
     public static void doAsPrivilege(final String methodName, 
                                      final Filter targetObject, 
-                                     final Class[] targetType,
+                                     final Class<?>[] targetType,
                                      final Object[] targetArguments) 
         throws java.lang.Exception{
 
@@ -221,7 +222,7 @@ public final class SecurityUtil{
      */    
     public static void doAsPrivilege(final String methodName, 
                                      final Filter targetObject, 
-                                     final Class[] targetType,
+                                     final Class<?>[] targetType,
                                      final Object[] targetArguments,
                                      Principal principal) 
         throws java.lang.Exception{
@@ -229,7 +230,7 @@ public final class SecurityUtil{
 
         Method[] methodsCache = null;
         if(objectCache.containsKey(targetObject)){
-            methodsCache = (Method[])objectCache.get(targetObject);
+            methodsCache = objectCache.get(targetObject);
             method = findMethod(methodsCache, methodName);
             if (method == null){
                 method = createMethodAndCacheIt(methodsCache,
@@ -268,8 +269,9 @@ public final class SecurityUtil{
        
         try{   
             Subject subject = null;
-            PrivilegedExceptionAction pea = new PrivilegedExceptionAction(){
-                    public Object run() throws Exception{
+            PrivilegedExceptionAction<Void> pea =
+                new PrivilegedExceptionAction<Void>(){
+                    public Void run() throws Exception{
                        method.invoke(targetObject, targetArguments);
                        return null;
                     }
@@ -374,7 +376,7 @@ public final class SecurityUtil{
     private static Method createMethodAndCacheIt(Method[] methodsCache,
                                                  String methodName,
                                                  Object targetObject,
-                                                 Class[] targetType) 
+                                                 Class<?>[] targetType) 
             throws Exception{
         
         if ( methodsCache == null){

commit caddf017e186c4a49199fff6a92a3a7161759b2e
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Sun Nov 30 20:14:59 2008 +0000

    Allow webapps to access org.apache.jasper.el package.
    I have looked through the package and I believe this change is safe although more eyes would be good. Without this permission, a handful of TCKs fail if tested with a security manager enabled.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@721886 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/conf/catalina.policy b/conf/catalina.policy
index edb601b..f00aa60 100644
--- a/conf/catalina.policy
+++ b/conf/catalina.policy
@@ -14,7 +14,7 @@
 // limitations under the License.
 
 // ============================================================================
-// catalina.corepolicy - Security Policy Permissions for Tomcat @VERSION_MAJOR@
+// catalina.corepolicy - Security Policy Permissions for Tomcat 6
 //
 // This file contains a default set of security policies to be enforced (by the
 // JVM) when Catalina is executed with the "-security" option.  In addition
@@ -134,7 +134,8 @@ grant {
     // Allow read of JAXP compliant XML parser debug
     permission java.util.PropertyPermission "jaxp.debug", "read";
 
-    // Precompiled JSPs need access to this package.
+    // Precompiled JSPs need access to these packages.
+    permission java.lang.RuntimePermission "accessClassInPackage.org.apache.jasper.el";
     permission java.lang.RuntimePermission "accessClassInPackage.org.apache.jasper.runtime";
     permission java.lang.RuntimePermission "accessClassInPackage.org.apache.jasper.runtime.*";
     

commit f748e8978d91a4206447a20bf286b9a53e70cfaa
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Sat Nov 29 20:20:06 2008 +0000

    Lots of EL failures with a security manager without this.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@721708 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/conf/catalina.policy b/conf/catalina.policy
index e7dde73..edb601b 100644
--- a/conf/catalina.policy
+++ b/conf/catalina.policy
@@ -138,9 +138,9 @@ grant {
     permission java.lang.RuntimePermission "accessClassInPackage.org.apache.jasper.runtime";
     permission java.lang.RuntimePermission "accessClassInPackage.org.apache.jasper.runtime.*";
     
-    // Precompiled JSPs need access to this system property.
+    // Precompiled JSPs need access to these system properties.
     permission java.util.PropertyPermission "org.apache.jasper.runtime.BodyContentImpl.LIMIT_BUFFER", "read";
-
+    permission java.util.PropertyPermission "org.apache.el.parser.COERCE_TO_ZERO", "read";
 };
 
 

commit 29fa038cff2fb67030f9afbb9d2832b1c5e4b26b
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Sat Nov 29 19:01:57 2008 +0000

    Fix some TCK failures when using a security manager.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@721704 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/core/DefaultInstanceManager.java b/java/org/apache/catalina/core/DefaultInstanceManager.java
index cc7a76f..254289f 100644
--- a/java/org/apache/catalina/core/DefaultInstanceManager.java
+++ b/java/org/apache/catalina/core/DefaultInstanceManager.java
@@ -205,14 +205,24 @@ public class DefaultInstanceManager implements InstanceManager {
      * @throws java.lang.reflect.InvocationTargetException
      *                                if call fails
      */
-    protected void preDestroy(Object instance, Class<?> clazz)
+    protected void preDestroy(Object instance, final Class<?> clazz)
             throws IllegalAccessException, InvocationTargetException {
         Class<?> superClass = clazz.getSuperclass();
         if (superClass != Object.class) {
             preDestroy(instance, superClass);
         }
 
-        Method[] methods = clazz.getDeclaredMethods();
+        Method[] methods;
+        if (Globals.IS_SECURITY_ENABLED) {
+            methods = AccessController.doPrivileged(
+                    new PrivilegedAction<Method[]>(){
+                public Method[] run(){
+                    return clazz.getDeclaredMethods();
+                }
+            });
+        } else {
+            methods = clazz.getDeclaredMethods();
+        }
         Method preDestroy = null;
         for (Method method : methods) {
             if (method.isAnnotationPresent(PreDestroy.class)) {
diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index 23d45ca..7cd230f 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -64,6 +64,21 @@ public final class SecurityClassLoad {
              "core.ContainerBase$PrivilegedAddChild");
         loader.loadClass
             (basePackage +
+             "core.DefaultInstanceManager$1");
+        loader.loadClass
+            (basePackage +
+             "core.DefaultInstanceManager$2");
+        loader.loadClass
+            (basePackage +
+             "core.DefaultInstanceManager$3");
+        loader.loadClass
+            (basePackage +
+             "core.DefaultInstanceManager$4");
+        loader.loadClass
+            (basePackage +
+             "core.DefaultInstanceManager$5");
+        loader.loadClass
+            (basePackage +
              "core.ApplicationHttpRequest$AttributeNamesEnumerator");
     }
     
diff --git a/java/org/apache/jasper/runtime/JspApplicationContextImpl.java b/java/org/apache/jasper/runtime/JspApplicationContextImpl.java
index a6431d3..0087a90 100644
--- a/java/org/apache/jasper/runtime/JspApplicationContextImpl.java
+++ b/java/org/apache/jasper/runtime/JspApplicationContextImpl.java
@@ -16,6 +16,8 @@
  */
 package org.apache.jasper.runtime;
 
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -37,6 +39,7 @@ import javax.servlet.jsp.el.ImplicitObjectELResolver;
 import javax.servlet.jsp.el.ScopedAttributeELResolver;
 
 import org.apache.el.ExpressionFactoryImpl;
+import org.apache.jasper.Constants;
 import org.apache.jasper.el.ELContextImpl;
 
 /**
@@ -88,8 +91,18 @@ public class JspApplicationContextImpl implements JspApplicationContext {
 		}
 
 		// create ELContext for JspContext
-		ELResolver r = this.createELResolver();
-		ELContextImpl ctx = new ELContextImpl(r);
+		final ELResolver r = this.createELResolver();
+		ELContextImpl ctx;
+		if (Constants.IS_SECURITY_ENABLED) {
+		    ctx = AccessController.doPrivileged(
+		            new PrivilegedAction<ELContextImpl>() {
+		                public ELContextImpl run() {
+		                    return new ELContextImpl(r);
+		                }
+		            });
+		} else {
+		    ctx = new ELContextImpl(r);
+		}
 		ctx.putContext(JspContext.class, context);
 
 		// alert all ELContextListeners

commit be8bf856d29aa52ef4739f71872b1a432267d83a
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Thu Nov 27 21:40:05 2008 +0000

    Add doPrivileged block required for Servlet TCK to pass when running with a security manager
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@721286 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/jasper/runtime/JspFactoryImpl.java b/java/org/apache/jasper/runtime/JspFactoryImpl.java
index f06a49d..f9852b3 100644
--- a/java/org/apache/jasper/runtime/JspFactoryImpl.java
+++ b/java/org/apache/jasper/runtime/JspFactoryImpl.java
@@ -196,7 +196,17 @@ public class JspFactoryImpl extends JspFactory {
 
     }
 
-    public JspApplicationContext getJspApplicationContext(ServletContext context) {
-        return JspApplicationContextImpl.getInstance(context);
+    public JspApplicationContext getJspApplicationContext(
+            final ServletContext context) {
+        if (Constants.IS_SECURITY_ENABLED) {
+            return AccessController.doPrivileged(
+                    new PrivilegedAction<JspApplicationContext>() {
+                public JspApplicationContext run() {
+                    return JspApplicationContextImpl.getInstance(context);
+                }
+            });
+        } else {
+            return JspApplicationContextImpl.getInstance(context);
+        }
     }
 }

commit 218951ee1294d434da86bc778e039e97319e60e1
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Mon Nov 3 21:52:42 2008 +0000

    Remove the invoker servlet and all references for security reasons. This will not be proposed for backport to 6.0.x
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@710179 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/RELEASE-NOTES b/RELEASE-NOTES
index fbf0985..b42b104 100644
--- a/RELEASE-NOTES
+++ b/RELEASE-NOTES
@@ -34,7 +34,6 @@ KNOWN ISSUES IN THIS RELEASE:
 * Enabling SSI and CGI Support
 * Security manager URLs
 * Symlinking static resources
-* Enabling invoker servlet
 * Viewing the Tomcat Change Log
 * When all else fails
 
@@ -165,19 +164,6 @@ This behavior is optional, and the "allowLinking" flag may be used to disable
 the check.
 
 
-=========================
-Enabling invoker servlet:
-=========================
-Starting with Tomcat 4.1.12, the invoker servlet is no longer available by
-default in all webapps. Enabling it for all webapps is possible by editing
-$CATALINA_HOME/conf/web.xml to uncomment the "/servlet/*" servlet-mapping
-definition.
-
-Using the invoker servlet in a production environment is not recommended and
-is unsupported.  More details are available on the Tomcat FAQ at
-http://tomcat.apache.org/faq/misc.html#invoker.
-
-
 ==============================
 Viewing the Tomcat Change Log:
 ==============================
diff --git a/conf/web.xml b/conf/web.xml
index 9c7d344..5431a37 100644
--- a/conf/web.xml
+++ b/conf/web.xml
@@ -102,34 +102,6 @@
     </servlet>
 
 
-  <!-- The "invoker" servlet, which executes anonymous servlet classes      -->
-  <!-- that have not been defined in a web.xml file.  Traditionally, this   -->
-  <!-- servlet is mapped to the URL pattern "/servlet/*", but you can map   -->
-  <!-- it to other patterns as well.  The extra path info portion of such a -->
-  <!-- request must be the fully qualified class name of a Java class that  -->
-  <!-- implements Servlet (or extends HttpServlet), or the servlet name     -->
-  <!-- of an existing servlet definition.     This servlet supports the     -->
-  <!-- following initialization parameters (default values are in square    -->
-  <!-- brackets):                                                           -->
-  <!--                                                                      -->
-  <!--   debug               Debugging detail level for messages logged     -->
-  <!--                       by this servlet.  [0]                          -->
-
-<!--
-    <servlet>
-        <servlet-name>invoker</servlet-name>
-        <servlet-class>
-          org.apache.catalina.servlets.InvokerServlet
-        </servlet-class>
-        <init-param>
-            <param-name>debug</param-name>
-            <param-value>0</param-value>
-        </init-param>
-        <load-on-startup>2</load-on-startup>
-    </servlet>
--->
-
-
   <!-- The JSP page compiler and execution servlet, which is the mechanism  -->
   <!-- used by Tomcat to support JSP pages.  Traditionally, this servlet    -->
   <!-- is mapped to the URL pattern "*.jsp".  This servlet supports the     -->
@@ -364,14 +336,6 @@
         <url-pattern>/</url-pattern>
     </servlet-mapping>
 
-    <!-- The mapping for the invoker servlet -->
-<!--
-    <servlet-mapping>
-        <servlet-name>invoker</servlet-name>
-        <url-pattern>/servlet/*</url-pattern>
-    </servlet-mapping>
--->
-
     <!-- The mapping for the JSP servlet -->
     <servlet-mapping>
         <servlet-name>jsp</servlet-name>
diff --git a/java/org/apache/catalina/Globals.java b/java/org/apache/catalina/Globals.java
index 597113c..0d0125b 100644
--- a/java/org/apache/catalina/Globals.java
+++ b/java/org/apache/catalina/Globals.java
@@ -121,15 +121,6 @@ public final class Globals {
 
 
     /**
-     * The request attribute under which the Invoker servlet will store
-     * the invoking servlet path, if it was used to execute a servlet
-     * indirectly instead of through a servlet mapping.
-     */
-    public static final String INVOKED_ATTR =
-        "org.apache.catalina.INVOKED";
-
-
-    /**
      * The request attribute under which we expose the value of the
      * <code>&lt;jsp-file&gt;</code> value associated with this servlet,
      * if any.
diff --git a/java/org/apache/catalina/core/ApplicationDispatcher.java b/java/org/apache/catalina/core/ApplicationDispatcher.java
index f9b4bba..89e9261 100644
--- a/java/org/apache/catalina/core/ApplicationDispatcher.java
+++ b/java/org/apache/catalina/core/ApplicationDispatcher.java
@@ -823,9 +823,6 @@ final class ApplicationDispatcher
         while (current != null) {
             if(state.hrequest == null && (current instanceof HttpServletRequest))
                 state.hrequest = (HttpServletRequest)current;
-            if ("org.apache.catalina.servlets.InvokerHttpRequest".
-                equals(current.getClass().getName()))
-                break; // KLUDGE - Make nested RD.forward() using invoker work
             if (!(current instanceof ServletRequestWrapper))
                 break;
             if (current instanceof ApplicationHttpRequest)
diff --git a/java/org/apache/catalina/core/RestrictedServlets.properties b/java/org/apache/catalina/core/RestrictedServlets.properties
index 17a6807..d336968 100644
--- a/java/org/apache/catalina/core/RestrictedServlets.properties
+++ b/java/org/apache/catalina/core/RestrictedServlets.properties
@@ -15,5 +15,4 @@
 
 org.apache.catalina.ssi.SSIServlet=restricted
 org.apache.catalina.servlets.CGIServlet=restricted
-org.apache.catalina.servlets.InvokerServlet=restricted
 org.apache.catalina.manager.JMXProxyServlet=restricted
diff --git a/java/org/apache/catalina/manager/LocalStrings.properties b/java/org/apache/catalina/manager/LocalStrings.properties
index 17ddde2..a6a95bb 100644
--- a/java/org/apache/catalina/manager/LocalStrings.properties
+++ b/java/org/apache/catalina/manager/LocalStrings.properties
@@ -57,7 +57,6 @@ htmlManagerServlet.serverVersion=Tomcat Version
 htmlManagerServlet.title=Tomcat Web Application Manager
 managerServlet.alreadyContext=FAIL - Application already exists at path {0}
 managerServlet.alreadyDocBase=FAIL - Directory {0} is already in use
-managerServlet.cannotInvoke=Cannot invoke manager servlet through invoker
 managerServlet.configured=OK - Deployed application from context file {0}
 managerServlet.deployed=OK - Deployed application at context path {0}
 managerServlet.deployFailed=FAIL - Failed to deploy application at context path {0}
diff --git a/java/org/apache/catalina/manager/LocalStrings_de.properties b/java/org/apache/catalina/manager/LocalStrings_de.properties
index 0296553..59c6353 100644
--- a/java/org/apache/catalina/manager/LocalStrings_de.properties
+++ b/java/org/apache/catalina/manager/LocalStrings_de.properties
@@ -55,7 +55,6 @@ htmlManagerServlet.serverVersion=Tomcat Version
 htmlManagerServlet.title=Tomcat Webanwendungs-Manager
 managerServlet.alreadyContext=FEHLER - Anwendung existiert bereits fr Kontext Pfad {0}
 managerServlet.alreadyDocBase=FEHLER - Verzeichnis {0} bereits in Benutzung
-managerServlet.cannotInvoke=Kann Manager-Servlet nicht durch Invoker aufrufen
 managerServlet.configured=OK - Anwendung von Kontext-Datei {0} installiert
 managerServlet.deployed=OK - Anwendung mit Kontext Pfad {0} installiert
 managerServlet.exception=FEHLER - Ausnahme aufgetreten {0}
diff --git a/java/org/apache/catalina/manager/LocalStrings_fr.properties b/java/org/apache/catalina/manager/LocalStrings_fr.properties
index 903667d..023e937 100644
--- a/java/org/apache/catalina/manager/LocalStrings_fr.properties
+++ b/java/org/apache/catalina/manager/LocalStrings_fr.properties
@@ -38,7 +38,6 @@ htmlManagerServlet.serverVersion=Version de serveur
 htmlManagerServlet.title=Gestionnaire d''applications WEB Tomcat
 managerServlet.alreadyContext=ECHEC - l''application existe dj dans le chemin {0}
 managerServlet.alreadyDocBase=ECHEC - Le rpertoire {0} est dj utilis
-managerServlet.cannotInvoke=Impossible d''utiliser le gestionnaire de servlet au travers du dlgu (invoker)
 managerServlet.configured=OK - Application configure depuis le fichier contexte {0}
 managerServlet.deployed=OK - Application dploye pour le chemin de contexte {0}
 managerServlet.exception=ECHEC - L''exception {0} a t rencontre
diff --git a/java/org/apache/catalina/manager/ManagerServlet.java b/java/org/apache/catalina/manager/ManagerServlet.java
index 9487932..2a5f129 100644
--- a/java/org/apache/catalina/manager/ManagerServlet.java
+++ b/java/org/apache/catalina/manager/ManagerServlet.java
@@ -144,11 +144,6 @@ import org.apache.tomcat.util.modeler.Registry;
  * generally be deployed as a separate web application within the virtual host
  * to be managed.
  * <p>
- * <b>NOTE</b> - For security reasons, this application will not operate
- * when accessed via the invoker servlet.  You must explicitly map this servlet
- * with a servlet mapping, and you will always want to protect it with
- * appropriate security constraints as well.
- * <p>
  * The following servlet initialization parameters are recognized:
  * <ul>
  * <li><b>debug</b> - The debugging detail level that controls the amount
@@ -318,11 +313,6 @@ public class ManagerServlet
                       HttpServletResponse response)
         throws IOException, ServletException {
 
-        // Verify that we were not accessed using the invoker servlet
-        if (request.getAttribute(Globals.INVOKED_ATTR) != null)
-            throw new UnavailableException
-                (sm.getString("managerServlet.cannotInvoke"));
-
         // Identify the request parameters that we need
         String command = request.getPathInfo();
         if (command == null)
@@ -404,11 +394,6 @@ public class ManagerServlet
                       HttpServletResponse response)
         throws IOException, ServletException {
 
-        // Verify that we were not accessed using the invoker servlet
-        if (request.getAttribute(Globals.INVOKED_ATTR) != null)
-            throw new UnavailableException
-                (sm.getString("managerServlet.cannotInvoke"));
-
         // Identify the request parameters that we need
         String command = request.getPathInfo();
         if (command == null)
@@ -452,14 +437,6 @@ public class ManagerServlet
             throw new UnavailableException
                 (sm.getString("managerServlet.noWrapper"));
 
-        // Verify that we were not accessed using the invoker servlet
-        String servletName = getServletConfig().getServletName();
-        if (servletName == null)
-            servletName = "";
-        if (servletName.startsWith("org.apache.catalina.INVOKER."))
-            throw new UnavailableException
-                (sm.getString("managerServlet.cannotInvoke"));
-
         // Set our properties from the initialization parameters
         String value = null;
         try {
diff --git a/java/org/apache/catalina/manager/host/HostManagerServlet.java b/java/org/apache/catalina/manager/host/HostManagerServlet.java
index 3912018..42494e1 100644
--- a/java/org/apache/catalina/manager/host/HostManagerServlet.java
+++ b/java/org/apache/catalina/manager/host/HostManagerServlet.java
@@ -81,11 +81,6 @@ import org.apache.catalina.core.ContainerBase;
  * this servlet itself will not succeed.  Therefore, this servlet should
  * generally be deployed in a separate virtual host.
  * <p>
- * <b>NOTE</b> - For security reasons, this application will not operate
- * when accessed via the invoker servlet.  You must explicitly map this servlet
- * with a servlet mapping, and you will always want to protect it with
- * appropriate security constraints as well.
- * <p>
  * The following servlet initialization parameters are recognized:
  * <ul>
  * <li><b>debug</b> - The debugging detail level that controls the amount
@@ -216,11 +211,6 @@ public class HostManagerServlet
                       HttpServletResponse response)
         throws IOException, ServletException {
 
-        // Verify that we were not accessed using the invoker servlet
-        if (request.getAttribute(Globals.INVOKED_ATTR) != null)
-            throw new UnavailableException
-                (sm.getString("hostManagerServlet.cannotInvoke"));
-
         // Identify the request parameters that we need
         String command = request.getPathInfo();
         if (command == null)
@@ -324,14 +314,6 @@ public class HostManagerServlet
             throw new UnavailableException
                 (sm.getString("hostManagerServlet.noWrapper"));
 
-        // Verify that we were not accessed using the invoker servlet
-        String servletName = getServletConfig().getServletName();
-        if (servletName == null)
-            servletName = "";
-        if (servletName.startsWith("org.apache.catalina.INVOKER."))
-            throw new UnavailableException
-                (sm.getString("hostManagerServlet.cannotInvoke"));
-
         // Set our properties from the initialization parameters
         String value = null;
         try {
diff --git a/java/org/apache/catalina/manager/host/LocalStrings.properties b/java/org/apache/catalina/manager/host/LocalStrings.properties
index 58b476c..926b1f0 100644
--- a/java/org/apache/catalina/manager/host/LocalStrings.properties
+++ b/java/org/apache/catalina/manager/host/LocalStrings.properties
@@ -13,7 +13,6 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-hostManagerServlet.cannotInvoke=Cannot invoke host manager servlet through invoker
 hostManagerServlet.noCommand=FAIL - No command was specified
 hostManagerServlet.unknownCommand=FAIL - Unknown command {0}
 hostManagerServlet.noWrapper=Container has not called setWrapper() for this servlet
diff --git a/java/org/apache/catalina/servlets/CGIServlet.java b/java/org/apache/catalina/servlets/CGIServlet.java
index 2cd5e28..ceaaa89 100644
--- a/java/org/apache/catalina/servlets/CGIServlet.java
+++ b/java/org/apache/catalina/servlets/CGIServlet.java
@@ -288,14 +288,6 @@ public final class CGIServlet extends HttpServlet {
 
         super.init(config);
 
-        // Verify that we were not accessed using the invoker servlet
-        String servletName = getServletConfig().getServletName();
-        if (servletName == null)
-            servletName = "";
-        if (servletName.startsWith("org.apache.catalina.INVOKER."))
-            throw new UnavailableException
-                ("Cannot invoke CGIServlet through the invoker");
-        
         // Set our properties from the initialization parameters
         if (getServletConfig().getInitParameter("debug") != null)
             debug = Integer.parseInt(getServletConfig().getInitParameter("debug"));
@@ -560,11 +552,6 @@ public final class CGIServlet extends HttpServlet {
     protected void doGet(HttpServletRequest req, HttpServletResponse res)
         throws ServletException, IOException {
 
-        // Verify that we were not accessed using the invoker servlet
-        if (req.getAttribute(Globals.INVOKED_ATTR) != null)
-            throw new UnavailableException
-                ("Cannot invoke CGIServlet through the invoker");
-
         CGIEnvironment cgiEnv = new CGIEnvironment(req, getServletContext());
 
         if (cgiEnv.isValid()) {
diff --git a/java/org/apache/catalina/servlets/InvokerHttpRequest.java b/java/org/apache/catalina/servlets/InvokerHttpRequest.java
deleted file mode 100644
index 71f1431..0000000
--- a/java/org/apache/catalina/servlets/InvokerHttpRequest.java
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.servlets;
-
-
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletRequestWrapper;
-
-
-/**
- * Wrapper around a <code>javax.servlet.http.HttpServletRequest</code>
- * utilized when <code>InvokerServlet</code> processes the initial request
- * for an invoked servlet.  Subsequent requests will be mapped directly
- * to the servlet, because a new servlet mapping will have been created.
- *
- * @author Craig R. McClanahan
- * @version $Revision$ $Date$
- */
-
-class InvokerHttpRequest extends HttpServletRequestWrapper {
-
-
-    // ----------------------------------------------------------- Constructors
-
-
-    /**
-     * Construct a new wrapped request around the specified servlet request.
-     *
-     * @param request The servlet request being wrapped
-     */
-    public InvokerHttpRequest(HttpServletRequest request) {
-
-        super(request);
-        this.pathInfo = request.getPathInfo();
-        this.pathTranslated = request.getPathTranslated();
-        this.requestURI = request.getRequestURI();
-        this.servletPath = request.getServletPath();
-
-    }
-
-
-    // ----------------------------------------------------- Instance Variables
-
-
-    /**
-     * Descriptive information about this implementation.
-     */
-    protected static final String info =
-        "org.apache.catalina.servlets.InvokerHttpRequest/1.0";
-
-
-    /**
-     * The path information for this request.
-     */
-    protected String pathInfo = null;
-
-
-    /**
-     * The translated path information for this request.
-     */
-    protected String pathTranslated = null;
-
-
-    /**
-     * The request URI for this request.
-     */
-    protected String requestURI = null;
-
-
-    /**
-     * The servlet path for this request.
-     */
-    protected String servletPath = null;
-
-
-    // --------------------------------------------- HttpServletRequest Methods
-
-
-    /**
-     * Override the <code>getPathInfo()</code> method of the wrapped request.
-     */
-    public String getPathInfo() {
-
-        return (this.pathInfo);
-
-    }
-
-
-    /**
-     * Override the <code>getPathTranslated()</code> method of the
-     * wrapped request.
-     */
-    public String getPathTranslated() {
-
-        return (this.pathTranslated);
-
-    }
-
-
-    /**
-     * Override the <code>getRequestURI()</code> method of the wrapped request.
-     */
-    public String getRequestURI() {
-
-        return (this.requestURI);
-
-    }
-
-
-    /**
-     * Override the <code>getServletPath()</code> method of the wrapped
-     * request.
-     */
-    public String getServletPath() {
-
-        return (this.servletPath);
-
-    }
-
-
-    // -------------------------------------------------------- Package Methods
-
-
-
-    /**
-     * Return descriptive information about this implementation.
-     */
-    public String getInfo() {
-
-        return (info);
-
-    }
-
-
-    /**
-     * Set the path information for this request.
-     *
-     * @param pathInfo The new path info
-     */
-    void setPathInfo(String pathInfo) {
-
-        this.pathInfo = pathInfo;
-
-    }
-
-
-    /**
-     * Set the translated path info for this request.
-     *
-     * @param pathTranslated The new translated path info
-     */
-    void setPathTranslated(String pathTranslated) {
-
-        this.pathTranslated = pathTranslated;
-
-    }
-
-
-    /**
-     * Set the request URI for this request.
-     *
-     * @param requestURI The new request URI
-     */
-    void setRequestURI(String requestURI) {
-
-        this.requestURI = requestURI;
-
-    }
-
-
-    /**
-     * Set the servlet path for this request.
-     *
-     * @param servletPath The new servlet path
-     */
-    void setServletPath(String servletPath) {
-
-        this.servletPath = servletPath;
-
-    }
-
-
-}
diff --git a/java/org/apache/catalina/servlets/InvokerServlet.java b/java/org/apache/catalina/servlets/InvokerServlet.java
deleted file mode 100644
index de498ef..0000000
--- a/java/org/apache/catalina/servlets/InvokerServlet.java
+++ /dev/null
@@ -1,421 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.catalina.servlets;
-
-
-import java.io.IOException;
-
-import javax.servlet.Servlet;
-import javax.servlet.ServletException;
-import javax.servlet.UnavailableException;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.catalina.ContainerServlet;
-import org.apache.catalina.Context;
-import org.apache.catalina.Globals;
-import org.apache.catalina.Wrapper;
-import org.apache.catalina.util.StringManager;
-
-
-/**
- * The default servlet-invoking servlet for most web applications,
- * used to serve requests to servlets that have not been registered
- * in the web application deployment descriptor.
- *
- * @author Craig R. McClanahan
- * @version $Revision$ $Date$
- */
-
-public final class InvokerServlet
-    extends HttpServlet implements ContainerServlet {
-
-
-    // ----------------------------------------------------- Instance Variables
-
-
-    /**
-     * The Context container associated with our web application.
-     */
-    private Context context = null;
-
-
-    /**
-     * The debugging detail level for this servlet.
-     */
-    private int debug = 0;
-
-
-    /**
-     * The string manager for this package.
-     */
-    private static StringManager sm =
-        StringManager.getManager(Constants.Package);
-
-
-    /**
-     * The Wrapper container associated with this servlet.
-     */
-    private Wrapper wrapper = null;
-
-
-    // ----------------------------------------------- ContainerServlet Methods
-
-
-    /**
-     * Return the Wrapper with which we are associated.
-     */
-    public Wrapper getWrapper() {
-
-        return (this.wrapper);
-
-    }
-
-
-    /**
-     * Set the Wrapper with which we are associated.
-     *
-     * @param wrapper The new wrapper
-     */
-    public void setWrapper(Wrapper wrapper) {
-
-        this.wrapper = wrapper;
-        if (wrapper == null)
-            context = null;
-        else
-            context = (Context) wrapper.getParent();
-
-    }
-
-
-    // --------------------------------------------------------- Public Methods
-
-
-    /**
-     * Finalize this servlet.
-     */
-    public void destroy() {
-
-        ;       // No actions necessary
-
-    }
-
-
-    /**
-     * Process a GET request for the specified resource.
-     *
-     * @param request The servlet request we are processing
-     * @param response The servlet response we are creating
-     *
-     * @exception IOException if an input/output error occurs
-     * @exception ServletException if a servlet-specified error occurs
-     */
-    public void doGet(HttpServletRequest request,
-                      HttpServletResponse response)
-        throws IOException, ServletException {
-
-        serveRequest(request, response);
-
-    }
-
-
-    /**
-     * Process a HEAD request for the specified resource.
-     *
-     * @param request The servlet request we are processing
-     * @param response The servlet response we are creating
-     *
-     * @exception IOException if an input/output error occurs
-     * @exception ServletException if a servlet-specified error occurs
-     */
-    public void doHead(HttpServletRequest request,
-                       HttpServletResponse response)
-        throws IOException, ServletException {
-
-        serveRequest(request, response);
-
-    }
-
-
-    /**
-     * Process a POST request for the specified resource.
-     *
-     * @param request The servlet request we are processing
-     * @param response The servlet response we are creating
-     *
-     * @exception IOException if an input/output error occurs
-     * @exception ServletException if a servlet-specified error occurs
-     */
-    public void doPost(HttpServletRequest request,
-                       HttpServletResponse response)
-        throws IOException, ServletException {
-
-        serveRequest(request, response);
-
-    }
-
-
-    /**
-     * Initialize this servlet.
-     */
-    public void init() throws ServletException {
-
-        // Ensure that our ContainerServlet properties have been set
-        if ((wrapper == null) || (context == null))
-            throw new UnavailableException
-                (sm.getString("invokerServlet.noWrapper"));
-
-        // Set our properties from the initialization parameters
-        if (getServletConfig().getInitParameter("debug") != null)
-            debug = Integer.parseInt(getServletConfig().getInitParameter("debug"));
-
-        if (debug >= 1)
-            log("init: Associated with Context '" + context.getPath() + "'");
-
-    }
-
-
-
-    // -------------------------------------------------------- Private Methods
-
-
-    /**
-     * Serve the specified request, creating the corresponding response.
-     * After the first time a particular servlet class is requested, it will
-     * be served directly (like any registered servlet) because it will have
-     * been registered and mapped in our associated Context.
-     *
-     * @param request The servlet request we are processing
-     * @param response The servlet response we are creating
-     *
-     * @exception IOException if an input/output error occurs
-     * @exception ServletException if a servlet-specified error occurs
-     */
-    public void serveRequest(HttpServletRequest request,
-                             HttpServletResponse response)
-        throws IOException, ServletException {
-
-        // Disallow calling this servlet via a named dispatcher
-        if (request.getAttribute(Globals.NAMED_DISPATCHER_ATTR) != null)
-            throw new ServletException
-                (sm.getString("invokerServlet.notNamed"));
-
-        // Identify the input parameters and our "included" state
-        String inRequestURI = null;
-        String inServletPath = null;
-        String inPathInfo = null;
-        boolean included =
-            (request.getAttribute(Globals.INCLUDE_REQUEST_URI_ATTR) != null);
-
-        if (included) {
-            inRequestURI =
-                (String) request.getAttribute(Globals.INCLUDE_REQUEST_URI_ATTR);
-            inServletPath =
-                (String) request.getAttribute(Globals.INCLUDE_SERVLET_PATH_ATTR);
-            inPathInfo =
-                (String) request.getAttribute(Globals.INCLUDE_PATH_INFO_ATTR);
-        } else {
-            inRequestURI = request.getRequestURI();
-            inServletPath = request.getServletPath();
-            inPathInfo = request.getPathInfo();
-        }
-        if (debug >= 1) {
-            log("included='" + included + "', requestURI='" +
-                inRequestURI + "'");
-            log("  servletPath='" + inServletPath + "', pathInfo='" +
-                inPathInfo + "'");
-        }
-
-        // Make sure a servlet name or class name was specified
-        if (inPathInfo == null) {
-            if (debug >= 1)
-                log("Invalid pathInfo '" + inPathInfo + "'");
-            if (included)
-                throw new ServletException
-                    (sm.getString("invokerServlet.invalidPath", inRequestURI));
-            else {
-                response.sendError(HttpServletResponse.SC_NOT_FOUND,
-                                   inRequestURI);
-                return;
-            }
-        }
-
-        // Identify the outgoing servlet name or class, and outgoing path info
-        String pathInfo = inPathInfo;
-        String servletClass = pathInfo.substring(1);
-        int slash = servletClass.indexOf('/');
-        if (slash >= 0) {
-            pathInfo = servletClass.substring(slash);
-            servletClass = servletClass.substring(0, slash);
-        } else {
-            pathInfo = "";
-        }
-
-        if (servletClass.startsWith("org.apache.catalina")) {
-            response.sendError(HttpServletResponse.SC_NOT_FOUND,
-                               inRequestURI);
-            return;
-        }
-
-        if (debug >= 1)
-            log("Processing servlet '" + servletClass +
-                "' with path info '" + pathInfo + "'");
-        String name = "org.apache.catalina.INVOKER." + servletClass;
-        String pattern = inServletPath + "/" + servletClass + "/*";
-        Wrapper wrapper = null;
-
-        // Synchronize to avoid race conditions when multiple requests
-        // try to initialize the same servlet at the same time
-        synchronized (this) {
-
-            // Are we referencing an existing servlet class or name?
-            wrapper = (Wrapper) context.findChild(servletClass);
-            if (wrapper == null)
-                wrapper = (Wrapper) context.findChild(name);
-            if (wrapper != null) {
-                String actualServletClass = wrapper.getServletClass();
-                if ((actualServletClass != null)
-                    && (actualServletClass.startsWith
-                        ("org.apache.catalina"))) {
-                    response.sendError(HttpServletResponse.SC_NOT_FOUND,
-                                       inRequestURI);
-                    return;
-                }
-                if (debug >= 1)
-                    log("Using wrapper for servlet '" +
-                        wrapper.getName() + "' with mapping '" +
-                        pattern + "'");
-                context.addServletMapping(pattern, wrapper.getName());
-            }
-
-            // No, create a new wrapper for the specified servlet class
-            else {
-
-                if (debug >= 1)
-                    log("Creating wrapper for '" + servletClass +
-                        "' with mapping '" + pattern + "'");
-
-                try {
-                    wrapper = context.createWrapper();
-                    wrapper.setName(name);
-                    wrapper.setLoadOnStartup(1);
-                    wrapper.setServletClass(servletClass);
-                    context.addChild(wrapper);
-                    context.addServletMapping(pattern, name);
-                } catch (Exception e) {
-                    log(sm.getString("invokerServlet.cannotCreate",
-                                     inRequestURI), e);
-                    context.removeServletMapping(pattern);
-                    context.removeChild(wrapper);
-                    if (included)
-                        throw new ServletException
-                            (sm.getString("invokerServlet.cannotCreate",
-                                          inRequestURI), e);
-                    else {
-                        response.sendError(HttpServletResponse.SC_NOT_FOUND,
-                                           inRequestURI);
-                        return;
-                    }
-                }
-            }
-
-        }
-
-        // Create a request wrapper to pass on to the invoked servlet
-        InvokerHttpRequest wrequest =
-            new InvokerHttpRequest(request);
-        wrequest.setRequestURI(inRequestURI);
-        StringBuffer sb = new StringBuffer(inServletPath);
-        sb.append("/");
-        sb.append(servletClass);
-        wrequest.setServletPath(sb.toString());
-        if ((pathInfo == null) || (pathInfo.length() < 1)) {
-            wrequest.setPathInfo(null);
-            wrequest.setPathTranslated(null);
-        } else {
-            wrequest.setPathInfo(pathInfo);
-            wrequest.setPathTranslated
-                (getServletContext().getRealPath(pathInfo));
-        }
-
-        // Allocate a servlet instance to perform this request
-        Servlet instance = null;
-        try {
-            instance = wrapper.allocate();
-        } catch (ServletException e) {
-            log(sm.getString("invokerServlet.allocate", inRequestURI), e);
-            context.removeServletMapping(pattern);
-            context.removeChild(wrapper);
-            Throwable rootCause = e.getRootCause();
-            if (rootCause == null)
-                rootCause = e;
-            if (rootCause instanceof ClassNotFoundException) {
-                response.sendError(HttpServletResponse.SC_NOT_FOUND,
-                                   inRequestURI);
-                return;
-            } else if (rootCause instanceof IOException) {
-                throw (IOException) rootCause;
-            } else if (rootCause instanceof RuntimeException) {
-                throw (RuntimeException) rootCause;
-            } else if (rootCause instanceof ServletException) {
-                throw (ServletException) rootCause;
-            } else {
-                throw new ServletException
-                    (sm.getString("invokerServlet.allocate", inRequestURI),
-                     rootCause);
-            }
-        }
-
-        // After loading the wrapper, restore some of the fields when including
-        if (included) {
-            wrequest.setRequestURI(request.getRequestURI());
-            wrequest.setPathInfo(request.getPathInfo());
-            wrequest.setServletPath(request.getServletPath());
-        }
-
-        // Invoke the service() method of the allocated servlet
-        try {
-            String jspFile = wrapper.getJspFile();
-            if (jspFile != null)
-                request.setAttribute(Globals.JSP_FILE_ATTR, jspFile);
-            else
-                request.removeAttribute(Globals.JSP_FILE_ATTR);
-            request.setAttribute(Globals.INVOKED_ATTR,
-                                 request.getServletPath());
-            instance.service(wrequest, response);
-        } catch (UnavailableException e) {
-            context.removeServletMapping(pattern);
-            throw e;
-        } finally {
-            request.removeAttribute(Globals.INVOKED_ATTR);
-            request.removeAttribute(Globals.JSP_FILE_ATTR);
-            // Deallocate the allocated servlet instance
-            try {
-                wrapper.deallocate(instance);
-            } catch (ServletException e) {
-                log(sm.getString("invokerServlet.deallocate", inRequestURI), e);
-                throw e;
-            }
-        }
-
-    }
-
-
-}
diff --git a/java/org/apache/catalina/servlets/LocalStrings.properties b/java/org/apache/catalina/servlets/LocalStrings.properties
index a97b32c..3fdf505 100644
--- a/java/org/apache/catalina/servlets/LocalStrings.properties
+++ b/java/org/apache/catalina/servlets/LocalStrings.properties
@@ -18,12 +18,6 @@ defaultservlet.directorylistingfor=Directory Listing for:
 defaultservlet.upto=Up to:
 defaultservlet.subdirectories=Subdirectories:
 defaultservlet.files=Files:
-invokerServlet.allocate=Cannot allocate servlet instance for path {0}
-invokerServlet.cannotCreate=Cannot create servlet wrapper for path {0}
-invokerServlet.deallocate=Cannot deallocate servlet instance for path {0}
-invokerServlet.invalidPath=No servlet name or class was specified in path {0}
-invokerServlet.notNamed=Cannot call invoker servlet with a named dispatcher
-invokerServlet.noWrapper=Container has not called setWrapper() for this servlet
 webdavservlet.jaxpfailed=JAXP initialization failed
 webdavservlet.enternalEntityIgnored=The request included a reference to an external entity with PublicID {0} and SystemID {1} which was ignored
 directory.filename=Filename
diff --git a/java/org/apache/catalina/servlets/LocalStrings_es.properties b/java/org/apache/catalina/servlets/LocalStrings_es.properties
index 373c290..c125c28 100644
--- a/java/org/apache/catalina/servlets/LocalStrings_es.properties
+++ b/java/org/apache/catalina/servlets/LocalStrings_es.properties
@@ -17,12 +17,6 @@ defaultservlet.directorylistingfor = Listado de Directorio para\:
 defaultservlet.upto = Atr\u00E1s a\:
 defaultservlet.subdirectories = Subdirectorios\:
 defaultservlet.files = Archivos\:
-invokerServlet.allocate = No puedo reservar espacio para instancia de servlet para trayectoria {0}
-invokerServlet.cannotCreate = No puedo crear arropador (wrapper) de servlet para trayectoria {0}
-invokerServlet.deallocate = No puedo recuperar instancia de servlet para trayectoria {0}
-invokerServlet.invalidPath = No se ha especificado nombre de servlet o clase en trayectoria {0}
-invokerServlet.notNamed = No puedo llamar a servlet invocador mediante un despachador nombrado (named)
-invokerServlet.noWrapper = El Contenedor no ha llamado a setWrapper() para este servlet
 webdavservlet.jaxpfailed = Fall\u00F3 la inicializaci\u00F3n de JAXP
 webdavservlet.enternalEntityIgnored = El requerimiento inclu\u00EDa una referencia a una entidad externa con PublicID {0} y SystemID {1} que fue ignorada
 directory.filename = Nombre de Archivo
diff --git a/java/org/apache/catalina/servlets/LocalStrings_fr.properties b/java/org/apache/catalina/servlets/LocalStrings_fr.properties
index bda9217..1ed30b1 100644
--- a/java/org/apache/catalina/servlets/LocalStrings_fr.properties
+++ b/java/org/apache/catalina/servlets/LocalStrings_fr.properties
@@ -17,12 +17,6 @@ defaultservlet.directorylistingfor=Liste du r
 defaultservlet.upto=Jusqu'':
 defaultservlet.subdirectories=Sous-rpertoires:
 defaultservlet.files=Fichiers:
-invokerServlet.allocate=Impossible d''allouer une instance de servlet pour le chemin {0}
-invokerServlet.cannotCreate=Impossible de crer un enrobeur (wrapper) de servlet pour le chemin {0}
-invokerServlet.deallocate=Impossible de dsallouer une instance de servlet pour le chemin {0}
-invokerServlet.invalidPath=Aucun nom de servlet ou de classe n''a t spcifi pour le chemin {0}
-invokerServlet.notNamed=Impossible d''appeler le dlgu (invoker) de servlet avec un aiguilleur (dispatcher) nomm
-invokerServlet.noWrapper=Le conteneur n''a pas appel "setWrapper()" pour cette servlet
 webdavservlet.jaxpfailed=Erreur d''initialisation de JAXP
 directory.filename=Nom de fichier
 directory.lastModified=Dernire modification
diff --git a/java/org/apache/catalina/servlets/LocalStrings_ja.properties b/java/org/apache/catalina/servlets/LocalStrings_ja.properties
index 1369672..5772ae5 100644
--- a/java/org/apache/catalina/servlets/LocalStrings_ja.properties
+++ b/java/org/apache/catalina/servlets/LocalStrings_ja.properties
@@ -17,12 +17,6 @@ defaultservlet.directorylistingfor=\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306e\u4
 defaultservlet.upto=\u89aa\u30c7\u30a3\u30ec\u30af\u30c8\u30ea: 
 defaultservlet.subdirectories=\u30b5\u30d6\u30c7\u30a3\u30ec\u30af\u30c8\u30ea:
 defaultservlet.files=\u30d5\u30a1\u30a4\u30eb:
-invokerServlet.allocate=\u30d1\u30b9 {0} \u306b\u30b5\u30fc\u30d6\u30ec\u30c3\u30c8\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u5272\u308a\u5f53\u3066\u3089\u308c\u307e\u305b\u3093
-invokerServlet.cannotCreate=\u30d1\u30b9 {0} \u306b\u30b5\u30fc\u30d6\u30ec\u30c3\u30c8\u30e9\u30c3\u30d1\u3092\u4f5c\u6210\u3067\u304d\u307e\u305b\u3093
-invokerServlet.deallocate=\u30d1\u30b9 {0} \u306e\u30b5\u30fc\u30d6\u30ec\u30c3\u30c8\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u306e\u5272\u308a\u5f53\u3066\u3092\u89e3\u9664\u3067\u304d\u307e\u305b\u3093
-invokerServlet.invalidPath=\u30d1\u30b9 {0} \u306b\u30b5\u30fc\u30d6\u30ec\u30c3\u30c8\u540d\u53c8\u306f\u30af\u30e9\u30b9\u304c\u6307\u5b9a\u3055\u308c\u3066\u3044\u307e\u305b\u3093
-invokerServlet.notNamed=\u305d\u306e\u540d\u524d\u306e\u30c7\u30a3\u30b9\u30d1\u30c3\u30c1\u30e3\u3067\u30a4\u30f3\u30dc\u30fc\u30ab\u30b5\u30fc\u30d6\u30ec\u30c3\u30c8\u3092\u547c\u3073\u51fa\u305b\u307e\u305b\u3093
-invokerServlet.noWrapper=\u30b3\u30f3\u30c6\u30ca\u306f\u3053\u306e\u30b5\u30fc\u30d6\u30ec\u30c3\u30c8\u306b\u5bfe\u3057\u3066\u547c\u3073\u51fa\u3055\u308c\u305fsetWrapper()\u3092\u6301\u3063\u3066\u3044\u307e\u305b\u3093
 webdavservlet.jaxpfailed=JAXP\u306e\u521d\u671f\u5316\u306b\u5931\u6557\u3057\u307e\u3057\u305f
 directory.filename=\u30d5\u30a1\u30a4\u30eb\u540d
 directory.lastModified=\u6700\u7d42\u66f4\u65b0
diff --git a/webapps/docs/funcspecs/fs-default.xml b/webapps/docs/funcspecs/fs-default.xml
index bb5e20a..71856b3 100644
--- a/webapps/docs/funcspecs/fs-default.xml
+++ b/webapps/docs/funcspecs/fs-default.xml
@@ -123,7 +123,7 @@
   <subsection name="Initialization Functionality">
 
     <p>The following processing must be performed when the <code>init()</code>
-    method of the invoker servlet is called:</p>
+    method of the default servlet is called:</p>
     <ul>
     <li>Process and sanity check configuration parameters.</li>
     </ul>
@@ -248,7 +248,7 @@
 
   <p>In addition the the assertions implied by the functionality requirements
   listed above, the following additional assertions shall be tested to
-  validate the behavior of the invoker servlet:</p>
+  validate the behavior of the default servlet:</p>
   <ul>
   <li>Requests for resources that do not exist in the web application must
       return HTTP status 404 (not found).</li>
diff --git a/webapps/docs/funcspecs/fs-invoker.xml b/webapps/docs/funcspecs/fs-invoker.xml
deleted file mode 100644
index 34bf02e..0000000
--- a/webapps/docs/funcspecs/fs-invoker.xml
+++ /dev/null
@@ -1,263 +0,0 @@
-<?xml version="1.0"?>
-<!--
-  Licensed to the Apache Software Foundation (ASF) under one or more
-  contributor license agreements.  See the NOTICE file distributed with
-  this work for additional information regarding copyright ownership.
-  The ASF licenses this file to You under the Apache License, Version 2.0
-  (the "License"); you may not use this file except in compliance with
-  the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<!DOCTYPE document [
-  <!ENTITY project SYSTEM "project.xml">
-]>
-<document url="fs-invoker.html">
-
-  &project;
-
-  <properties>
-    <author email="craigmcc@apache.org">Craig McClanahan</author>
-    <title>Invoker Servlet</title>
-    <revision>$Id$</revision>
-  </properties>
-
-<body>
-
-
-<section name="Overview">
-
-
-  <subsection name="Introduction">
-
-    <p>The purpose of the <strong>Invoker Servlet</strong> is to allow a
-    web application to dynamically register new <em>servlet definitions</em>
-    that correspond with a <code>&lt;servlet&gt;</code> element in the
-    <code>/WEB-INF/web.xml</code> deployment descriptor, and execute
-    requests utilizing the new servlet definitions.  From the perspective
-    of the newly registered servlets, all servlet lifecycle requirements
-    of the Servlet Specification (such as calling <code>init()</code> and
-    <code>destroy()</code> at the correct times) will be respected.</p>
-
-  </subsection>
-
-
-  <subsection name="External Specifications">
-
-    <p>I do not know of any formal specification of the behavior of an
-    invoker servlet that is publicly available.  Anyone know of one?</p>
-
-  </subsection>
-
-
-  <subsection name="Implementation Requirements">
-
-    <p>The implementation of this functionality shall conform to the
-    following requirements:</p>
-    <ul>
-    <li>Implemented as a servlet.</li>
-    <li>Exist in the <code>org.apache.catalina.servlets</code> package
-        so that it can be loaded by the Catalina class loader.</li>
-    <li>Implement the <code>org.apache.catalina.ContainerServlet</code>
-        interface, so that it gains knowledge of the <code>Wrapper</code>
-        that is responsible for itself and, therefore, access to other
-        internal Catalina components.</li>
-    <li>Support a configurable debugging detail level.</li>
-    <li>Log debugging and operational messages (suitably internationalized)
-        via the <code>getServletContext().log()</code> method.</li>
-    </ul>
-
-  </subsection>
-
-
-</section>
-
-
-<section name="Dependencies">
-
-
-  <subsection name="Environmental Dependencies">
-
-    <p>The following environmental dependencies must be met in order for
-    the Invoker servlet to operate correctly:</p>
-    <ul>
-    <li>The invoker servlet must be registered in the application deployment
-        descriptor (or the default deployment descriptor in file
-        <code>$CATALINA_BASE/conf/web.xml</code>) using a "path mapped"
-        servlet mapping.  The historical default mapping is to URL pattern
-        "<code>/servlet/*</code>", although the invoker servlet must operate
-        correctly with an arbitrary mapping.</li>
-    </ul>
-
-  </subsection>
-
-
-  <subsection name="Container Dependencies">
-
-    <p>Correct operation of the invoker servlet depends on the following
-    specific features of the surrounding container:</p>
-    <ul>
-    <li>Correct support for the <code>ContainerServlet</code> interface,
-        including calling <code>setWrapper()</code> <strong>before</strong>
-        the <code>init()</code> method of the invoker servlet is called.</li>
-    <li>The web application class loader must be stored as the context
-        class loader of the request processing thread.</li>
-    </ul>
-
-  </subsection>
-
-
-</section>
-
-
-<section name="Functionality">
-
-
-  <subsection name="Initialization Functionality">
-
-    <p>The following processing must be performed when the <code>init()</code>
-    method of the invoker servlet is called:</p>
-    <ul>
-    <li>Ensure that the container has called <code>setWrapper()</code>.  If
-        not, throw a permanent <code>UnavailableException</code>.</li>
-    <li>Look up and cache the <code>Context</code> that corresponds to our
-        <code>Wrapper</code>.  This is the component with which new servlet
-        definitions and mappings will be registered.</li>
-    </ul>
-
-  </subsection>
-
-
-  <subsection name="Per-Request Functionality">
-
-    <p>On each request, the following processing shall be performed:</p>
-    <ol>
-    <li>Calculate the <code>{ServletPath}</code> for this request, either from
-        request attribute <code>javax.servlet.include.servlet_path</code> or
-        by calling <code>request.getServletPath()</code>.</li>
-    <li>Calculate the <code>{PathInfo}</code> for this request, either from
-        request attribute <code>javax.servlet.include.path_info</code> or
-        by calling <code>request.getPathInfo()</code>.  If the calculated
-        <code>{PathInfo}</code> is null, return HTTP status 400
-        (bad request).</li>
-    <li>Parse the calculated <code>{PathInfo}</code> value as follows:
-        <ol>
-        <li>Ignore the leading slash character.</li>
-        <li>Accumulate characters up to the next '/' (if any) as the
-            <code>{ServletSelector}</code>.</li>
-        <li>If a '/' was encountered, accumulate all characters from that
-            slash (inclusive) to the end of the string as
-            <code>{PathRemainder}</code>.  If no slash was encountered,
-            set <code>{PathRemainder}</code> to a zero-length string.</li>
-        </ol></li>
-    <li>Determine whether <code>{ServletSelector}</code> is the name of an
-        existing servlet definition, and process it as follows:
-        <ol>
-        <li>Ask our associated <code>Context</code> to find and return a
-            child <code>Wrapper</code> named <code>{ServletSelector}</code>.
-            </li>
-        <li>If there is no such child, skip to the next major step.</li>
-        <li>Register a new servlet mapping for this <code>Wrapper</code>,
-            using a URL pattern calculated as follows:
-            <code>{ServletPath}</code> + "/" + <code>{ServletSelector}</code>
-            + "/*"</li>
-        <li>Create a request dispatcher using a path calculated as follows:
-            <code>{ServletPath}</code> + "/" + <code>{ServletSelector}</code>
-            + <code>{PathRemainder}</code></li>
-        <li>Forward this request to the created request dispatcher, and
-            exit from this request.</li>
-        </ol></li>
-    <li>Assume that <code>{ServletSelector}</code> is the fully qualified
-        name of a Java class that implements <code>javax.servlet.Servlet</code>
-        and process it as follows:
-        <ol>
-        <li>Synthesize a new <code>{ServletName}</code> for the servlet
-            definition that will be created.</li>
-        <li>If there is already a child <code>Wrapper</code> associated with
-            this name, return HTTP status 500 (internal server error), because
-            a mapping should have already been created for this servlet.</li>
-        <li>Attempt to load a class named <code>{ServletSelector}</code> from
-            the web application class loader (i.e. the context class loader
-            for our current thread).  If this fails, return HTTP status 404
-            (not found).</li>
-        <li>Instantiate an instance of this class.  If an error occurs,
-            return HTTP status 404 (not found).</li>
-        <li>If this class does not implement the
-            <code>javax.servlet.Servlet</code> interface, return HTTP status
-            404 (not found).</li>
-        <li>Create and register a new <code>Wrapper</code> child with our
-            <code>Context</code>, under name <code>{ServletName}</code>.</li>
-        <li>Register a new servlet mapping for this <code>Wrapper</code>,
-            using a URL pattern calculated as follows:
-            <code>{ServletPath}</code> + "/" + <code>{ServletSelector}</code>
-            + "/*"</li>
-        <li>Create a request dispatcher using a path calculated as follows:
-            <code>{ServletPath}</code> + "/" + <code>{ServletSelector}</code>
-            + <code>{PathRemainder}</code></li>
-        <li>Forward this request to the created request dispatcher, and
-            exit from this request.</li>
-        </ol></li>
-    </ol>
-
-  </subsection>
-
-
-  <subsection name="Finalization Functionality">
-
-    <p>No specific processing is required when the <code>destroy()</code>
-    method is called:</p>
-
-  </subsection>
-
-
-</section>
-
-
-<section name="Testable Assertions">
-
-  <p>In addition the the assertions implied by the functionality requirements
-  listed above, the following additional assertions shall be tested to
-  validate the behavior of the invoker servlet:</p>
-  <ul>
-  <li>It is possible to access an existing servlet definition by name
-      through the invoker.  The existing servlet definition can include
-      either a <code>&lt;servlet-class&gt;</code> or
-      <code>&lt;jsp-file&gt;</code> subelement.</li>
-  <li>When an existing servlet definition is accessed by name, the request
-      will be ultimately processed by the same servlet instance that would
-      have processed it had a mapping to that servlet definition been used
-      on the request directly.</li>
-  <li>It is possible to access an anonymous servlet by class name
-      through the invoker.</li>
-  <li>When an anonymous servlet is accessed, the servlet instance is processed
-      according to the lifecycle requirements of the Servlet Specification.
-      </li>
-  <li>When an anonymous servlet is accessed, the servlet instance receives
-      a <code>ServletConfig</code> instance with no servlet initialization
-      parameters.</li>
-  <li>It is possible to utilize the invoker servlet via a direct request.</li>
-  <li>It is possible to utilize the invoker servlet via a call to
-      <code>RequestDispatcher.forward()</code>, or the corresponding
-      <code>&lt;jsp:forward&gt;</code> tag in a JSP page.</li>
-  <li>It is possible to utilize the invoker servlet via a call to
-      <code>RequestDispatcher.include()</code>, or the corresponding
-      <code>&lt;jsp:include&gt;</code> tag in a JSP page.</li>
-  <li>It is possible to use any HTTP method (including GET and POST) that
-      is supported by the Servlet class that is ultimately executed.</li>
-  <li>The invoker servlet should never be asked to process a second or
-      subsequent request for the same <code>{ServletSelector}</code> (because
-      it will have registered an appropriate servlet mapping.</li>
-  </ul>
-
-</section>
-
-
-</body>
-
-</document>
diff --git a/webapps/docs/funcspecs/project.xml b/webapps/docs/funcspecs/project.xml
index 213204f..09d2033 100644
--- a/webapps/docs/funcspecs/project.xml
+++ b/webapps/docs/funcspecs/project.xml
@@ -40,7 +40,6 @@
 
     <menu name="Internal Servlets">
         <item name="Default Servlet"       href="fs-default.html"/>
-        <item name="Invoker Servlet"       href="fs-invoker.html"/>
     </menu>
 
     <menu name="Realm Implementations">
diff --git a/webapps/examples/WEB-INF/classes/filters/ExampleFilter.java b/webapps/examples/WEB-INF/classes/filters/ExampleFilter.java
index f8aaa36..3f27afb 100644
--- a/webapps/examples/WEB-INF/classes/filters/ExampleFilter.java
+++ b/webapps/examples/WEB-INF/classes/filters/ExampleFilter.java
@@ -126,8 +126,8 @@ public final class ExampleFilter implements Filter {
     public String toString() {
 
 	if (filterConfig == null)
-	    return ("InvokerFilter()");
-	StringBuffer sb = new StringBuffer("InvokerFilter(");
+	    return ("TimingFilter()");
+	StringBuffer sb = new StringBuffer("TimingFilter(");
 	sb.append(filterConfig);
 	sb.append(")");
 	return (sb.toString());
diff --git a/webapps/examples/WEB-INF/web.xml b/webapps/examples/WEB-INF/web.xml
index 0f3b933..478bdd5 100644
--- a/webapps/examples/WEB-INF/web.xml
+++ b/webapps/examples/WEB-INF/web.xml
@@ -27,23 +27,16 @@
     <display-name>Servlet and JSP Examples</display-name>
 
 
-    <!-- Define servlet-mapped and path-mapped example filters -->
+    <!-- Define example filters -->
     <filter>
-        <filter-name>Servlet Mapped Filter</filter-name>
+        <filter-name>Timing filter</filter-name>
         <filter-class>filters.ExampleFilter</filter-class>
 	<init-param>
 	    <param-name>attribute</param-name>
-	    <param-value>filters.ExampleFilter.SERVLET_MAPPED</param-value>
-	</init-param>
-    </filter>
-    <filter>
-        <filter-name>Path Mapped Filter</filter-name>
-        <filter-class>filters.ExampleFilter</filter-class>
-	<init-param>
-	    <param-name>attribute</param-name>
-	    <param-value>filters.ExampleFilter.PATH_MAPPED</param-value>
+	    <param-value>filters.ExampleFilter</param-value>
 	</init-param>
     </filter>
+
     <filter>
         <filter-name>Request Dumper Filter</filter-name>
         <filter-class>filters.RequestDumperFilter</filter-class>
@@ -73,15 +66,13 @@
         </init-param>
     </filter>
 
-    <!-- Define filter mappings for the defined filters -->
+    <!-- Define filter mappings for the timing filters -->
+    <!--
     <filter-mapping>
-        <filter-name>Servlet Mapped Filter</filter-name>
-	<servlet-name>invoker</servlet-name>
-    </filter-mapping>
-    <filter-mapping>
-        <filter-name>Path Mapped Filter</filter-name>
-	<url-pattern>/servlet/*</url-pattern>
+        <filter-name>Timing Filter</filter-name>
+        <url-pattern>/*</url-pattern>
     </filter-mapping>
+    -->
 
 <!-- Example filter mapping to apply the "Set Character Encoding" filter
      to *all* requests processed by this web application -->

commit 428c03bd89e4603cf726a67881f5da81617013c9
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Mon Oct 27 17:28:16 2008 +0000

    Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=46096
    Allow for running under a security manager when processing annotations.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@708243 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/core/DefaultInstanceManager.java b/java/org/apache/catalina/core/DefaultInstanceManager.java
index 0997cc6..cc7a76f 100644
--- a/java/org/apache/catalina/core/DefaultInstanceManager.java
+++ b/java/org/apache/catalina/core/DefaultInstanceManager.java
@@ -26,6 +26,7 @@ import java.lang.reflect.Modifier;
 import java.util.Map;
 import java.util.Properties;
 import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.security.PrivilegedExceptionAction;
 import java.security.PrivilegedActionException;
 import java.io.InputStream;
@@ -46,6 +47,7 @@ import javax.servlet.Servlet;
 import org.apache.InstanceManager;
 import org.apache.catalina.security.SecurityUtil;
 import org.apache.catalina.ContainerServlet;
+import org.apache.catalina.Globals;
 import org.apache.catalina.core.Constants;
 import org.apache.catalina.util.StringManager;
 
@@ -150,14 +152,24 @@ public class DefaultInstanceManager implements InstanceManager {
      * @throws java.lang.reflect.InvocationTargetException
      *                                if call fails
      */
-    protected void postConstruct(Object instance, Class<?> clazz)
+    protected void postConstruct(Object instance, final Class<?> clazz)
             throws IllegalAccessException, InvocationTargetException {
         Class<?> superClass = clazz.getSuperclass();
         if (superClass != Object.class) {
             postConstruct(instance, superClass);
         }
 
-        Method[] methods = clazz.getDeclaredMethods();
+        Method[] methods = null;
+        if (Globals.IS_SECURITY_ENABLED) {
+            methods = AccessController.doPrivileged(
+                    new PrivilegedAction<Method[]>(){
+                public Method[] run(){
+                    return clazz.getDeclaredMethods();
+                }
+            });
+        } else {
+            methods = clazz.getDeclaredMethods();
+        }
         Method postConstruct = null;
         for (Method method : methods) {
             if (method.isAnnotationPresent(PostConstruct.class)) {
@@ -249,7 +261,18 @@ public class DefaultInstanceManager implements InstanceManager {
         
         while (clazz != null) {
             // Initialize fields annotations
-            Field[] fields = clazz.getDeclaredFields();
+            Field[] fields = null;
+            if (Globals.IS_SECURITY_ENABLED) {
+                final Class<?> clazz2 = clazz;
+                fields = AccessController.doPrivileged(
+                        new PrivilegedAction<Field[]>(){
+                    public Field[] run(){
+                        return clazz2.getDeclaredFields();
+                    }
+                });
+            } else {
+                fields = clazz.getDeclaredFields();
+            }
             for (Field field : fields) {
                 if (injections != null && injections.containsKey(field.getName())) {
                     lookupFieldResource(context, instance, field,
@@ -281,7 +304,18 @@ public class DefaultInstanceManager implements InstanceManager {
             }
     
             // Initialize methods annotations
-            Method[] methods = clazz.getDeclaredMethods();
+            Method[] methods = null;
+            if (Globals.IS_SECURITY_ENABLED) {
+                final Class<?> clazz2 = clazz;
+                methods = AccessController.doPrivileged(
+                        new PrivilegedAction<Method[]>(){
+                    public Method[] run(){
+                        return clazz2.getDeclaredMethods();
+                    }
+                });
+            } else {
+                methods = clazz.getDeclaredMethods();
+            }
             for (Method method : methods) {
                 String methodName = method.getName();
                 if (injections != null && methodName.startsWith("set") && methodName.length() > 3) {

commit 7beabcd929cce72c0328c90369402e181af62a8c
Author: Rainer Jung <rjung@apache.org>
Date:   Fri Sep 19 19:51:59 2008 +0000

    Add an optional and configurable default role to the JNDIRealm.
    This comes handy, if you only want to authenticate the users,
    but have a security constraint with a role in the app.
    
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@697213 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/realm/JNDIRealm.java b/java/org/apache/catalina/realm/JNDIRealm.java
index 114b013..150738b 100644
--- a/java/org/apache/catalina/realm/JNDIRealm.java
+++ b/java/org/apache/catalina/realm/JNDIRealm.java
@@ -347,6 +347,12 @@ public class JNDIRealm extends RealmBase {
      */
     protected int curUserPattern = 0;
 
+    /**
+     *  Add this role to every authenticated user
+     */
+    protected String commonRole = null;
+
+
     // ------------------------------------------------------------- Properties
 
     /**
@@ -776,6 +782,28 @@ public class JNDIRealm extends RealmBase {
     }
 
 
+    /**
+     * Return the common role
+     */
+    public String getCommonRole() {
+
+        return commonRole;
+
+    }
+
+
+    /**
+     * Set the common role
+     *
+     * @param commonRole The common role
+     */
+    public void setCommonRole(String commonRole) {
+
+        this.commonRole = commonRole;
+
+    }
+
+
     // ---------------------------------------------------------- Realm Methods
 
 
@@ -1363,6 +1391,8 @@ public class JNDIRealm extends RealmBase {
         if (list == null) {
             list = new ArrayList<String>();
         }
+        if (commonRole != null)
+            list.add(commonRole);
 
         // Are we configured to do role searches?
         if ((roleFormat == null) || (roleName == null))
diff --git a/webapps/docs/config/realm.xml b/webapps/docs/config/realm.xml
index 0af0f92..ac1e313 100644
--- a/webapps/docs/config/realm.xml
+++ b/webapps/docs/config/realm.xml
@@ -304,6 +304,12 @@
          can be used. If no value is given the providers default is used.</p>
        </attribute>
 
+      <attribute name="commonRole" required="false">
+        <p>A role name assigned to each successfully authenticated user in
+        addition to the roles retrieved from LDAP. If not specified, only
+        the roles retrieved via LDAP are used.</p>
+      </attribute>
+
       <attribute name="connectionName" required="false">
         <p>The directory username to use when establishing a
         connection to the directory for LDAP search operations. If not
diff --git a/webapps/docs/realm-howto.xml b/webapps/docs/realm-howto.xml
index 09f8f0f..cfd37ba 100644
--- a/webapps/docs/realm-howto.xml
+++ b/webapps/docs/realm-howto.xml
@@ -859,6 +859,12 @@ attributes are supported by this implementation:</p>
         can be used. If no value is given the providers default is used.</p>
       </attribute>
 
+      <attribute name="commonRole" required="false">
+        <p>A role name assigned to each successfully authenticated user in
+        addition to the roles retrieved from LDAP. If not specified, only
+        the roles retrieved via LDAP are used.</p>
+      </attribute>
+
       <attribute name="connectionName" required="false">
         <p>The directory username to use when establishing a
         connection to the directory for LDAP search operations. If not

commit 1e51e49fe13fb8fe5ec5cf857db218aabf989951
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Thu Jul 10 23:00:31 2008 +0000

    Startup fails with security enabled
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@675796 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/security/SecurityClassLoad.java b/java/org/apache/catalina/security/SecurityClassLoad.java
index a71bbf3..0b88458 100644
--- a/java/org/apache/catalina/security/SecurityClassLoad.java
+++ b/java/org/apache/catalina/security/SecurityClassLoad.java
@@ -64,7 +64,7 @@ public final class SecurityClassLoad {
              "core.ContainerBase$PrivilegedAddChild");
         loader.loadClass
             (basePackage +
-             "core.StandardWrapper$1");
+             "core.StandardWrapper");
         loader.loadClass
         	(basePackage +
              "core.ApplicationHttpRequest$AttributeNamesEnumerator");

commit 8b17e7e20209187fc4f56bad99e95f2d764cc000
Author: Mark Emlyn David Thomas <markt@apache.org>
Date:   Mon Jul 30 23:48:45 2007 +0000

    Fix bug 42979. Update sample.war to include recent security fixes.
    Ported from TC5.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk@561188 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/webapps/docs/appdev/sample/index.html b/webapps/docs/appdev/sample/index.html
index 582c970..ed355be 100644
--- a/webapps/docs/appdev/sample/index.html
+++ b/webapps/docs/appdev/sample/index.html
@@ -20,7 +20,7 @@
         <a href="http://localhost:8080/sample">http://localhost:8080/sample</a>
       </p>
       <p>
-        If you just want to browse the code you can unpack the war file 
+        If you just want to browse the contents, you can unpack the war file 
         with the <b>jar</b> command.
         <source>
           jar -xvf sample.war
diff --git a/webapps/docs/appdev/sample/sample.war b/webapps/docs/appdev/sample/sample.war
index b649cc8..0a127e6 100644
Binary files a/webapps/docs/appdev/sample/sample.war and b/webapps/docs/appdev/sample/sample.war differ
diff --git a/webapps/docs/changelog.xml b/webapps/docs/changelog.xml
index 8663dc7..26ba961 100644
--- a/webapps/docs/changelog.xml
+++ b/webapps/docs/changelog.xml
@@ -26,9 +26,17 @@
          stop to fail. Based on a fix suggested by Michael Vorburger.
          Port of r454193 (<bug>36976</bug>) from Tomcat 5.5.x. (markt,rjung)
       </fix>
+    </changelog>
+  </subsection>
+  <subsection name="Webapps">
+    <changelog>
       <fix>
         Fix WebDAV Servlet so it works correctly with MS clients. (markt)
       </fix>
+      <fix>
+        <bug>42979</bug>: Update sample.war to include recent security fixes
+        in the source code. (markt)
+      </fix>
     </changelog>
   </subsection>
 </section>

commit fd6f5508267bfa8dccc05f1395c3375d34c3232d
Author: Remy Maucherat <remm@apache.org>
Date:   Fri Jun 29 12:35:04 2007 +0000

    - Fix a lost reference problem when using Comet with a security manager.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk@551870 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/core/ApplicationFilterFactory.java b/java/org/apache/catalina/core/ApplicationFilterFactory.java
index 212a173..f0bfef5 100644
--- a/java/org/apache/catalina/core/ApplicationFilterFactory.java
+++ b/java/org/apache/catalina/core/ApplicationFilterFactory.java
@@ -123,9 +123,13 @@ public final class ApplicationFilterFactory {
         ApplicationFilterChain filterChain = null;
         if (request instanceof Request) {
             Request req = (Request) request;
+            comet = req.isComet();
             if (Globals.IS_SECURITY_ENABLED) {
                 // Security: Do not recycle
                 filterChain = new ApplicationFilterChain();
+                if (comet) {
+                    req.setFilterChain(filterChain);
+                }
             } else {
                 filterChain = (ApplicationFilterChain) req.getFilterChain();
                 if (filterChain == null) {
@@ -133,7 +137,6 @@ public final class ApplicationFilterFactory {
                     req.setFilterChain(filterChain);
                 }
             }
-            comet = req.isComet();
         } else {
             // Request dispatcher in use
             filterChain = new ApplicationFilterChain();

commit 22c47be25fe7abd6f712b819e2f8416f873e07b1
Author: Remy Maucherat <remm@apache.org>
Date:   Fri Mar 30 14:38:02 2007 +0000

    - Adjustments to error processing with Comet during the begin event (exceptions not causing error reports).
    - Fix a probable bug when security was enabled (Comet would most likely not work).
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk@524103 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/connector/CoyoteAdapter.java b/java/org/apache/catalina/connector/CoyoteAdapter.java
index 7054fc6..810b755 100644
--- a/java/org/apache/catalina/connector/CoyoteAdapter.java
+++ b/java/org/apache/catalina/connector/CoyoteAdapter.java
@@ -216,7 +216,7 @@ public class CoyoteAdapter
                 connector.getContainer().getPipeline().getFirst().invoke(request, response);
 
                 if (request.isComet()) {
-                    if (!response.isClosed()) {
+                    if (!response.isClosed() && !response.isError()) {
                         comet = true;
                         res.action(ActionCode.ACTION_COMET_BEGIN, null);
                     } else {
diff --git a/java/org/apache/catalina/core/ApplicationFilterFactory.java b/java/org/apache/catalina/core/ApplicationFilterFactory.java
index c3cdd4f..212a173 100644
--- a/java/org/apache/catalina/core/ApplicationFilterFactory.java
+++ b/java/org/apache/catalina/core/ApplicationFilterFactory.java
@@ -121,16 +121,21 @@ public final class ApplicationFilterFactory {
         
         // Create and initialize a filter chain object
         ApplicationFilterChain filterChain = null;
-        if (!Globals.IS_SECURITY_ENABLED && (request instanceof Request)) {
+        if (request instanceof Request) {
             Request req = (Request) request;
-            filterChain = (ApplicationFilterChain) req.getFilterChain();
-            if (filterChain == null) {
+            if (Globals.IS_SECURITY_ENABLED) {
+                // Security: Do not recycle
                 filterChain = new ApplicationFilterChain();
-                req.setFilterChain(filterChain);
+            } else {
+                filterChain = (ApplicationFilterChain) req.getFilterChain();
+                if (filterChain == null) {
+                    filterChain = new ApplicationFilterChain();
+                    req.setFilterChain(filterChain);
+                }
             }
             comet = req.isComet();
         } else {
-            // Security: Do not recycle
+            // Request dispatcher in use
             filterChain = new ApplicationFilterChain();
         }
 
diff --git a/java/org/apache/catalina/core/StandardWrapperValve.java b/java/org/apache/catalina/core/StandardWrapperValve.java
index 887b1e6..c992de0 100644
--- a/java/org/apache/catalina/core/StandardWrapperValve.java
+++ b/java/org/apache/catalina/core/StandardWrapperValve.java
@@ -159,9 +159,10 @@ final class StandardWrapperValve
         }
 
         // Identify if the request is Comet related now that the servlet has been allocated
+        boolean comet = false;
         if (servlet instanceof CometProcessor 
                 && request.getAttribute("org.apache.tomcat.comet.support") == Boolean.TRUE) {
-            request.setComet(true);
+            comet = true;
         }
         
         // Acknowlege the request
@@ -209,8 +210,9 @@ final class StandardWrapperValve
                 if (context.getSwallowOutput()) {
                     try {
                         SystemLogHandler.startCapture();
-                        if (request.isComet()) {
+                        if (comet) {
                             filterChain.doFilterEvent(request.getEvent());
+                            request.setComet(true);
                         } else {
                             filterChain.doFilter(request.getRequest(), 
                                     response.getResponse());
@@ -222,8 +224,9 @@ final class StandardWrapperValve
                         }
                     }
                 } else {
-                    if (request.isComet()) {
+                    if (comet) {
                         filterChain.doFilterEvent(request.getEvent());
+                        request.setComet(true);
                     } else {
                         filterChain.doFilter
                             (request.getRequest(), response.getResponse());

commit dbfe39dce70949f609f8173194fab9ea52ca2c5b
Author: Remy Maucherat <remm@apache.org>
Date:   Sat Feb 10 00:54:56 2007 +0000

    - Set of minor optimizations.
    - Unify usage of the security manager flag.
    - Submitted by Arvind Srinivasan.
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk@505593 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/Globals.java b/java/org/apache/catalina/Globals.java
index dc89b4e..39dfb52 100644
--- a/java/org/apache/catalina/Globals.java
+++ b/java/org/apache/catalina/Globals.java
@@ -330,4 +330,11 @@ public final class Globals {
         Boolean.valueOf(System.getProperty("org.apache.catalina.STRICT_SERVLET_COMPLIANCE", "false")).booleanValue();
 
 
+    /**
+     * Has security been turned on?
+     */
+    public static final boolean IS_SECURITY_ENABLED =
+        (System.getSecurityManager() != null);
+
+
 }
diff --git a/java/org/apache/catalina/connector/Constants.java b/java/org/apache/catalina/connector/Constants.java
index 1884a9c..f401efa 100644
--- a/java/org/apache/catalina/connector/Constants.java
+++ b/java/org/apache/catalina/connector/Constants.java
@@ -39,11 +39,5 @@ public final class Constants {
     public static final int PROCESSOR_IDLE = 0;
     public static final int PROCESSOR_ACTIVE = 1;
 
-    /**
-     * Security flag.
-     */
-    public static final boolean SECURITY = 
-        (System.getSecurityManager() != null);
-
 
 }
diff --git a/java/org/apache/catalina/connector/OutputBuffer.java b/java/org/apache/catalina/connector/OutputBuffer.java
index c86bbca..4f282a2 100644
--- a/java/org/apache/catalina/connector/OutputBuffer.java
+++ b/java/org/apache/catalina/connector/OutputBuffer.java
@@ -27,6 +27,7 @@ import java.util.HashMap;
 
 import org.apache.coyote.ActionCode;
 import org.apache.coyote.Response;
+import org.apache.catalina.Globals;
 import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.buf.C2BConverter;
 
@@ -499,7 +500,7 @@ public class OutputBuffer extends Writer
         conv = (C2BConverter) encoders.get(enc);
         if (conv == null) {
             
-            if (System.getSecurityManager() != null){
+            if (Globals.IS_SECURITY_ENABLED){
                 try{
                     conv = (C2BConverter)AccessController.doPrivileged(
                             new PrivilegedExceptionAction(){
diff --git a/java/org/apache/catalina/connector/Request.java b/java/org/apache/catalina/connector/Request.java
index 11706f4..ea33f36 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -423,7 +423,7 @@ public class Request
         requestedSessionId = null;
         requestedSessionURL = false;
 
-        if (Constants.SECURITY || Connector.RECYCLE_FACADES) {
+        if (Globals.IS_SECURITY_ENABLED || Connector.RECYCLE_FACADES) {
             parameterMap = new ParameterMap();
         } else {
             parameterMap.setLocked(false);
@@ -432,7 +432,7 @@ public class Request
 
         mappingData.recycle();
 
-        if (Constants.SECURITY || Connector.RECYCLE_FACADES) {
+        if (Globals.IS_SECURITY_ENABLED || Connector.RECYCLE_FACADES) {
             if (facade != null) {
                 facade.clear();
                 facade = null;
@@ -1738,7 +1738,7 @@ public class Request
      */
     public void setUserPrincipal(Principal principal) {
 
-        if (System.getSecurityManager() != null){
+        if (Globals.IS_SECURITY_ENABLED){
             HttpSession session = getSession(false);
             if ( (subject != null) && 
                  (!subject.getPrincipals().contains(principal)) ){
diff --git a/java/org/apache/catalina/connector/RequestFacade.java b/java/org/apache/catalina/connector/RequestFacade.java
index 783b968..63f062e 100644
--- a/java/org/apache/catalina/connector/RequestFacade.java
+++ b/java/org/apache/catalina/connector/RequestFacade.java
@@ -32,6 +32,7 @@ import javax.servlet.http.Cookie;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpSession;
 
+import org.apache.catalina.Globals;
 import org.apache.catalina.util.StringManager;
 
 
@@ -270,7 +271,7 @@ public class RequestFacade implements HttpServletRequest {
                             sm.getString("requestFacade.nullRequest"));
         }
 
-        if (System.getSecurityManager() != null){
+        if (Globals.IS_SECURITY_ENABLED){
             return (Enumeration)AccessController.doPrivileged(
                 new GetAttributePrivilegedAction());        
         } else {
@@ -286,7 +287,7 @@ public class RequestFacade implements HttpServletRequest {
                             sm.getString("requestFacade.nullRequest"));
         }
 
-        if (System.getSecurityManager() != null){
+        if (Globals.IS_SECURITY_ENABLED){
             return (String)AccessController.doPrivileged(
                 new GetCharacterEncodingPrivilegedAction());
         } else {
@@ -347,7 +348,7 @@ public class RequestFacade implements HttpServletRequest {
                             sm.getString("requestFacade.nullRequest"));
         }
 
-        if (System.getSecurityManager() != null){
+        if (Globals.IS_SECURITY_ENABLED){
             return (String)AccessController.doPrivileged(
                 new GetParameterPrivilegedAction(name));
         } else {
@@ -363,7 +364,7 @@ public class RequestFacade implements HttpServletRequest {
                             sm.getString("requestFacade.nullRequest"));
         }
 
-        if (System.getSecurityManager() != null){
+        if (Globals.IS_SECURITY_ENABLED){
             return (Enumeration)AccessController.doPrivileged(
                 new GetParameterNamesPrivilegedAction());
         } else {
@@ -406,7 +407,7 @@ public class RequestFacade implements HttpServletRequest {
                             sm.getString("requestFacade.nullRequest"));
         }
 
-        if (System.getSecurityManager() != null){
+        if (Globals.IS_SECURITY_ENABLED){
             return (Map)AccessController.doPrivileged(
                 new GetParameterMapPrivilegedAction());        
         } else {
@@ -521,7 +522,7 @@ public class RequestFacade implements HttpServletRequest {
                             sm.getString("requestFacade.nullRequest"));
         }
 
-        if (System.getSecurityManager() != null){
+        if (Globals.IS_SECURITY_ENABLED){
             return (Locale)AccessController.doPrivileged(
                 new GetLocalePrivilegedAction());
         } else {
@@ -537,7 +538,7 @@ public class RequestFacade implements HttpServletRequest {
                             sm.getString("requestFacade.nullRequest"));
         }
 
-        if (System.getSecurityManager() != null){
+        if (Globals.IS_SECURITY_ENABLED){
             return (Enumeration)AccessController.doPrivileged(
                 new GetLocalesPrivilegedAction());
         } else {
@@ -564,7 +565,7 @@ public class RequestFacade implements HttpServletRequest {
                             sm.getString("requestFacade.nullRequest"));
         }
 
-        if (System.getSecurityManager() != null){
+        if (Globals.IS_SECURITY_ENABLED){
             return (RequestDispatcher)AccessController.doPrivileged(
                 new GetRequestDispatcherPrivilegedAction(path));
         } else {
@@ -650,7 +651,7 @@ public class RequestFacade implements HttpServletRequest {
                             sm.getString("requestFacade.nullRequest"));
         }
 
-        if (System.getSecurityManager() != null){
+        if (Globals.IS_SECURITY_ENABLED){
             return (Enumeration)AccessController.doPrivileged(
                 new GetHeadersPrivilegedAction(name));
         } else {
@@ -666,7 +667,7 @@ public class RequestFacade implements HttpServletRequest {
                             sm.getString("requestFacade.nullRequest"));
         }
 
-        if (System.getSecurityManager() != null){
+        if (Globals.IS_SECURITY_ENABLED){
             return (Enumeration)AccessController.doPrivileged(
                 new GetHeaderNamesPrivilegedAction());
         } else {
diff --git a/java/org/apache/catalina/connector/ResponseFacade.java b/java/org/apache/catalina/connector/ResponseFacade.java
index af72652..724eca5 100644
--- a/java/org/apache/catalina/connector/ResponseFacade.java
+++ b/java/org/apache/catalina/connector/ResponseFacade.java
@@ -30,6 +30,7 @@ import javax.servlet.ServletOutputStream;
 import javax.servlet.http.Cookie;
 import javax.servlet.http.HttpServletResponse;
 
+import org.apache.catalina.Globals;
 import org.apache.catalina.util.StringManager;
 import org.apache.catalina.security.SecurityUtil;
 
@@ -446,7 +447,7 @@ public class ResponseFacade
         if (isCommitted())
             return;
 
-        if(System.getSecurityManager() != null) {
+        if(Globals.IS_SECURITY_ENABLED) {
             AccessController.doPrivileged(new DateHeaderPrivilegedAction
                                              (name, date, false));
         } else {
@@ -461,7 +462,7 @@ public class ResponseFacade
         if (isCommitted())
             return;
 
-        if(System.getSecurityManager() != null) {
+        if(Globals.IS_SECURITY_ENABLED) {
             AccessController.doPrivileged(new DateHeaderPrivilegedAction
                                              (name, date, true));
         } else {
diff --git a/java/org/apache/catalina/core/ApplicationContextFacade.java b/java/org/apache/catalina/core/ApplicationContextFacade.java
index 3a849b9..d1373c0 100644
--- a/java/org/apache/catalina/core/ApplicationContextFacade.java
+++ b/java/org/apache/catalina/core/ApplicationContextFacade.java
@@ -36,6 +36,7 @@ import javax.servlet.Servlet;
 import javax.servlet.ServletContext;
 import javax.servlet.ServletException;
 
+import org.apache.catalina.Globals;
 import org.apache.catalina.security.SecurityUtil;
 
 
@@ -161,7 +162,7 @@ public final class ApplicationContextFacade
 
     public URL getResource(String path)
         throws MalformedURLException {
-        if (System.getSecurityManager() != null) {
+        if (Globals.IS_SECURITY_ENABLED) {
             try {
                 return (URL) invokeMethod(context, "getResource", 
                                           new Object[]{path});
diff --git a/java/org/apache/catalina/core/ApplicationDispatcher.java b/java/org/apache/catalina/core/ApplicationDispatcher.java
index 4a10815..7667081 100644
--- a/java/org/apache/catalina/core/ApplicationDispatcher.java
+++ b/java/org/apache/catalina/core/ApplicationDispatcher.java
@@ -287,7 +287,7 @@ final class ApplicationDispatcher
     public void forward(ServletRequest request, ServletResponse response)
         throws ServletException, IOException
     {
-        if (System.getSecurityManager() != null) {
+        if (Globals.IS_SECURITY_ENABLED) {
             try {
                 PrivilegedForward dp = new PrivilegedForward(request,response);
                 AccessController.doPrivileged(dp);
@@ -490,7 +490,7 @@ final class ApplicationDispatcher
     public void include(ServletRequest request, ServletResponse response)
         throws ServletException, IOException
     {
-        if (System.getSecurityManager() != null) {
+        if (Globals.IS_SECURITY_ENABLED) {
             try {
                 PrivilegedInclude dp = new PrivilegedInclude(request,response);
                 AccessController.doPrivileged(dp);
diff --git a/java/org/apache/catalina/core/ApplicationFilterChain.java b/java/org/apache/catalina/core/ApplicationFilterChain.java
index 36d4c0a..24ae109 100644
--- a/java/org/apache/catalina/core/ApplicationFilterChain.java
+++ b/java/org/apache/catalina/core/ApplicationFilterChain.java
@@ -178,7 +178,7 @@ final class ApplicationFilterChain implements FilterChain, CometFilterChain {
     public void doFilter(ServletRequest request, ServletResponse response)
         throws IOException, ServletException {
 
-        if( System.getSecurityManager() != null ) {
+        if( Globals.IS_SECURITY_ENABLED ) {
             final ServletRequest req = request;
             final ServletResponse res = response;
             try {
@@ -220,7 +220,7 @@ final class ApplicationFilterChain implements FilterChain, CometFilterChain {
                 support.fireInstanceEvent(InstanceEvent.BEFORE_FILTER_EVENT,
                                           filter, request, response);
                 
-                if( System.getSecurityManager() != null ) {
+                if( Globals.IS_SECURITY_ENABLED ) {
                     final ServletRequest req = request;
                     final ServletResponse res = response;
                     Principal principal = 
@@ -274,7 +274,7 @@ final class ApplicationFilterChain implements FilterChain, CometFilterChain {
             if ((request instanceof HttpServletRequest) &&
                 (response instanceof HttpServletResponse)) {
                     
-                if( System.getSecurityManager() != null ) {
+                if( Globals.IS_SECURITY_ENABLED ) {
                     final ServletRequest req = request;
                     final ServletResponse res = response;
                     Principal principal = 
@@ -336,7 +336,7 @@ final class ApplicationFilterChain implements FilterChain, CometFilterChain {
     public void doFilterEvent(CometEvent event)
         throws IOException, ServletException {
 
-        if( System.getSecurityManager() != null ) {
+        if( Globals.IS_SECURITY_ENABLED ) {
             final CometEvent ev = event;
             try {
                 java.security.AccessController.doPrivileged(
@@ -402,7 +402,7 @@ final class ApplicationFilterChain implements FilterChain, CometFilterChain {
                         filter, event);
                         */
 
-                if( System.getSecurityManager() != null ) {
+                if( Globals.IS_SECURITY_ENABLED ) {
                     final CometEvent ev = event;
                     Principal principal = 
                         ev.getHttpServletRequest().getUserPrincipal();
@@ -455,7 +455,7 @@ final class ApplicationFilterChain implements FilterChain, CometFilterChain {
             support.fireInstanceEvent(InstanceEvent.BEFORE_SERVICE_EVENT,
                     servlet, request, response);
                     */
-            if( System.getSecurityManager() != null ) {
+            if( Globals.IS_SECURITY_ENABLED ) {
                 final CometEvent ev = event;
                 Principal principal = 
                     ev.getHttpServletRequest().getUserPrincipal();
diff --git a/java/org/apache/catalina/core/ApplicationFilterConfig.java b/java/org/apache/catalina/core/ApplicationFilterConfig.java
index e71e44a..87f75fe 100644
--- a/java/org/apache/catalina/core/ApplicationFilterConfig.java
+++ b/java/org/apache/catalina/core/ApplicationFilterConfig.java
@@ -36,6 +36,7 @@ import javax.servlet.ServletException;
 
 import org.apache.AnnotationProcessor;
 import org.apache.catalina.Context;
+import org.apache.catalina.Globals;
 import org.apache.catalina.deploy.FilterDef;
 import org.apache.catalina.security.SecurityUtil;
 import org.apache.catalina.util.Enumerator;
@@ -320,7 +321,7 @@ final class ApplicationFilterConfig implements FilterConfig, Serializable {
 
         if (this.filter != null)
         {
-            if (System.getSecurityManager() != null) {
+            if (Globals.IS_SECURITY_ENABLED) {
                 try {
                     SecurityUtil.doAsPrivilege("destroy", filter); 
                 } catch(java.lang.Exception ex){                    
@@ -370,7 +371,7 @@ final class ApplicationFilterConfig implements FilterConfig, Serializable {
 
             // Release any previously allocated filter instance
             if (this.filter != null){
-                if( System.getSecurityManager() != null) {
+                if( Globals.IS_SECURITY_ENABLED) {
                     try{
                         SecurityUtil.doAsPrivilege("destroy", filter);  
                     } catch(java.lang.Exception ex){    
diff --git a/java/org/apache/catalina/core/ApplicationFilterFactory.java b/java/org/apache/catalina/core/ApplicationFilterFactory.java
index cb41188..c3cdd4f 100644
--- a/java/org/apache/catalina/core/ApplicationFilterFactory.java
+++ b/java/org/apache/catalina/core/ApplicationFilterFactory.java
@@ -58,9 +58,6 @@ public final class ApplicationFilterFactory {
     public static final String DISPATCHER_REQUEST_PATH_ATTR = 
         Globals.DISPATCHER_REQUEST_PATH_ATTR;
 
-    private static final SecurityManager securityManager = 
-        System.getSecurityManager();
-
     private static ApplicationFilterFactory factory = null;;
 
 
@@ -124,7 +121,7 @@ public final class ApplicationFilterFactory {
         
         // Create and initialize a filter chain object
         ApplicationFilterChain filterChain = null;
-        if ((securityManager == null) && (request instanceof Request)) {
+        if (!Globals.IS_SECURITY_ENABLED && (request instanceof Request)) {
             Request req = (Request) request;
             filterChain = (ApplicationFilterChain) req.getFilterChain();
             if (filterChain == null) {
diff --git a/java/org/apache/catalina/core/ContainerBase.java b/java/org/apache/catalina/core/ContainerBase.java
index d8401d4..d2e3dc7 100644
--- a/java/org/apache/catalina/core/ContainerBase.java
+++ b/java/org/apache/catalina/core/ContainerBase.java
@@ -41,6 +41,7 @@ import org.apache.catalina.Cluster;
 import org.apache.catalina.Container;
 import org.apache.catalina.ContainerEvent;
 import org.apache.catalina.ContainerListener;
+import org.apache.catalina.Globals;
 import org.apache.catalina.Lifecycle;
 import org.apache.catalina.LifecycleException;
 import org.apache.catalina.LifecycleListener;
@@ -732,7 +733,7 @@ public abstract class ContainerBase
      *  child Containers
      */
     public void addChild(Container child) {
-        if (System.getSecurityManager() != null) {
+        if (Globals.IS_SECURITY_ENABLED) {
             PrivilegedAction dp =
                 new PrivilegedAddChild(child);
             AccessController.doPrivileged(dp);
diff --git a/java/org/apache/catalina/core/StandardWrapper.java b/java/org/apache/catalina/core/StandardWrapper.java
index ed0003e..8c61204 100644
--- a/java/org/apache/catalina/core/StandardWrapper.java
+++ b/java/org/apache/catalina/core/StandardWrapper.java
@@ -52,6 +52,7 @@ import org.apache.PeriodicEventListener;
 import org.apache.catalina.Container;
 import org.apache.catalina.ContainerServlet;
 import org.apache.catalina.Context;
+import org.apache.catalina.Globals;
 import org.apache.catalina.InstanceEvent;
 import org.apache.catalina.InstanceListener;
 import org.apache.catalina.LifecycleException;
@@ -1148,7 +1149,7 @@ public class StandardWrapper
                 instanceSupport.fireInstanceEvent(InstanceEvent.BEFORE_INIT_EVENT,
                                                   servlet);
 
-                if( System.getSecurityManager() != null) {
+                if( Globals.IS_SECURITY_ENABLED) {
 
                     Object[] args = new Object[]{((ServletConfig)facade)};
                     SecurityUtil.doAsPrivilege("init",
@@ -1168,7 +1169,7 @@ public class StandardWrapper
                     req.setQueryString("jsp_precompile=true");
                     DummyResponse res = new DummyResponse();
 
-                    if( System.getSecurityManager() != null) {
+                    if( Globals.IS_SECURITY_ENABLED) {
                         Object[] args = new Object[]{req, res};
                         SecurityUtil.doAsPrivilege("service",
                                                    servlet,
@@ -1373,7 +1374,7 @@ public class StandardWrapper
             instanceSupport.fireInstanceEvent
               (InstanceEvent.BEFORE_DESTROY_EVENT, instance);
 
-            if( System.getSecurityManager() != null) {
+            if( Globals.IS_SECURITY_ENABLED) {
                 SecurityUtil.doAsPrivilege("destroy",
                                            instance);
                 SecurityUtil.remove(instance);                           
@@ -1421,7 +1422,7 @@ public class StandardWrapper
             try {
                 while (!instancePool.isEmpty()) {
                     Servlet s = (Servlet) instancePool.pop();
-                    if (System.getSecurityManager() != null) {
+                    if (Globals.IS_SECURITY_ENABLED) {
                         SecurityUtil.doAsPrivilege("destroy", s);
                         SecurityUtil.remove(instance);                           
                     } else {
diff --git a/java/org/apache/catalina/loader/WebappLoader.java b/java/org/apache/catalina/loader/WebappLoader.java
index 08f233c..1734f4b 100644
--- a/java/org/apache/catalina/loader/WebappLoader.java
+++ b/java/org/apache/catalina/loader/WebappLoader.java
@@ -788,7 +788,7 @@ public class WebappLoader
      */
     private void setPermissions() {
 
-        if (System.getSecurityManager() == null)
+        if (!Globals.IS_SECURITY_ENABLED)
             return;
         if (!(container instanceof Context))
             return;
diff --git a/java/org/apache/catalina/security/SecurityUtil.java b/java/org/apache/catalina/security/SecurityUtil.java
index afd5a81..8a6a4b2 100644
--- a/java/org/apache/catalina/security/SecurityUtil.java
+++ b/java/org/apache/catalina/security/SecurityUtil.java
@@ -375,7 +375,7 @@ public final class SecurityUtil{
      * package protection mechanism is enabled.
      */
     public static boolean isPackageProtectionEnabled(){
-        if (packageDefinitionEnabled && System.getSecurityManager() !=  null){
+        if (packageDefinitionEnabled && Globals.IS_SECURITY_ENABLED){
             return true;
         }
         return false;
diff --git a/java/org/apache/catalina/session/ManagerBase.java b/java/org/apache/catalina/session/ManagerBase.java
index eeaf1cb..38f4be4 100644
--- a/java/org/apache/catalina/session/ManagerBase.java
+++ b/java/org/apache/catalina/session/ManagerBase.java
@@ -44,6 +44,7 @@ import javax.management.ObjectName;
 
 import org.apache.catalina.Container;
 import org.apache.catalina.Engine;
+import org.apache.catalina.Globals;
 import org.apache.catalina.Manager;
 import org.apache.catalina.Session;
 import org.apache.catalina.core.StandardContext;
@@ -506,7 +507,7 @@ public abstract class ManagerBase implements Manager, MBeanRegistration {
     public void setRandomFile( String s ) {
         // as a hack, you can use a static file - and genarate the same
         // session ids ( good for strange debugging )
-        if (System.getSecurityManager() != null){
+        if (Globals.IS_SECURITY_ENABLED){
             randomIS = (DataInputStream)AccessController.doPrivileged(new PrivilegedSetRandomFile());          
         } else {
             try{
diff --git a/java/org/apache/catalina/session/StandardSession.java b/java/org/apache/catalina/session/StandardSession.java
index 6b29c74..42113dc 100644
--- a/java/org/apache/catalina/session/StandardSession.java
+++ b/java/org/apache/catalina/session/StandardSession.java
@@ -863,7 +863,6 @@ public class StandardSession
         id = null;
         lastAccessedTime = 0L;
         maxInactiveInterval = -1;
-        accessCount = null;
         notes.clear();
         setPrincipal(null);
         isNew = false;
diff --git a/java/org/apache/coyote/Constants.java b/java/org/apache/coyote/Constants.java
index 6f7e970..94647f1 100644
--- a/java/org/apache/coyote/Constants.java
+++ b/java/org/apache/coyote/Constants.java
@@ -53,4 +53,12 @@ public final class Constants {
     public static final int STAGE_ENDED = 7;
 
 
+    /**
+     * Has security been turned on?
+     */
+    public static final boolean IS_SECURITY_ENABLED =
+        (System.getSecurityManager() != null);
+
+
+
 }
diff --git a/java/org/apache/coyote/http11/Http11Processor.java b/java/org/apache/coyote/http11/Http11Processor.java
index 0ce7ccf..d5dfbb1 100644
--- a/java/org/apache/coyote/http11/Http11Processor.java
+++ b/java/org/apache/coyote/http11/Http11Processor.java
@@ -1542,7 +1542,7 @@ public class Http11Processor implements ActionHook {
 
         // Add date header
         String date = null;
-        if (System.getSecurityManager() != null){
+        if (org.apache.coyote.Constants.IS_SECURITY_ENABLED){
             date = (String)AccessController.doPrivileged(
                     new PrivilegedAction() {
                         public Object run(){
diff --git a/java/org/apache/coyote/http11/InternalOutputBuffer.java b/java/org/apache/coyote/http11/InternalOutputBuffer.java
index a013b59..1df2fc6 100644
--- a/java/org/apache/coyote/http11/InternalOutputBuffer.java
+++ b/java/org/apache/coyote/http11/InternalOutputBuffer.java
@@ -446,7 +446,7 @@ public class InternalOutputBuffer
         }
 
         // End the response status line
-        if (System.getSecurityManager() != null){
+        if (org.apache.coyote.Constants.IS_SECURITY_ENABLED){
            AccessController.doPrivileged(
                 new PrivilegedAction(){
                     public Object run(){
@@ -464,7 +464,7 @@ public class InternalOutputBuffer
     }
 
     private String getMessage(final int message){
-        if (System.getSecurityManager() != null){
+        if (org.apache.coyote.Constants.IS_SECURITY_ENABLED){
            return (String)AccessController.doPrivileged(
                 new PrivilegedAction(){
                     public Object run(){
diff --git a/java/org/apache/jasper/Constants.java b/java/org/apache/jasper/Constants.java
index dff908b..4ec2fef 100644
--- a/java/org/apache/jasper/Constants.java
+++ b/java/org/apache/jasper/Constants.java
@@ -187,4 +187,10 @@ public class Constants {
     public static final char ESC = '\u001b';
     public static final String ESCStr = "'\\u001b'";
 
+    /**
+     * Has security been turned on?
+     */
+    public static final boolean IS_SECURITY_ENABLED = 
+        (System.getSecurityManager() != null);
+
 }
diff --git a/java/org/apache/jasper/compiler/JspRuntimeContext.java b/java/org/apache/jasper/compiler/JspRuntimeContext.java
index b6a712d..4245a00 100644
--- a/java/org/apache/jasper/compiler/JspRuntimeContext.java
+++ b/java/org/apache/jasper/compiler/JspRuntimeContext.java
@@ -133,7 +133,7 @@ public final class JspRuntimeContext {
 	    return;
 	}
 
-        if (System.getSecurityManager() != null) {
+        if (Constants.IS_SECURITY_ENABLED) {
             initSecurity();
         }
 
diff --git a/java/org/apache/jasper/runtime/JspFactoryImpl.java b/java/org/apache/jasper/runtime/JspFactoryImpl.java
index 5183cde..49b667f 100644
--- a/java/org/apache/jasper/runtime/JspFactoryImpl.java
+++ b/java/org/apache/jasper/runtime/JspFactoryImpl.java
@@ -28,6 +28,7 @@ import javax.servlet.jsp.JspFactory;
 import javax.servlet.jsp.JspEngineInfo;
 import javax.servlet.jsp.PageContext;
 
+import org.apache.jasper.Constants;
 import org.apache.jasper.util.SimplePool;
 import org.apache.juli.logging.Log;
 import org.apache.juli.logging.LogFactory;
@@ -56,7 +57,7 @@ public class JspFactoryImpl extends JspFactory {
 				      int bufferSize,
                                       boolean autoflush) {
 
-	if( System.getSecurityManager() != null ) {
+	if( Constants.IS_SECURITY_ENABLED ) {
 	    PrivilegedGetPageContext dp = new PrivilegedGetPageContext(
 		(JspFactoryImpl)this, servlet, request, response, errorPageURL,
                 needsSession, bufferSize, autoflush);
@@ -71,7 +72,7 @@ public class JspFactoryImpl extends JspFactory {
     public void releasePageContext(PageContext pc) {
 	if( pc == null )
 	    return;
-        if( System.getSecurityManager() != null ) {
+        if( Constants.IS_SECURITY_ENABLED ) {
             PrivilegedReleasePageContext dp = new PrivilegedReleasePageContext(
                 (JspFactoryImpl)this,pc);
             AccessController.doPrivileged(dp);
diff --git a/java/org/apache/jasper/runtime/JspRuntimeLibrary.java b/java/org/apache/jasper/runtime/JspRuntimeLibrary.java
index aec6453..02d21dd 100644
--- a/java/org/apache/jasper/runtime/JspRuntimeLibrary.java
+++ b/java/org/apache/jasper/runtime/JspRuntimeLibrary.java
@@ -37,6 +37,7 @@ import javax.servlet.jsp.JspWriter;
 import javax.servlet.jsp.PageContext;
 import javax.servlet.jsp.tagext.BodyContent;
 
+import org.apache.jasper.Constants;
 import org.apache.jasper.JasperException;
 import org.apache.jasper.compiler.Localizer;
 
@@ -293,7 +294,7 @@ public class JspRuntimeLibrary {
                                         String param, boolean ignoreMethodNF)
                                         throws JasperException
     {
-        if( System.getSecurityManager() != null ) {
+        if( Constants.IS_SECURITY_ENABLED ) {
             try {
                 PrivilegedIntrospectHelper dp =
 		    new PrivilegedIntrospectHelper(
diff --git a/java/org/apache/jasper/security/SecurityUtil.java b/java/org/apache/jasper/security/SecurityUtil.java
index 6462a93..657a872 100644
--- a/java/org/apache/jasper/security/SecurityUtil.java
+++ b/java/org/apache/jasper/security/SecurityUtil.java
@@ -16,6 +16,8 @@
  */
 package org.apache.jasper.security;
 
+import org.apache.jasper.Constants;
+
 /**
  * Util class for Security related operations.
  *
@@ -32,7 +34,7 @@ public final class SecurityUtil{
      * package protection mechanism is enabled.
      */
     public static boolean isPackageProtectionEnabled(){
-        if (packageDefinitionEnabled && System.getSecurityManager() !=  null){
+        if (packageDefinitionEnabled && Constants.IS_SECURITY_ENABLED){
             return true;
         }
         return false;
diff --git a/java/org/apache/naming/Constants.java b/java/org/apache/naming/Constants.java
index 740977f..ffb3c42 100644
--- a/java/org/apache/naming/Constants.java
+++ b/java/org/apache/naming/Constants.java
@@ -27,4 +27,9 @@ public final class Constants {
 
     public static final String Package = "org.apache.naming";
 
+    /**
+     * Has security been turned on?
+     */
+    public static final boolean IS_SECURITY_ENABLED =
+        (System.getSecurityManager() != null);
 }
diff --git a/java/org/apache/naming/resources/DirContextURLConnection.java b/java/org/apache/naming/resources/DirContextURLConnection.java
index aa60769..2c85e7e 100644
--- a/java/org/apache/naming/resources/DirContextURLConnection.java
+++ b/java/org/apache/naming/resources/DirContextURLConnection.java
@@ -59,7 +59,7 @@ public class DirContextURLConnection
         if (context == null)
             throw new IllegalArgumentException
                 ("Directory context can't be null");
-        if (System.getSecurityManager() != null) {
+        if (org.apache.naming.Constants.IS_SECURITY_ENABLED) {
             this.permission = new JndiPermission(url.toString());
 	}
         this.context = context;

commit 9734c80789a3ff314ff02701f59003259b7a2cc5
Author: Remy Maucherat <remm@apache.org>
Date:   Fri Nov 3 10:56:25 2006 +0000

    - Remove an extra throwable.
    - Add a specific flag for recycling facades (when security is on, recycling will always be done, obviously).
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk@470756 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/connector/Connector.java b/java/org/apache/catalina/connector/Connector.java
index babc2f6..05eba1d 100644
--- a/java/org/apache/catalina/connector/Connector.java
+++ b/java/org/apache/catalina/connector/Connector.java
@@ -59,6 +59,13 @@ public class Connector
     private static Log log = LogFactory.getLog(Connector.class);
 
 
+    /**
+     * Alternate flag to enable recycling of facades.
+     */
+    public static final boolean RECYCLE_FACADES =
+        Boolean.valueOf(System.getProperty("org.apache.catalina.connector.RECYCLE_FACADES", "false")).booleanValue();
+
+    
     // ------------------------------------------------------------ Constructor
 
 
diff --git a/java/org/apache/catalina/connector/Request.java b/java/org/apache/catalina/connector/Request.java
index 61e3de2..ec35862 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -423,7 +423,7 @@ public class Request
         requestedSessionId = null;
         requestedSessionURL = false;
 
-        if (Constants.SECURITY) {
+        if (Constants.SECURITY || Connector.RECYCLE_FACADES) {
             parameterMap = new ParameterMap();
         } else {
             parameterMap.setLocked(false);
@@ -432,7 +432,7 @@ public class Request
 
         mappingData.recycle();
 
-        if (Constants.SECURITY) {
+        if (Constants.SECURITY || Connector.RECYCLE_FACADES) {
             if (facade != null) {
                 facade.clear();
                 facade = null;
diff --git a/java/org/apache/catalina/connector/Response.java b/java/org/apache/catalina/connector/Response.java
index d9c4bc8..4ab3c72 100644
--- a/java/org/apache/catalina/connector/Response.java
+++ b/java/org/apache/catalina/connector/Response.java
@@ -268,7 +268,7 @@ public class Response
         
         cookies.clear();
 
-        if (Constants.SECURITY) {
+        if (Constants.SECURITY || Connector.RECYCLE_FACADES) {
             if (facade != null) {
                 facade.clear();
                 facade = null;
diff --git a/java/org/apache/catalina/valves/ErrorReportValve.java b/java/org/apache/catalina/valves/ErrorReportValve.java
index 0c8b3c5..793bc13 100644
--- a/java/org/apache/catalina/valves/ErrorReportValve.java
+++ b/java/org/apache/catalina/valves/ErrorReportValve.java
@@ -153,8 +153,7 @@ public class ErrorReportValve
      *  a root cause exception
      */
     protected void report(Request request, Response response,
-                          Throwable throwable)
-        throws IOException {
+                          Throwable throwable) {
 
         // Do nothing on non-HTTP responses
         int statusCode = response.getStatus();

commit 574ec61724b26e610b8727603473d3c23ce4d474
Author: Remy Maucherat <remm@apache.org>
Date:   Fri Jul 7 22:35:25 2006 +0000

    - If there is a security manager, the map should be reset (otherwise, references could be kept).
    
    git-svn-id: https://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk@420002 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/java/org/apache/catalina/connector/Request.java b/java/org/apache/catalina/connector/Request.java
index 0066c5d..4892822 100644
--- a/java/org/apache/catalina/connector/Request.java
+++ b/java/org/apache/catalina/connector/Request.java
@@ -404,8 +404,12 @@ public class Request
         requestedSessionId = null;
         requestedSessionURL = false;
 
-        parameterMap.setLocked(false);
-        parameterMap.clear();
+        if (Constants.SECURITY) {
+            parameterMap = new ParameterMap();
+        } else {
+            parameterMap.setLocked(false);
+            parameterMap.clear();
+        }
 
         mappingData.recycle();
 
